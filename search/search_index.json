{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#npxpy","title":"npxpy","text":""},{"location":"#what-is-npxpy","title":"What is npxpy?","text":"<p>npxpy is a versatile open source Python package that enables you to build projects (NANO files) for the 3D direct laser  lithography system Nanoscribe Quantum X align via CLI/Scripts. It is designed such that it adheres to the same workflow logic as Nanoscribe's GUI software nanoPrintX, making the application additionally user-friendly to experienced users of the QXa.</p>"},{"location":"#how-to-install-it","title":"How to install it?","text":"<p>You can install <code>npxpy</code> via <code>pip</code> together with all features (recommended): <pre><code>pip install npxpy[all]\n</code></pre> It is recommended to install <code>npxpy</code> in a virtual environment to prevent dependency issues. A more selective installation with respect to features like the 3D-viewport or GDS-parsing is possible as well by exchanging <code>[all]</code> with <code>[viewport]</code> and <code>[gds]</code>, respectively. If you are interested in a light-weight installation you are able to install only the core features of <code>npxpy</code> via: <pre><code>pip install npxpy\n</code></pre> Beware that the light-weight installation lacks the other aforementioned features entirely. </p>"},{"location":"#how-to-use-it","title":"How to use it?","text":"<p>The print project preparation exhibits the usual workflow logic only that is embeded in the Python-software ecosystem with extras like GDS-parsing for high workflow integration. Below is the implementation of an example print project.  <pre><code>&gt;&gt;&gt; import npxpy\n&gt;&gt;&gt; #  Initialize the presets and resources that you want to use in this project.\n&gt;&gt;&gt; #  You can either load presets directly from a .toml...\n&gt;&gt;&gt; preset_from_file = npxpy.Preset.load_single(file_path=\"preset_from_file.toml\")\n&gt;&gt;&gt; \n&gt;&gt;&gt; #  ... or initialize it inside of your script.\n&gt;&gt;&gt; edit_presets = {\n...     \"writing_speed\": 220000.0,\n...     \"writing_power\": 50.0,\n...     \"slicing_spacing\": 0.8,\n...     \"hatching_spacing\": 0.3,\n...     \"hatching_angle\": 0.0,\n...     \"hatching_angle_increment\": 0.0,\n...     \"hatching_offset\": 0.0,\n...     \"hatching_offset_increment\": 0.0,\n...     \"hatching_back_n_forth\": True,\n...     \"mesh_z_offset\": 0.0,\n... }\n&gt;&gt;&gt; \n&gt;&gt;&gt; preset_from_args = npxpy.Preset(name=\"preset_from_args\", **edit_presets)\n&gt;&gt;&gt; \n&gt;&gt;&gt; #  Load your resources simply via path to their directories.\n&gt;&gt;&gt; stl_mesh = npxpy.Mesh(file_path=\"./example_mesh.stl\", name=\"stl_structure\")\n&gt;&gt;&gt; marker = npxpy.Image(file_path=\"./example_marker.png\", name=\"marker_image\")\n&gt;&gt;&gt; \n&gt;&gt;&gt; #  Initialize your project and load your presets and resources into it.\n&gt;&gt;&gt; project = npxpy.Project(objective=\"25x\", resin=\"IP-n162\", substrate=\"FuSi\")\n&gt;&gt;&gt; project.load_presets(preset_from_file, preset_from_args)\n&gt;&gt;&gt; project.load_resources(stl_mesh, marker)\n&gt;&gt;&gt; \n&gt;&gt;&gt; #  Prepare the nodes of your project as usual.\n&gt;&gt;&gt; #  Setup alignment nodes\n&gt;&gt;&gt; coarse_aligner = npxpy.CoarseAligner(residual_threshold=8)\n&gt;&gt;&gt; marker_aligner = npxpy.MarkerAligner(\n...     name=\"Marker Aligner\", image=marker, marker_size=[10, 10]\n... )\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Set anchors manually...\n&gt;&gt;&gt; ca_positions = [\n...     [200.0, 200.0, 0.0],\n...     [200.0, -200.0, 0.0],\n...     [-200.0, -200.0, 0.0],\n...     [-200.0, 200.0, 0.0],\n... ]\n&gt;&gt;&gt; ma_positions = [\n...     [0, 200, 0.33],\n...     [200, 0, 0.33],\n...     [0, -200, 0.33],\n...     [-200, 0, 0.33],\n... ]\n&gt;&gt;&gt; \n&gt;&gt;&gt; coarse_aligner.set_coarse_anchors_at(ca_positions)\n&gt;&gt;&gt; marker_aligner.set_markers_at(ma_positions)\n&gt;&gt;&gt; \n&gt;&gt;&gt; #  ... or incorporate them in a GDS-design and read them in.\n&gt;&gt;&gt; import npxpy.gds\n&gt;&gt;&gt;\n&gt;&gt;&gt; gds = npxpy.gds.GDSParser(\"gds_file.gds\")\n&gt;&gt;&gt; \n&gt;&gt;&gt; interface_aligner = gds.get_custom_interface_aligner(\n...     cell_name=\"cell_with_print_scene\",\n...     interface_layer=(1, 0),\n...     signal_type=\"reflection\",\n...     detector_type=\"confocal\",\n...     area_measurement=True,\n...     measure_tilt=True,\n... )\n&gt;&gt;&gt; \n&gt;&gt;&gt; #  Initialize printing scene\n&gt;&gt;&gt; scene = npxpy.Scene(name=\"scene\", writing_direction_upward=True)\n&gt;&gt;&gt; \n&gt;&gt;&gt; #  Initialize structure with desired preset and mesh defined above.\n&gt;&gt;&gt; structure = npxpy.Structure(\n...     name=\"structure\", preset=preset_from_file, mesh=stl_mesh\n... )\n&gt;&gt;&gt; \n&gt;&gt;&gt; #  Arrange hierarchy of all nodes as desired either with .add_child()...\n&gt;&gt;&gt; coarse_aligner.add_child(scene.add_child(interface_aligner))\n&gt;&gt;&gt; \n&gt;&gt;&gt; #  ...or more conveniently by using .append_node() to append\n&gt;&gt;&gt; #  consecutively to the lowest node.\n&gt;&gt;&gt; scene.append_node(marker_aligner, structure)\n&gt;&gt;&gt; \n&gt;&gt;&gt; #  Eventually, add all highest-order nodes of interest\n&gt;&gt;&gt; #  (here only coarse_aligner) to project.\n&gt;&gt;&gt; project.add_child(coarse_aligner)\n&gt;&gt;&gt; \n&gt;&gt;&gt; #  After allocating your nodes, you can copy, manipulate and add additional\n&gt;&gt;&gt; #  instances as you like.\n&gt;&gt;&gt; scene_1 = scene.deepcopy_node(copy_children=True)\n&gt;&gt;&gt; scene_1.name = \"scene_1\"\n&gt;&gt;&gt; scene_1.translate([254.0, 300.0, 0.0])\n&gt;&gt;&gt; \n&gt;&gt;&gt; #  You can access descendants/ancestors as you go via semantically ordered lists.\n&gt;&gt;&gt; structure_1 = scene_1.all_descendants[-1]\n&gt;&gt;&gt; structure_1.preset = preset_from_args\n&gt;&gt;&gt; structure_1.name = \"structure_1\"\n&gt;&gt;&gt; \n&gt;&gt;&gt; coarse_aligner.add_child(scene_1)\n&gt;&gt;&gt; \n&gt;&gt;&gt; #  Export your project to a .nano-file.\n&gt;&gt;&gt; project.nano(project_name=\"my_project\") \n</code></pre> Although only a scripting interface is provided for project preparation, the internal viewport (based on <code>pyvistaqt</code>) enables to keep track of your projects visually as well. <pre><code>&gt;&gt;&gt; viewport = project.viewport()\n</code></pre> </p> <p>If something does not go as intended, debugging tools make your life easier. <pre><code>&gt;&gt;&gt; project.tree()\nProject (project)\n    \u2514\u2500\u2500Coarse aligner (coarse_alignment)\n        \u251c\u2500\u2500scene (scene)\n        \u2502   \u2514\u2500\u2500cell_with_print_scene(1, 0) (interface_alignment)\n        \u2502       \u2514\u2500\u2500Marker Aligner (marker_alignment)\n        \u2502           \u2514\u2500\u2500structure (structure)\n        \u2514\u2500\u2500scene_1 (scene)\n            \u2514\u2500\u2500cell_with_print_scene(1, 0) (interface_alignment)\n                \u2514\u2500\u2500Marker Aligner (marker_alignment)\n                    \u2514\u2500\u2500structure_1 (structure)\n</code></pre></p>"},{"location":"#how-to-cite","title":"How to Cite","text":"<p>If npxpy contributes to your research, software, or project, we kindly request that you cite it in your publications using the provided DOI above.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details. TL;DR: You may use, modify, and distribute this software freely, provided the license and copyright notice are included.</p>"},{"location":"#what-this-means-for-users-and-contributors","title":"What This Means for Users and Contributors","text":"<ul> <li> <p>Freedom to Use: You are free to use this software in any project (commercial, personal, or otherwise) without restrictions, as long as the MIT License terms are met.</p> </li> <li> <p>Modifications and Derivatives: You may modify the code, create derivative works, and distribute them under any license of your choice. The only requirements are:</p> </li> <li>Include the original MIT License and copyright notice with your distribution.</li> <li>Clearly state any significant changes made to the original code.</li> <li> <p>Linking and Distribution: You may link this software with proprietary code or other open-source projects without restrictions. No obligations apply to the proprietary components of your project.</p> </li> <li> <p>Contribution: By contributing to this project, you agree that your contributions will be licensed under the MIT License. This ensures your changes remain freely usable by others under the same terms.</p> </li> </ul> <p>For more details on your rights and responsibilities under this license, please review the LICENSE file.</p>"},{"location":"CHANGELOG/","title":"CHANGELOG","text":""},{"location":"CHANGELOG/#v020-2025-08-27","title":"v0.2.0 (2025-08-27)","text":""},{"location":"CHANGELOG/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Deepcopy_node alignment_anchors issue   (<code>25c53c0</code>)</li> </ul>"},{"location":"CHANGELOG/#features","title":"Features","text":"<ul> <li> <p>Implement auto loading for presets/resources   (<code>fc6009a</code>)</p> </li> <li> <p>Implemented auto loading flags for images/meshes/presets. - Fixed possible multiloading of same   instances for meshes/presets during export. - Introduced 10x objective as possible parameter</p> </li> <li> <p>Implement method .get_scenes()   (<code>38e8ae4</code>)</p> </li> <li> <p>Implemented new method that is supposed to supersede method .marker_aligned_printing(). - Enhanced   method .gds_printing() by introducing option to tile for each polygon instead of the enclosing   bbox.</p> </li> </ul>"},{"location":"CHANGELOG/#v013-2025-03-28","title":"v0.1.3 (2025-03-28)","text":""},{"location":"CHANGELOG/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Hotfix missing positional argument: 'mesh'   (<code>50e0dfa</code>)</li> </ul>"},{"location":"CHANGELOG/#v012-2025-03-28","title":"v0.1.2 (2025-03-28)","text":""},{"location":"CHANGELOG/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li> <p>Attributes assigned but never passed to_dict()   (<code>f20d514</code>)</p> </li> <li> <p>Enforce passing of Preset and Mesh args   (<code>7680c97</code>)</p> </li> </ul> <p>Keeping Preset/Mesh for structures optional may cause issues with the TOML-parser during export if   not passed.</p> <ul> <li> <p>Resize pyvista text mesh for potential linebreaks   (<code>a8e9bf5</code>)</p> </li> <li> <p>Return self when appending nodes   (<code>647cca4</code>)</p> </li> </ul>"},{"location":"CHANGELOG/#documentation","title":"Documentation","text":"<ul> <li> <p>Add introductory example to Examples tab   (<code>28952ba</code>)</p> </li> <li> <p>Change \"Tutorials\" section to \"User Guide\"   (<code>de84b3e</code>)</p> </li> <li> <p>Create download for full example   (<code>1fd0ecf</code>)</p> </li> </ul> <p>docs: zip example</p> <ul> <li>Reorganize example section   (<code>d3329c5</code>)</li> </ul>"},{"location":"CHANGELOG/#v011-2025-03-17","title":"v0.1.1 (2025-03-17)","text":""},{"location":"CHANGELOG/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li> <p>Enhance data validation for position/rotation   (<code>8a580ff</code>)</p> </li> <li> <p>Implement a gatekeeper node class for better maintainability of nodes with position/rotation   attributes.</p> </li> <li> <p>Enable input of arbitrary iterable types and force entry datatypes to be float.</p> </li> </ul>"},{"location":"CHANGELOG/#documentation_1","title":"Documentation","text":"<ul> <li> <p>Add metadata references   (<code>820c192</code>)</p> </li> <li> <p>Deploy documentation   (<code>3213278</code>)</p> </li> </ul>"},{"location":"CHANGELOG/#v010-2025-03-17","title":"v0.1.0 (2025-03-17)","text":""},{"location":"CHANGELOG/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>Release on PyPI   (<code>ad2c923</code>)</li> </ul>"},{"location":"CHANGELOG/#documentation_2","title":"Documentation","text":"<ul> <li>Prepare docs for deployment   (<code>baae993</code>)</li> </ul>"},{"location":"CHANGELOG/#v000-2025-03-15","title":"v0.0.0 (2025-03-15)","text":""},{"location":"CHANGELOG/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>Add parent_node missing in deepcopy_node   (<code>f992fd8</code>)</li> </ul> <p>perf: implement recursive deepcopy_node</p> <p>chores: rename parents_nodes to parent_node</p> <ul> <li> <p>Add type check if input translation is list   (<code>c2e10dd</code>)</p> </li> <li> <p>Auto_load() for structure   (<code>1c13a69</code>)</p> </li> <li> <p>Case where len(position)=1   (<code>9571430</code>)</p> </li> <li> <p>Check for scene and not calling node (ronin scene check)   (<code>d274b6b</code>)</p> </li> <li> <p>Empty mesh plotting issues   (<code>9a5bfc5</code>)</p> </li> </ul> <p>Reason as to why this issue comes up is not apparent. Setting global theme accordingly seems to fix   the issue though.</p> <ul> <li> <p>Error in previous optimization   (<code>526c559</code>)</p> </li> <li> <p>File_path instead of path variable in resources   (<code>a592250</code>)</p> </li> <li> <p>Implement clean getter for node_type   (<code>961b668</code>)</p> </li> <li> <p>Implement errorhandling   (<code>3539a54</code>)</p> </li> </ul> <p>chores: add typing/docstrings/refactoring</p> <ul> <li> <p>Implement method _auto_center in Mesh   (<code>56a6eb2</code>)</p> </li> <li> <p>Implement new argument ordering   (<code>743b8ca</code>)</p> </li> <li> <p>Logo issues when calling viewport   (<code>8e1aea2</code>)</p> </li> </ul> <p>fix: remove/adjust versioning/redundant package declarations</p> <ul> <li> <p>Marker aligner takes three positions as it should.   (<code>b4190d1</code>)</p> </li> <li> <p>Optimize routines   (<code>f989829</code>)</p> </li> <li> <p>Optimized generation of all_ancestors/all_descendants - Omit self.geometry in .to_dict()</p> </li> <li> <p>Order of arguments for and in methods   (<code>d24c509</code>)</p> </li> <li> <p>Position_at rotation reset only if is not None   (<code>fe46e67</code>)</p> </li> <li> <p>Pull return out of loop in add_child method   (<code>ea58ebd</code>)</p> </li> <li> <p>Rename resin to resist in project_info dict   (<code>de62388</code>)</p> </li> <li> <p>Set default position/rotation for structure.postion_at()   (<code>28a1834</code>)</p> </li> <li> <p>Typo   (<code>77196e1</code>)</p> </li> <li> <p>Unpack in grab_node()   (<code>ef972b2</code>)</p> </li> <li> <p>Viewport cases for block render   (<code>8dff02d</code>)</p> </li> </ul> <p>feat: enhance append_node by applying as *args</p>"},{"location":"CHANGELOG/#chores","title":"Chores","text":"<ul> <li>Exchange toml with pytomlpp   (<code>d739de6</code>)</li> </ul>"},{"location":"CHANGELOG/#documentation_3","title":"Documentation","text":"<ul> <li> <p>Add example for stl sweep   (<code>2fe6baf</code>)</p> </li> <li> <p>Add examples (menger sponge and STL sweep)   (<code>ed7430d</code>)</p> </li> <li> <p>Adjusting and expanding on examples   (<code>3f9f3ac</code>)</p> </li> <li> <p>Adjusting/adding resources   (<code>5296a20</code>)</p> </li> <li> <p>Fix installation instructions   (<code>ec96eb8</code>)</p> </li> <li> <p>Fix typo   (<code>caec77d</code>)</p> </li> <li> <p>Prepare for release   (<code>e2471d4</code>)</p> </li> </ul>"},{"location":"CHANGELOG/#features_1","title":"Features","text":"<ul> <li> <p>Add (optional) submodule   (<code>8c10b4e</code>)</p> </li> <li> <p>Display color in viewport   (<code>69ac6c3</code>)</p> </li> <li> <p>Handle resources/presets now as *args   (<code>ee1ebdd</code>)</p> </li> <li> <p>Implement default labels   (<code>3fceb1a</code>)</p> </li> </ul> <p>more flexible input for interface anchors by list slicing/type handling</p> <ul> <li> <p>Implement new method auto_load   (<code>1260c25</code>)</p> </li> <li> <p>Implement project.viewport()   (<code>8fb8235</code>)</p> </li> </ul> <p>Current implementation is a rough prototype still missing some the visualization of some objects.   Refactoring necessary. chore: Exchange toml for pytomlpp in preset.py</p> <ul> <li> <p>Migrate viewport from Project to Node   (<code>4127f7b</code>)</p> </li> <li> <p>Add labels for markers in viewport - Add xyz-axes to viewport</p> </li> <li> <p>Project-viewport implementation   (<code>fec23e9</code>)</p> </li> </ul>"},{"location":"CHANGELOG/#performance-improvements","title":"Performance Improvements","text":"<ul> <li> <p>Increase opacity of marker labels   (<code>c2f838f</code>)</p> </li> <li> <p>Try to introduce compositions via pv.MultiBlock()   (<code>abc6c86</code>)</p> </li> </ul>"},{"location":"CHANGELOG/#testing","title":"Testing","text":"<ul> <li> <p>Add minor changes for viewport testing   (<code>6848119</code>)</p> </li> <li> <p>Added some readme   (<code>019612b</code>)</p> </li> <li> <p>Refined test cases for multiple nodes.   (<code>c40a398</code>)</p> </li> </ul>"},{"location":"examples/example_README/example0/","title":"Introductory Example","text":""},{"location":"examples/example_README/example0/#overview","title":"Overview","text":"<p>The code provided in this section is the introductory example as given on the Github repository's Readme and the documentation's Home tab.</p> <p>This script:</p> <ul> <li>Loads printing presets and resources:  </li> <li>Reads a <code>.toml</code> preset file and initializes custom presets with parameters like writing speed, power, and hatching settings.  </li> <li> <p>Imports a 3D mesh (<code>example_mesh.stl</code>) and a marker image (<code>example_marker.png</code>).  </p> </li> <li> <p>Sets up alignment configurations:  </p> </li> <li>Defines <code>CoarseAligner</code> and <code>MarkerAligner</code> nodes for nano-printing alignment, with manual anchor positions.  </li> <li> <p>Integrates GDS cell data (<code>gds_file.gds</code>) to create a custom <code>InterfaceAligner</code> with anchor positions/scan sizes defined by polygons in a GDS file.  </p> </li> <li> <p>Organizes the printing hierarchy:  </p> </li> <li>Initializes a <code>Scene</code> with upward writing direction and attaches a <code>Structure</code> (using the mesh and preset).  </li> <li> <p>Builds a node hierarchy with coarse alignment, scene, interface alignment, and marker alignment.  </p> </li> <li> <p>Duplicates and modifies scenes:  </p> </li> <li> <p>Clones scenes, translates their positions, and updates their presets/names for multi-scene arrangements.  </p> </li> <li> <p>Exports the project:  </p> </li> <li>Generates a <code>.nano</code> file for and validates node hierarchy via <code>project.tree()</code>.</li> </ul> <p>Prerequisites</p> <p>Files/Directories: - <code>preset_from_file.toml</code> (preset configuration). - <code>example_mesh.stl</code> (3D structure mesh). - <code>example_marker.png</code> (alignment marker image). - <code>gds_file.gds</code> (GDSII design for interface alignment).  </p> <p>Python Packages: - <code>npxpy</code> installed with key <code>all</code>: <code>pip install npxpy[all]</code>. - <code>shapely</code> &amp; <code>gdshelpers</code> (for GDS parsing and geometry operations).</p> <p>You can download the full example below:</p> <p>Download full example</p>"},{"location":"examples/example_README/example0/#full-implementation","title":"Full Implementation","text":"<pre><code>import npxpy\n\n#  Initialize the presets and resources that you want to use in this project.\n#  You can either load presets directly from a .toml...\npreset_from_file = npxpy.Preset.load_single(file_path=\"preset_from_file.toml\")\n\n#  ... or initialize it inside of your script.\nedit_presets = {\n    \"writing_speed\": 220000.0,\n    \"writing_power\": 50.0,\n    \"slicing_spacing\": 0.8,\n    \"hatching_spacing\": 0.3,\n    \"hatching_angle\": 0.0,\n    \"hatching_angle_increment\": 0.0,\n    \"hatching_offset\": 0.0,\n    \"hatching_offset_increment\": 0.0,\n    \"hatching_back_n_forth\": True,\n    \"mesh_z_offset\": 0.0,\n}\n\npreset_from_args = npxpy.Preset(name=\"preset_from_args\", **edit_presets)\n\n#  Load your resources simply via path to their directories.\nstl_mesh = npxpy.Mesh(file_path=\"./example_mesh.stl\", name=\"stl_structure\")\nmarker = npxpy.Image(file_path=\"./example_marker.png\", name=\"marker_image\")\n\n#  Initialize your project and load your presets and resources into it.\nproject = npxpy.Project(objective=\"25x\", resin=\"IP-n162\", substrate=\"FuSi\")\nproject.load_presets(preset_from_file, preset_from_args)\nproject.load_resources(stl_mesh, marker)\n\n#  Prepare the nodes of your project as usual.\n#  Setup alignment nodes\ncoarse_aligner = npxpy.CoarseAligner(residual_threshold=8)\nmarker_aligner = npxpy.MarkerAligner(\n    name=\"Marker Aligner\", image=marker, marker_size=[10, 10]\n)\n\n# Set anchors manually...\nca_positions = [\n    [200.0, 200.0, 0.0],\n    [200.0, -200.0, 0.0],\n    [-200.0, -200.0, 0.0],\n    [-200.0, 200.0, 0.0],\n]\n\nma_positions = [\n    [0, 200, 0.33],\n    [200, 0, 0.33],\n    [0, -200, 0.33],\n    [-200, 0, 0.33],\n]\n\ncoarse_aligner.set_coarse_anchors_at(ca_positions)\nmarker_aligner.set_markers_at(ma_positions)\n\n#  ... or incorporate them in a GDS-design and read them in.\nimport npxpy.gds\n\ngds = npxpy.gds.GDSParser(\"gds_file.gds\")\n\ninterface_aligner = gds.get_custom_interface_aligner(\n    cell_name=\"cell_with_print_scene\",\n    interface_layer=(1, 0),\n    signal_type=\"reflection\",\n    detector_type=\"confocal\",\n    area_measurement=True,\n    measure_tilt=True,\n)\n\n#  Initiale printing scene\nscene = npxpy.Scene(name=\"scene\", writing_direction_upward=True)\n\n#  Initialize structure with desired preset and mesh defined above.\nstructure = npxpy.Structure(\n    name=\"structure\", preset=preset_from_file, mesh=stl_mesh\n)\n\n#  Arrange hierarchy of all nodes as desired either with .add_child()...\ncoarse_aligner.add_child(scene.add_child(interface_aligner))\n\n#  ...or more conveniently by using .append_node() to append\n#  consecutively to the lowest node.\nscene.append_node(marker_aligner, structure)\n\n#  Eventually, add all highest-order nodes of interest\n#  (here only coarse_aligner) to project.\nproject.add_child(coarse_aligner)\n\n#  After allocating your nodes, you can copy, manipulate and add additional\n#  instances as you like.\nscene_1 = scene.deepcopy_node(copy_children=True)\nscene_1.name = \"scene_1\"\nscene_1.translate([254.0, 300.0, 0.0])\n\n#  You can access descendants/ancestors as you go via semantically ordered lists.\nstructure_1 = scene_1.all_descendants[-1]\nstructure_1.preset = preset_from_args\nstructure_1.name = \"structure_1\"\n\ncoarse_aligner.add_child(scene_1)\n\n#  Checking the node order can be done as well\nproject.tree()\n\n#  Export your project to a .nano-file.\nproject.nano(project_name=\"my_project\")\n</code></pre> <p>In addition, you can regard your project in the viewport.</p> <pre><code>#  Check Project in Viewport\n\nproject.viewport()\n</code></pre> <p></p>"},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/","title":"Structured Sweep of Cylinders with GDS Markers","text":""},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/#overview","title":"Overview","text":"<p>This tutorial demonstrates creating a parameter sweep of 3D-printed cylinders with alignment markers, combining both 3D print project and 2D GDS layout preparation in a single script. For generating the GDS-layout in Python we will make use of the package <code>gsdhelpers</code>.</p> <p>This script: </p> <ol> <li>Loads printing presets and resources (cylinders, marker image).  </li> <li>Defines helper functions to create marker patterns and cells.  </li> <li>Sets up coarse, interface, and marker aligners for nano-scale 3D printing.  </li> <li>Arranges multiple scenes in a grid, each containing a cylinder structure and a textual label describing its    geometric parameters.  </li> <li>Integrates 2D GDS cell generation (for markers) alongside the 3D scenes.  </li> <li>Exports the final configuration as a .nano file and a GDS file.  </li> </ol> <p>Prerequisites: </p> <ul> <li>A valid <code>25x_IP-n162_cylinders.toml</code> preset file.  </li> <li>A <code>meshes/</code> directory containing cylinder meshes named in a numeric sequence.  </li> <li>A <code>marker.png</code> image for the marker aligner.  </li> <li>The <code>npxpy[viewport]</code>, <code>shapely</code>, <code>gdshelpers</code>, and <code>numpy</code> packages installed.</li> </ul> <p>You can download the full example below:</p> <p>Download full example</p>"},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/#helper-functions","title":"Helper Functions","text":"<p>Marker Pattern Creation</p> <pre><code>def create_marker_pattern(center, size):\n    \"\"\"\n    Create a simple marker pattern composed of two polygons forming a corner shape.\n    \"\"\"\n    x, y = center[0], center[1]\n    half_size = size / 2\n\n    # Define two adjoining square-like polygons\n    square1 = Polygon(\n        [\n            (x - half_size, y),\n            (x, y),\n            (x, y + half_size),\n            (x - half_size, y + half_size),\n        ]\n    )\n    square2 = Polygon(\n        [\n            (x, y - half_size),\n            (x + half_size, y - half_size),\n            (x + half_size, y),\n            (x, y),\n        ]\n    )\n    return MultiPolygon([square1, square2])\n</code></pre> <p>GDS Marker Cell Creation</p> <pre><code>def create_marker_cell(name, positions):\n    \"\"\"\n    Create a GDS cell containing marker patterns at specified positions.\n    \"\"\"\n    cell = Cell(name)\n    marker_size = 13  # Fixed marker size in micrometers\n\n    for pos in positions:\n        pattern = create_marker_pattern((pos[0], pos[1]), marker_size)\n        cell.add_to_layer(1, pattern)\n    return cell\n</code></pre>"},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/#implementation-steps","title":"Implementation Steps","text":""},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/#step-1-loading-presets-and-resources","title":"Step 1: Loading Presets and Resources","text":"<p>Load a preset file which defines printing parameters. Load a series of cylinder meshes from the <code>meshes/</code> directory. The filenames are expected to follow a pattern like <code>cylinder_0.stl</code>, <code>cylinder_1.stl</code>, ... . <pre><code>preset = npxpy.Preset.load_single(file_path=\"25x_IP-n162_cylinders.toml\")\n\n# Sorting by the numeric suffix ensures a known order of cylinders.\ncylinder_meshes = [\n    npxpy.Mesh(file_path=f\"meshes/{mesh}\", name=f\"{mesh}\")\n    for mesh in sorted(\n        os.listdir(\"meshes\"), key=lambda x: int(x.split(\".\")[0].split(\"_\")[-1])\n    )\n]\n\n# Load a marker image for fine alignment tasks later on.\nmarker = npxpy.Image(file_path=\"marker.png\", name=\"marker_image\")\n</code></pre></p>"},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/#step-2-initializing-the-project","title":"Step 2: Initializing the Project","text":"<p>Initialize the project with chosen objective, resin, and substrate parameters. <pre><code>project = npxpy.Project(objective=\"25x\", resin=\"IP-n162\", substrate=\"FuSi\")\n\n# Load presets and resources (marker image and cylinder meshes) into the project.\nproject.load_presets(preset)\nproject.load_resources(marker)\nproject.load_resources(cylinder_meshes)\n</code></pre></p>"},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/#step-3-gds-cell-initialization-for-markers","title":"Step 3: GDS Cell Initialization for Markers","text":"<p>In addition to the 3D printing scenes, we will also create a GDS cell that represents a top-down view of marker patterns. This can be used to generate 2D layouts. <pre><code>gds_cell = Cell(\"sweep_scene_array\")\n</code></pre></p>"},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/#step-4-setting-up-the-coarse-aligner","title":"Step 4: Setting Up the Coarse Aligner","text":"<p>The coarse aligner defines a rough reference frame using four anchor points placed at known sample coordinates. <pre><code>coarse_aligner_labels = [\"anchor 0\", \"anchor 1\", \"anchor 2\", \"anchor 3\"]\ncoarse_aligner_positions = [\n    [-100.0, -100.0, 0.0],\n    [1900.0, -100.0, 0.0],\n    [1900.0, 1900.0, 0.0],\n    [-100.0, 1900.0, 0.0],\n]\n\n# Initialize the coarse aligner with a tolerance (residual_threshold) defining\n# how precisely anchors must align.\ncoarse_aligner = npxpy.CoarseAligner(residual_threshold=5)\ncoarse_aligner.set_coarse_anchors_at(\n    labels=coarse_aligner_labels, positions=coarse_aligner_positions\n)\nproject.add_child(coarse_aligner)\n</code></pre></p>"},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/#step-5-adding-a-frame-pattern-for-each-anchor-in-gds","title":"Step 5: Adding a Frame Pattern for Each Anchor in GDS","text":"<p>We create a larger frame pattern around each coarse anchor to visualize their positions in GDS. This provides a 2D reference map of the entire scene array.</p> <pre><code>frame_marker_size = 25\n\nfor pos, label in zip(coarse_aligner_positions, coarse_aligner_labels):\n    # Create a frame pattern bigger than the marker patterns used inside scenes.\n    frame_pattern = create_marker_pattern(pos, frame_marker_size)\n\n    # Create a dedicated cell for this frame pattern and label it.\n    gds_cell_frame_pattern = Cell(label)\n    gds_cell_frame_pattern.add_to_layer(1, frame_pattern)\n\n    # Add a text label indicating the anchor\u2019s name below the pattern.\n    # The text is shifted slightly downward (e.g., 25 \u00b5m) from the anchor position.\n    gds_cell_frame_pattern.add_to_layer(\n        1,\n        Text(\n            origin=tuple(np.array(pos[:-1]) - np.array([0, 25])),\n            height=5,\n            text=label,\n            alignment=\"center-center\",\n        ),\n    )\n\n    # Add the frame-pattern cell to the main GDS cell.\n    gds_cell.add_cell(gds_cell_frame_pattern)\n</code></pre>"},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/#step-6-interface-alignment","title":"Step 6: Interface Alignment","text":"<p>The interface aligner refines alignment at the substrate interface level. Four interface markers define a plane onto which printing occurs. <pre><code>interface_aligner_labels = [\"marker 0\", \"marker 1\", \"marker 2\", \"marker 3\"]\ninterface_aligner_positions = [\n    [0.0, 50.0],\n    [50.0, 0.0],\n    [-50.0, 0.0],\n    [0.0, -50.0],\n]\n\ninterface_aligner = npxpy.InterfaceAligner(name=\"Interface Aligner\")\ninterface_aligner.set_interface_anchors_at(\n    labels=interface_aligner_labels, positions=interface_aligner_positions\n)\n</code></pre></p>"},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/#step-7-marker-alignment","title":"Step 7: Marker Alignment","text":"<p>The marker aligner uses an image and marker positions to achieve fine alignment accuracy. Each marker is placed at a known coordinate with a given orientation. Here we define a cluster of four markers forming a square.</p> <pre><code>marker_aligner_labels = [\"marker 0\", \"marker 1\", \"marker 2\", \"marker 3\"]\nmarker_aligner_orientations = [0.0, 0.0, 0.0, 0.0]\nmarker_aligner_positions = [\n    [-50.0, -50.0, 0.0],\n    [-50.0, 50.0, 0.0],\n    [50.0, 50.0, 0.0],\n    [50.0, -50.0, 0.0],\n]\n\nmarker_aligner = npxpy.MarkerAligner(\n    name=\"Marker Aligner\", image=marker, marker_size=[13, 13]\n)\nmarker_aligner.set_markers_at(\n    labels=marker_aligner_labels,\n    orientations=marker_aligner_orientations,\n    positions=marker_aligner_positions,\n)\n</code></pre>"},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/#step-8-creating-a-base-scene","title":"Step 8: Creating a Base Scene","text":"<p>Create a base scene to which we attach the interface and marker aligners. We will replicate this scene multiple times, placing cylinders and labels at various positions to form a parameter sweep. <pre><code>sweep_scene = npxpy.Scene(name=\"scene_0\", writing_direction_upward=True)\nsweep_scene.append_node(interface_aligner)\nsweep_scene.append_node(marker_aligner)\n</code></pre></p>"},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/#step-9-generating-a-grid-of-scenes","title":"Step 9: Generating a Grid of Scenes","text":"<p>We want a 10x10 grid of scenes, each displaced in x and y by 200 \u00b5m.  Each scene will have a unique cylinder and text label.</p> <pre><code>count_x = 10\npitch_x = 200\ncount_y = 10\npitch_y = 200\n\n# Generate a list of positions for each scene in a grid layout.\nsweep_scenes_positions = [\n    [x, y, 0]\n    for y in range(0, count_y * pitch_y, pitch_y)\n    for x in range(0, count_x * pitch_x, pitch_x)\n]\n\n# Define text labels corresponding to cylinder radius (r) and height (h).\n# r varies from 5 to 50 in steps of 5, and h varies from 10 to 100 in steps of 10.\n# This creates 100 unique labels for 100 cylinders.\ntext_labels = [\n    f\"r={r}\\nh={h}\"\n    for r in range(5, 55, 5)\n    for h in range(10, 110, 10)\n]\n\n# Create a separate scene instance (deepcopy) for each grid position.\nsweep_scenes_list = [\n    sweep_scene.deepcopy_node().position_at(position=pos, rotation=[0, 0, 0])\n    for pos in sweep_scenes_positions\n]\n</code></pre>"},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/#step-10-adding-cylinders-and-labels-to-each-scene","title":"Step 10: Adding Cylinders and Labels to Each Scene","text":"<p>For each cylinder and scene, we attach:  - The cylinder structure (with preset parameters).  - A text label describing the radius/height and file name.  - Update the GDS layout with corresponding marker patterns for reference. <pre><code>for cylinder, scene_instance, text in zip(\n    cylinder_meshes, sweep_scenes_list, text_labels\n):\n    # Create the cylinder structure node using the loaded preset.\n    cylinder_structure = npxpy.Structure(\n        name=cylinder.name, preset=preset, mesh=cylinder\n    )\n    scene_instance.append_node(cylinder_structure)\n\n    # Create a text label node showing the cylinder parameters and mesh name.\n    # Position it slightly below the cylinder (shifted by -75 \u00b5m in y) so they don't overlap.\n    text_label = npxpy.Text(\n        position=cylinder_structure.position,\n        text=f\"{text}\\n{cylinder_structure.name}\",\n        preset=preset,\n    )\n    text_label.translate([0, -75, 0])\n\n    # Find the marker aligner node within the current scene to ensure text and cylinder\n    # share the same alignment reference.\n    marker_aligner_in_scene = scene_instance.grab_all_nodes_bfs(\n        \"marker_alignment\"\n    )[0]\n    marker_aligner_in_scene.add_child(text_label)\n\n    # Add the fully populated scene (with cylinder and text) to the coarse aligner\n    # so that it\u2019s integrated into the global coordinate system.\n    coarse_aligner.add_child(scene_instance)\n\n    # Additionally, create a GDS marker cell for each scene corresponding to the\n    # marker positions. This gives a top-down 2D reference for the array layout.\n    gds_marker_cell = create_marker_cell(\n        cylinder_structure.name, marker_aligner_positions\n    )\n    gds_cell.add_cell(\n        gds_marker_cell, origin=tuple(scene_instance.position[:-1])\n    )\n</code></pre></p>"},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/#step-11-exporting-the-project","title":"Step 11: Exporting the Project","text":"<p>Export the entire project configuration to a NANO-file and save the GDS-design <pre><code>project.nano(project_name=\"cylinder_params_sweep\")\ngds_cell.save(\"cylinder_params_sweep.gds\")\n</code></pre></p>"},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/#step-12-optional-check-project-in-viewport","title":"Step 12 (optional): Check Project in Viewport","text":"<pre><code>project.viewport()\n</code></pre>"},{"location":"examples/example_stl_sweep/example_stl_sweep_with_gds/#end-of-example","title":"End of Example","text":"<p>In this script, we demonstrated how to:</p> <ul> <li>Load presets, meshes, and marker images for use in a nano-scale 3D printing project.</li> <li>Set up coarse, interface, and marker aligners to establish a precise coordinate system.</li> <li>Create a grid of scenes containing parameter-swept cylinders and text labels.</li> <li>Incorporate GDS cell generation to represent marker patterns in a 2D layout.</li> <li>Export the final configuration to a NANO-file for printing and a GDS-file for reference.</li> </ul> <p>Consider experimenting with:</p> <ul> <li>Different pitches, counts, and parameter ranges for your structures.</li> <li>Alternative marker positions, orientations, and amounts.</li> <li>Additional preset files or combining multiple structure types in the array with different presets.</li> </ul>"},{"location":"gds/GDSParser/","title":"npxpy.gds.GDSParser","text":"<p>Parser for GDSII layout files with dependency management and validation.</p> <p>Attributes:</p> Name Type Description <code>gds_file</code> <code>str</code> <p>Path to the loaded GDSII file</p> <code>layout</code> <code>Layout</code> <p>Parsed GDSII layout object</p> <code>gds_name</code> <code>str</code> <p>Base name of the GDS file without extension</p> Source code in <code>npxpy/gds.py</code> <pre><code>class GDSParser:\n    \"\"\"Parser for GDSII layout files with dependency management and validation.\n\n    Attributes:\n        gds_file (str): Path to the loaded GDSII file\n        layout (pya.Layout): Parsed GDSII layout object\n        gds_name (str): Base name of the GDS file without extension\n    \"\"\"\n\n    _REQUIRED_DEPS: List[str] = [\"numpy\", \"shapely\", \"trimesh\", \"PIL\"]\n\n    def __init__(self, gds_file: str) -&gt; None:\n        \"\"\"Initialize GDS parser with file validation and dependency checks.\n\n        Args:\n            gds_file: Path to GDSII file to load\n\n        Raises:\n            ImportError: If required dependencies are missing\n            FileNotFoundError: If specified file doesn't exist\n            ValueError: For invalid file types or parsing errors\n        \"\"\"\n        self.gds_file = gds_file  # Validated through property setter\n        self._layout = pya.Layout()\n        self._layout.read(gds_file)  # Let pya exceptions bubble up\n        self._plot_tiles_flag = False\n        self._previous_image_safe_path_marker_aligned_printing = \"0/0\"\n        self._check_dependencies()\n\n    def _check_dependencies(self) -&gt; None:\n        \"\"\"Verify required dependencies are installed.\n\n        Raises:\n            ImportError: With list of missing dependencies\n        \"\"\"\n        missing = [dep for dep in self._REQUIRED_DEPS if dep in _MISSING_DEPS]\n        if missing:\n            raise ImportError(\n                f\"Missing required dependencies: {', '.join(missing)}\\n\"\n                \"Install either with: pip install npxpy[gds]\\n\"\n                \"or with: pip install npxpy[all]\"\n            )\n\n    @property\n    def gds_file(self) -&gt; str:\n        \"\"\"Get path to loaded GDS file.\"\"\"\n        return self._gds_file\n\n    @property\n    def layout(self) -&gt; pya.Layout:\n        \"\"\"Get parsed GDS layout object.\"\"\"\n        return self._layout\n\n    @property\n    def gds_name(self) -&gt; str:\n        \"\"\"Get base name of GDS file without extension.\"\"\"\n        base = os.path.basename(self.gds_file)\n        return os.path.splitext(base)[0]\n\n    @gds_file.setter\n    def gds_file(self, value: str) -&gt; None:\n        \"\"\"Validate and set new GDS file path.\n\n        Args:\n            value: Path to new GDS file\n\n        Raises:\n            TypeError: For non-string input\n            FileNotFoundError: If file doesn't exist\n            ValueError: For non-GDS file extension\n        \"\"\"\n        if not isinstance(value, str):\n            raise TypeError(f\"Expected string path, got {type(value)}\")\n\n        norm_path = os.path.normpath(value)\n        if not os.path.isfile(norm_path):\n            raise FileNotFoundError(f\"GDS file not found: {norm_path}\")\n\n        if not value.lower().endswith(\".gds\"):\n            raise ValueError(\"File must have .gds extension\")\n\n        self._gds_file = norm_path\n\n    def _gather_polygons_in_child_cell(self, child_cell, layer_to_print):\n        \"\"\"\n        Return a list of NumPy arrays containing polygon coordinates in the given\n        cell.\n        \"\"\"\n        polygons = []\n        for shape in child_cell.shapes(layer_to_print):\n            if shape.is_polygon() or shape.is_box():\n                poly = shape.dpolygon\n                # Convert the polygon's points to a NumPy array\n                coords = np.array([(p.x, p.y) for p in poly.each_point_hull()])\n                polygons.append(coords)\n        return polygons\n\n    def _polygons_to_shapely(self, polygons_np):\n        \"\"\"\n        Convert a list of NumPy arrays (each shape (N,2))\n        into a list of shapely Polygons.\n        \"\"\"\n        shapely_polygons = []\n        for arr in polygons_np:\n            # Ensure closure if needed, or let Shapely handle it\n            # Note: If your arrays are not closed, Shapely still interprets them as closed\n            shapely_polygons.append(Polygon(arr))\n        return shapely_polygons\n\n    def _tile_polygon(self, ix, iy, tile_size, epsilon):\n        \"\"\"\n        Return a shapely Polygon for the tile at (ix, iy),\n        where each tile is 100\u00d7100, and (0,0) tile is centered around the origin:\n           =&gt; x in [ix*100 - 50, ix*100 + 50]\n           =&gt; y in [iy*100 - 50, iy*100 + 50]\n        \"\"\"\n        xmin = ix * tile_size - tile_size / 2 - epsilon\n        xmax = ix * tile_size + tile_size / 2 + epsilon\n        ymin = iy * tile_size - tile_size / 2 - epsilon\n        ymax = iy * tile_size + tile_size / 2 + epsilon\n        return box(xmin, ymin, xmax, ymax)  # shapely box\n\n    def _get_bounding_box(self, shapely_polygons):\n        \"\"\"\n        Returns (min_x, min_y, max_x, max_y) that bounds all given shapely polygons.\n        \"\"\"\n        minx = min(poly.bounds[0] for poly in shapely_polygons)\n        miny = min(poly.bounds[1] for poly in shapely_polygons)\n        maxx = max(poly.bounds[2] for poly in shapely_polygons)\n        maxy = max(poly.bounds[3] for poly in shapely_polygons)\n        return (minx, miny, maxx, maxy)\n\n    def _tile_indices_for_bounding_box(\n        self, minx, miny, maxx, maxy, tile_size\n    ):\n        \"\"\"\n        Given a bounding box and tile size (100 by default),\n        yield (ix, iy) indices that cover all polygons.\n\n        We define tiles so that the tile at (0,0) covers x in [-50, 50], y in [-50, 50].\n        That means for a tile index (ix, iy), the tile covers:\n            x in [ix*100 - 50, ix*100 + 50]\n            y in [iy*100 - 50, iy*100 + 50].\n        \"\"\"\n        # Figure out what range of indices we need in x and y directions\n        # We shift coordinates so that \"center\" tile is from -50 to 50, etc.\n        # Solve for ix such that ix*100 - 50 &lt;= minx  =&gt;  ix &lt;= (minx + 50)/100.\n        # But we need integer steps. We'll take floor for start, ceil for end.\n\n        # X range\n        ix_min = math.floor(\n            (minx + tile_size / 2) / tile_size\n        )  # leftmost tile index\n        ix_max = math.ceil(\n            (maxx + tile_size / 2) / tile_size\n        )  # rightmost tile index\n\n        # Y range\n        iy_min = math.floor(\n            (miny + tile_size / 2) / tile_size\n        )  # bottom tile index\n        iy_max = math.ceil(\n            (maxy + tile_size / 2) / tile_size\n        )  # top tile index\n\n        for ix in range(ix_min, ix_max):\n            for iy in range(iy_min, iy_max):\n                yield ix, iy\n\n    def _clip_polygons_to_tiles(self, shapely_polygons, tile_size, epsilon):\n        \"\"\"\n        Main routine:\n          1) Find bounding box of all polygons\n          2) Figure out which tiles we need\n          3) For each tile, intersect with each polygon\n          4) Collect non-empty intersections in a result dictionary\n\n        Returns a dict: {\n           (ix, iy): [list of clipped Polygons / MultiPolygons within that tile]\n        }\n        \"\"\"\n        # 1) bounding box\n        minx, miny, maxx, maxy = self._get_bounding_box(shapely_polygons)\n\n        # 2) gather tiles\n        tile_dict = {}  # (ix, iy) -&gt; list of shapely geometries\n        for ix, iy in self._tile_indices_for_bounding_box(\n            minx, miny, maxx, maxy, tile_size\n        ):\n            tile_poly = self._tile_polygon(ix, iy, tile_size, epsilon)\n            # 3) intersect with each polygon\n            clipped_list = []\n            for poly in shapely_polygons:\n                intersection = poly.intersection(tile_poly)\n                if not intersection.is_empty:\n                    clipped_list.append(intersection)\n            # Store if we got any intersection\n            if clipped_list:\n                tile_dict[(ix, iy)] = clipped_list\n        return tile_dict\n\n    def _tile_polygons(self, polygons_np, tile_size, epsilon):\n        # 1) Convert to shapely Polygons\n        shapely_polys = self._polygons_to_shapely(polygons_np)\n\n        # 2) Clip polygons to tiles\n        tile_dict = self._clip_polygons_to_tiles(\n            shapely_polys, tile_size=tile_size, epsilon=epsilon\n        )\n\n        # Print how many tiles we actually used\n        print(f\"Number of tiles with content: {len(tile_dict)}\")\n        for tile_idx, clipped_geoms in tile_dict.items():\n            print(\n                f\"Tile {tile_idx} has {len(clipped_geoms)} clipped polygon(s)\"\n            )\n\n        # OPTIONAL: Visualize result\n        if self._plot_tiles_flag:\n            import matplotlib.pyplot as plt\n\n            fig, ax = plt.subplots(figsize=(8, 8))\n\n            # Draw each tile that has content\n            for (ix, iy), geoms in tile_dict.items():\n                tile_poly = self._tile_polygon(\n                    ix, iy, tile_size=tile_size, epsilon=epsilon\n                )\n                # Draw tile boundary\n                x_tile, y_tile = tile_poly.exterior.xy\n                ax.plot(x_tile, y_tile, \"k--\", alpha=0.3)\n\n                # Draw clipped polygons\n                for geom in geoms:\n                    if geom.geom_type == \"Polygon\":\n                        x, y = geom.exterior.xy\n                        ax.fill(x, y, alpha=0.5)\n                        for hole in geom.interiors:\n                            xh, yh = hole.xy\n                            ax.fill(xh, yh, color=\"white\")\n                    elif geom.geom_type == \"MultiPolygon\":\n                        for part in geom.geoms:\n                            x, y = part.exterior.xy\n                            ax.fill(x, y, alpha=0.5)\n                            for hole in part.interiors:\n                                xh, yh = hole.xy\n                                ax.fill(xh, yh, color=\"white\")\n\n            ax.set_aspect(\"equal\", \"box\")\n            ax.set_xlabel(\"X\")\n            ax.set_ylabel(\"Y\")\n            ax.set_title(\n                f\"Polygons clipped to {tile_size}um x {tile_size}um tiles\"\n            )\n            plt.grid(True)\n            plt.show()\n\n        return tile_dict\n\n    def _extrude_shapely_geometry(\n        self,\n        geometry,\n        thickness,\n        hollow=False,\n        hollow_scale=0.9,\n        hollow_shift_z=0.0,\n    ):\n        \"\"\"\n        Extrude a Shapely geometry (Polygon or MultiPolygon) into a Trimesh mesh.\n        Optionally create a hollow mesh by scaling and shifting an inner copy.\n\n        Args:\n            geometry: Shapely Polygon or MultiPolygon.\n            thickness: Z-axis extrusion height.\n            hollow: If True, generate a hollow mesh (default: False).\n            hollow_scale: Scaling factor for inner geometry (0 &lt; scale &lt; 1).\n            hollow_shift_z: Z-axis shift for inner geometry (relative to base).\n\n        Returns:\n            Trimesh mesh or None if geometry is empty.\n        \"\"\"\n\n        # Validate hollow parameters\n        if hollow:\n            if hollow_scale &lt;= 0 or hollow_scale &gt;= 1:\n                raise ValueError(\n                    \"hollow_scale must be between 0 and 1 (exclusive)\"\n                )\n            if not (-thickness &lt;= hollow_shift_z &lt;= thickness):\n                raise ValueError(\n                    \"hollow_shift_z must be within [-thickness, thickness]\"\n                )\n\n        # Create the original solid mesh\n        meshes = []\n        if geometry.geom_type == \"Polygon\":\n            mesh = trimesh.creation.extrude_polygon(geometry, thickness)\n            meshes.append(mesh)\n        elif geometry.geom_type == \"MultiPolygon\":\n            for poly in geometry.geoms:\n                mesh = trimesh.creation.extrude_polygon(poly, thickness)\n                meshes.append(mesh)\n\n        if not meshes:\n            return None  # Empty geometry\n\n        outer_mesh = (\n            meshes[0] if len(meshes) == 1 else trimesh.util.concatenate(meshes)\n        )\n\n        # Early return if not hollow\n        if not hollow:\n            return outer_mesh\n\n        # Create inner geometry (scaled)\n        if geometry.geom_type == \"Polygon\":\n            inner_geom = shapely_scale(\n                geometry,\n                xfact=hollow_scale,\n                yfact=hollow_scale,\n                origin=\"center\",\n            )\n        else:  # MultiPolygon\n            inner_geoms = [\n                shapely_scale(\n                    poly,\n                    xfact=hollow_scale,\n                    yfact=hollow_scale,\n                    origin=\"center\",\n                )\n                for poly in geometry.geoms\n            ]\n            inner_geom = (\n                MultiPolygon(inner_geoms)\n                if len(inner_geoms) &gt; 1\n                else inner_geoms[0]\n            )\n\n        # Extrude inner geometry and apply Z-shift\n        inner_meshes = []\n        if inner_geom.geom_type == \"Polygon\":\n            inner_mesh = trimesh.creation.extrude_polygon(\n                inner_geom, thickness\n            )\n            inner_meshes.append(inner_mesh)\n        elif inner_geom.geom_type == \"MultiPolygon\":\n            for poly in inner_geom.geoms:\n                inner_mesh = trimesh.creation.extrude_polygon(poly, thickness)\n                inner_meshes.append(inner_mesh)\n\n        if not inner_meshes:\n            return outer_mesh  # Fallback if inner geometry is empty\n\n        inner_mesh = (\n            inner_meshes[0]\n            if len(inner_meshes) == 1\n            else trimesh.util.concatenate(inner_meshes)\n        )\n        inner_mesh.apply_translation([0, 0, hollow_shift_z])\n\n        # Boolean subtraction (hollowing)\n        try:\n            hollow_mesh = outer_mesh.difference(inner_mesh, engine=\"blender\")\n            return hollow_mesh\n        except Exception:\n            # Fallback to solid mesh if boolean operation fails\n            return outer_mesh\n\n    def _tile_polygons_2D_extrusion(\n        self,\n        extrusion,\n        tile_dict,\n        child_cell,\n        target_layer,\n        skip_if_exists,\n        hollow,\n        hollow_scale,\n        hollow_shift_z,\n    ):\n\n        output_folder = f\"{self.gds_name}/{child_cell.name}{target_layer}\"\n        os.makedirs(output_folder, exist_ok=True)\n\n        for (ix, iy), geoms in tile_dict.items():\n            # Generate the tile filename and path\n            tile_filename = f\"tile_{ix}_{iy}.stl\"\n            tile_filepath = os.path.join(output_folder, tile_filename)\n\n            # Check if the STL file already exists\n            if os.path.exists(tile_filepath) and skip_if_exists:\n                print(\n                    f\"Tile {(ix, iy)} already exists at {tile_filepath}, skipping.\"\n                )\n                continue\n\n            # List to collect meshes from each geometry\n            tile_meshes = []\n\n            # Extrude each geometry in that tile\n            for geom in geoms:\n                mesh_3d = self._extrude_shapely_geometry(\n                    geometry=geom,\n                    thickness=extrusion,\n                    hollow=hollow,\n                    hollow_scale=hollow_scale,\n                    hollow_shift_z=hollow_shift_z,\n                )\n                if mesh_3d is not None:\n                    tile_meshes.append(mesh_3d)\n\n            # Combine (concatenate) all extruded meshes in this tile\n            if len(tile_meshes) == 0:\n                # No valid geometry in this tile, skip\n                continue\n            elif len(tile_meshes) == 1:\n                tile_mesh_combined = tile_meshes[0]\n            else:\n                tile_mesh_combined = trimesh.util.concatenate(tile_meshes)\n\n            # Export to STL\n            tile_mesh_combined.export(tile_filepath)\n            print(f\"Exported tile {(ix, iy)} to {tile_filepath}\")\n\n    def _meander_order(self, tile_keys):\n        \"\"\"\n        Given an iterable of (ix, iy) tile indices,\n        return a list of (ix, iy) in a zigzag (meander) order.\n\n        - Sort by ascending y for the rows.\n        - For each consecutive row, alternate the x-direction:\n            * row0: left-to-right\n            * row1: right-to-left\n            * row2: left-to-right\n            * ...\n        \"\"\"\n        # Group the tile indices by their y\n        from collections import defaultdict\n\n        rows = defaultdict(list)\n        for ix, iy in tile_keys:\n            rows[iy].append(ix)\n\n        # Sort the rows by Y ascending\n        sorted_ys = sorted(rows.keys())\n\n        # Build the final list of (ix, iy)\n        meandered = []\n        for row_i, y in enumerate(sorted_ys):\n            x_list = sorted(rows[y])\n            # If row_i is odd, reverse the list to create the zigzag\n            if row_i % 2 == 1:\n                x_list.reverse()\n\n            for x in x_list:\n                meandered.append((x, y))\n\n        return meandered\n\n    def _tile_center(self, ix, iy, tile_size):\n        \"\"\"\n        Return the center of tile (ix, iy) in the same coordinate system\n        that was used for clipping (i.e., each tile is tile_size wide/high).\n        \"\"\"\n        cx = ix * tile_size\n        cy = iy * tile_size\n        return (cx, cy)\n\n    def _build_nano_leaf_group(\n        self,\n        tile_dict,\n        tile_size,\n        project,\n        preset,\n        leaf_cell,\n        layer_to_print,\n        group_xy,\n        rotation,\n        write_field_scene=None,\n        color=\"#16506B\",\n    ):\n        # 1) Collect tile keys and meander them\n        tile_keys = list(tile_dict.keys())\n        meandered_keys = self._meander_order(tile_keys)\n        if write_field_scene is None:\n            write_field_scene = _write_field_scene()\n        else:  # Sleep-deprived much? Time to go to bed...\n            try:\n                if write_field_scene._type != \"scene\":\n                    raise TypeError(\n                        \"write_field_scene needs to be of node type scene\"\n                    )\n            except:\n                write_field_scene = _write_field_scene()\n                UserWarning(\n                    \"Invalid scene. Default write field going to be applied instead.\"\n                )\n        # 2) Build Scenes in meander order\n        scenes = []\n        meshes = []\n        for i, (ix, iy) in enumerate(meandered_keys):\n            # tile_{ix}_{iy}.stl is our new naming scheme\n            stl_filename = f\"{self.gds_name}/{leaf_cell.name}{layer_to_print}/tile_{ix}_{iy}.stl\"\n\n            # Compute the tile center\n            cx, cy = self._tile_center(ix, iy, tile_size=tile_size)\n\n            # Build the Scene, position = [cx, cy, 0]\n            scene = write_field_scene.deepcopy_node(\n                name=stl_filename\n            ).position_at(position=[cx, cy, 0])\n\n            # Build the Mesh object\n            # auto_center=True =&gt; internally centers the geometry\n            mesh_obj = Mesh(\n                stl_filename, name=stl_filename, translation=[-cx, -cy, 0]\n            )\n\n            # Prepare for the structure\n            # (assuming you have your 'preset' object already loaded)\n            structure = Structure(\n                name=mesh_obj.name, preset=preset, mesh=mesh_obj, color=color\n            )\n\n            # Attach structure to the scene\n            scene.append_node(structure)\n\n            # Keep references\n            scenes.append(scene)\n            meshes.append(mesh_obj)\n\n        project.load_resources(meshes)\n        leaf_group = Group(\n            name=leaf_cell.name,\n            position=[*group_xy, 0],\n            rotation=[0, 0, rotation],\n        )\n        leaf_group.add_child(*scenes)\n        return leaf_group\n\n    def _cell_has_direct_polygons(\n        self, cell: pya.Cell, layer_to_print: int\n    ) -&gt; bool:\n        \"\"\"\n        Check if a cell directly contains any polygon shapes on a specific layer.\n\n        Args:\n            cell: pya.Cell to check\n            layer_to_print: Layer index to examine\n\n        Returns:\n            True if cell directly contains polygons on this layer, False otherwise\n        \"\"\"\n        for shape in cell.shapes(layer_to_print):\n            if shape.is_polygon() or shape.is_box():\n                return True\n        return False\n\n    groups = []\n\n    def _collect_instance_displacements(self, cell):\n        displacements = []\n        dbu = self.layout.dbu  # Database unit to micron conversion factor\n\n        for instance in cell.each_inst():\n            # Extract array parameters (default to 1 if not an array)\n            na = instance.na or 1\n            nb = instance.nb or 1\n            a_vec = (\n                instance.a\n            )  # Column displacement vector (in database units)\n            b_vec = instance.b  # Row displacement vector\n\n            # Base displacement from the instance's transformation\n            base_disp_db = instance.trans.disp  # In database units\n\n            # Iterate over all elements in the array\n            for i in range(na):\n                for j in range(nb):\n                    # Compute total displacement for this array element\n                    delta = a_vec * i + b_vec * j\n                    total_disp_db = base_disp_db + delta\n\n                    # Convert to microns and add to the list\n                    total_disp_micron = total_disp_db.to_dtype(dbu)\n                    displacements.append(\n                        [total_disp_micron.x, total_disp_micron.y]\n                    )\n\n        return displacements\n\n    def gds_printing(\n        self,\n        project: Project,\n        preset: Preset,\n        cell_name: Optional[str] = None,\n        write_field_scene: Optional[Scene] = None,\n        layer: Tuple[int, int] = (1, 0),\n        epsilon: float = 1.0,\n        tile_size: Tuple[float, float] = (200.0, 200.0),\n        extrusion: float = 20.0,\n        skip_if_exists: bool = False,\n        color: str = \"#16506B\",\n        iterate_over_each_polygon: bool = False,\n        hollow: bool = True,\n        hollow_scale: float = 0.9,\n        hollow_shift_z: float = -2.0,\n        layer_to_print=None,\n        _verbose: bool = False,\n    ) -&gt; Group:\n        \"\"\"\n        Process GDS layout to generate tiled scenes for 3D printing.\n\n        This method processes a GDS layout, divides it into tiles, creates 3D extrusions\n        from the polygons, and generates scenes for each tile with appropriate positioning.\n\n        Args:\n            project: Project instance to which generated meshes are loaded to.\n            preset: Preset instance for printing.\n            cell_name: Name of the cell in GDS to process.\n            write_field_scene: Scene template for writing fields.\n            layer: Layer containing polygons that are supposed to be extruded and printed.\n            extrusion: Thickness for 3D extrusion.\n            tile_size: Size of each tile in micrometers.\n            epsilon: Overlap value between tiles in micrometers.\n            skip_if_exists: Skip processing if output files already exist.\n            color: Color for generated structures in viewer.\n            iterate_over_each_polygon: Tile each polygon individually if True\n            hollow: Create hollow structures if True\n            hollow_scale: Scaling factor for hollow structures\n            hollow_shift_z: Z-axis shift for hollow structures\n            _verbose: Verbose output flag (for debugging/developing)\n\n        Returns:\n            Group: Group instance containing all generated tile scenes.\n\n        Raises:\n            ValueError: Invalid input parameters\n            TypeError: Incorrect argument types\n            RuntimeError: Polygon processing failure\n        \"\"\"\n        # Input validation\n        if not isinstance(project, Project):\n            raise TypeError(\"project must be a Project instance\")\n        if not isinstance(preset, Preset):\n            raise TypeError(\"preset must be a Preset instance\")\n        if cell_name is not None and not isinstance(cell_name, str):\n            raise TypeError(\"cell_name must be a string or None\")\n        if write_field_scene is not None and not isinstance(\n            write_field_scene, Scene\n        ):\n            raise TypeError(\n                \"write_field_scene must be a Scene instance or None\"\n            )\n        if layer == (1, 0) and layer_to_print is not None:\n            DeprecationWarning(\n                \"Argument layer_to_print is deprecated and will \"\n                \"be removed in a future release. Use layer instead.\"\n            )\n            layer = layer_to_print\n        elif layer_to_print is not None:\n            DeprecationWarning(\n                \"Argument layer_to_print is deprecated and will be removed \"\n                \"in a future release. Argument layer will be used instead. \"\n            )\n        # Validate layer_to_print structure and content\n        if not isinstance(layer, tuple) or len(layer) != 2:\n            raise TypeError(\"layer must be a tuple of two integers\")\n        if not all(isinstance(x, int) for x in layer):\n            raise TypeError(\"Both elements in layer must be integers\")\n\n        # Validate numerical parameters\n        if not isinstance(extrusion, (int, float)):\n            raise TypeError(\"extrusion must be a numeric value\")\n        if not isinstance(tile_size, tuple) or len(layer) != 2:\n            raise TypeError(\"tile_size must be a tuple of two integers\")\n        if not all(isinstance(x, (int, float)) for x in tile_size):\n            raise TypeError(\n                \"All elements in tile_size must be numbers (int or float)\"\n            )\n        if not all(x &gt; 0 for x in tile_size):\n            raise ValueError(\"All elements in tile_size must be positive\")\n\n        if not isinstance(epsilon, (int, float)):\n            raise TypeError(\"epsilon must be a numeric value\")\n        if epsilon &lt; 0:\n            raise ValueError(\"epsilon must be non-negative\")\n        if not isinstance(hollow_scale, (int, float)):\n            raise TypeError(\n                \"hollow_scale must be a numeric value between 0 and 1.\"\n            )\n        if hollow_scale &lt; 0 or hollow_scale &gt; 1:\n            raise TypeError(\n                \"hollow_scale must be a numeric value between 0 and 1.\"\n            )\n        if not isinstance(hollow_shift_z, (int, float)):\n            raise TypeError(\"hollow_shift_z must be a numeric value.\")\n\n        # Validate boolean parameters\n        if not isinstance(skip_if_exists, bool):\n            raise TypeError(\"skip_if_exists must be a boolean\")\n        if not isinstance(iterate_over_each_polygon, bool):\n            raise TypeError(\"iterate_over_each_polygon must be a boolean\")\n        if not isinstance(hollow, bool):\n            raise TypeError(\"hollow must be a boolean\")\n        if not isinstance(_verbose, bool):\n            raise TypeError(\"_verbose must be a boolean\")\n\n        gds_printing_group = self._gds_printing_new(\n            project,\n            preset,\n            cell_name=cell_name,\n            write_field_scene=write_field_scene,\n            layer=layer,\n            extrusion=extrusion,\n            hollow=hollow,\n            hollow_scale=hollow_scale,\n            hollow_shift_z=hollow_shift_z,\n            tile_size=tile_size,\n            epsilon=epsilon,\n            skip_if_exists=skip_if_exists,\n            color=color,\n            iterate_over_each_polygon=iterate_over_each_polygon,\n            _verbose=_verbose,\n        )\n\n        return gds_printing_group\n\n    @verbose_output()\n    def _gds_printing_new(\n        self,\n        project: Project,\n        preset: Preset,\n        cell_name: Optional[str] = None,\n        write_field_scene: Optional[Scene] = None,\n        layer: Tuple[int, int] = (1, 0),\n        epsilon: float = 1.0,\n        tile_size: Tuple[float, float] = (200.0, 200.0),\n        extrusion: float = 20.0,\n        skip_if_exists: bool = False,\n        color: str = \"#16506B\",\n        iterate_over_each_polygon: bool = True,\n        hollow: bool = True,\n        hollow_scale: float = 0.9,\n        hollow_shift_z: float = -2.0,\n        _verbose: bool = False,\n    ) -&gt; Group:\n        \"\"\"\n        Process GDS layout to generate tiled scenes for 3D printing.\n\n        This method processes a GDS layout, divides it into tiles, creates 3D extrusions\n        from the polygons, and generates scenes for each tile with appropriate positioning.\n\n        Args:\n            project: Project configuration object\n            preset: Preset configuration for structures\n            cell_name: Name of the cell to process (optional)\n            write_field_scene: Scene template for writing fields (optional)\n            layer: Layer specification to process\n            epsilon: Overlap value between tiles\n            tile_size: Size of each tile in micrometers\n            extrusion: Thickness for 3D extrusion\n            skip_if_exists: Skip processing if output files already exist\n            color: Color for generated structures\n            iterate_over_each_polygon: Process each polygon individually if True\n            hollow: Create hollow structures if True\n            hollow_scale: Scaling factor for hollow structures\n            hollow_shift_z: Z-axis shift for hollow structures\n            _verbose: Verbose output flag\n\n        Returns:\n            Group: Group containing all generated tiled scenes\n        \"\"\"\n        # Load the GDS file\n        #        self.layout.read(self.gds_path)\n\n        # Get the specified layer\n        layer_index = self.layout.layer(*layer)\n        gds_name = os.path.splitext(os.path.basename(self.gds_file))[0]\n\n        # Get the top cell\n        top_cell = (\n            self.layout.top_cell()\n            if cell_name is None\n            else self.get_cell_by_name(cell_name=cell_name, layout=self.layout)\n        )\n\n        shapes_iter = top_cell.begin_shapes_rec(layer_index)\n        tiles = []\n        results = []\n        meshes_npx = []\n        scenes_npx = []\n        output_group = Group(\n            name=gds_name\n            + \"_\"\n            + top_cell.name\n            + f\"_layer_{layer[0]}_{layer[1]}\"\n        )\n\n        # Check if passed write field is a valid scene\n        if write_field_scene is None:\n            write_field_scene = _write_field_scene()\n        elif write_field_scene._type != \"scene\":\n            write_field_scene = _write_field_scene()\n            UserWarning(\n                \"Invalid scene. Default write field going to be applied instead.\"\n            )\n\n        # Convert from um to dbu\n        epsilon_dbu = epsilon * 1000\n        tile_size_dbu = (tile_size[0] * 1000, tile_size[1] * 1000)\n\n        # Create a region from all shapes on the layer\n        region_all = pya.Region(shapes_iter)\n        iterable = region_all.each() if iterate_over_each_polygon else [0]\n\n        for poly in iterable:\n            # Get the region to process\n            if iterate_over_each_polygon:\n                region = pya.Region(poly)\n            else:\n                region = region_all\n\n            bbox = region.bbox()\n            x_min, y_min = bbox.left, bbox.bottom\n            x_max, y_max = bbox.right, bbox.top\n\n            # Calculate number of tiles needed\n            tile_width, tile_height = tile_size_dbu\n            num_x = int(np.ceil((x_max - x_min) / (tile_width - epsilon_dbu)))\n            num_y = int(np.ceil((y_max - y_min) / (tile_height - epsilon_dbu)))\n\n            # Generate tiles in meander order\n            for j in range(num_y):\n                # Alternate direction for meander pattern\n                x_indices = (\n                    range(num_x) if j % 2 == 0 else reversed(range(num_x))\n                )\n\n                for i in x_indices:\n                    # Calculate tile boundaries with overlap\n                    x1 = x_min + i * (tile_width - epsilon_dbu)\n                    y1 = y_min + j * (tile_height - epsilon_dbu)\n                    x2 = x1 + tile_width\n                    y2 = y1 + tile_height\n\n                    # Create tile box\n                    tile_box = pya.Box(x1, y1, x2, y2)\n                    tiles.append((i, j, tile_box))\n\n            # Process each tile\n            for i, j, tile_box in tiles:\n                # Create region for the tile\n                tile_region = pya.Region(tile_box)\n\n                # Extract polygons that intersect with the tile\n                extracted = region &amp; tile_region\n\n                # Merge overlapping/adjacent polygons\n                extracted.merge()\n\n                # Skip empty tiles\n                if extracted.is_empty():\n                    continue\n\n                # Convert to Shapely polygons\n                shapely_polygons = []\n                for poly in extracted.each():\n                    # Get polygon points\n                    points = []\n                    for point in poly.each_point_hull():\n                        points.append((point.x / 1000, point.y / 1000))\n\n                    # Create Shapely polygon (close the ring if needed)\n                    if points[0] != points[-1]:\n                        points.append(points[0])\n\n                    shapely_polygons.append(Polygon(points))\n\n                # Create MultiPolygon from all polygons in the tile\n                multipolygon = MultiPolygon(shapely_polygons)\n\n                # Calculate tile center\n                center_x = extracted.bbox().center().x / 1000\n                center_y = extracted.bbox().center().y / 1000\n\n                # Create 3D extrusions/meshes\n                tile_meshes = []\n                mesh_3d = self._extrude_shapely_geometry(\n                    geometry=multipolygon,\n                    thickness=extrusion,\n                    hollow=hollow,\n                    hollow_scale=hollow_scale,\n                    hollow_shift_z=hollow_shift_z,\n                )\n                if mesh_3d is not None:\n                    tile_meshes.append(mesh_3d)\n\n                # Combine (concatenate) all extruded meshes in this tile\n                if len(tile_meshes) == 0:\n                    # No valid geometry in this tile, skip\n                    continue\n                elif len(tile_meshes) == 1:\n                    tile_mesh_combined = tile_meshes[0]\n                else:\n                    tile_mesh_combined = trimesh.util.concatenate(tile_meshes)\n\n                # Export to STL\n                output_folder = f\"{gds_name}/{top_cell.name}{layer}\"\n                os.makedirs(output_folder, exist_ok=True)\n\n                tile_filename = (\n                    f\"tile_{i}_{j}_center_{int(center_x)}_{int(center_y)}.stl\"\n                )\n                tile_filepath = os.path.join(output_folder, tile_filename)\n\n                # Check if the STL file already exists and export if not\n                if not os.path.exists(tile_filepath) and not skip_if_exists:\n                    tile_mesh_combined.export(tile_filepath)\n                else:\n                    print(\n                        f\"Tile {(i, j)} already exists at {tile_filepath}, skipping.\"\n                    )\n\n                # npx-API goes below here\n                mesh_npx = Mesh(\n                    file_path=tile_filepath,\n                    name=tile_filename.split(\".\")[0],\n                    auto_center=True,\n                )\n                meshes_npx.append(mesh_npx)\n                structure_npx = Structure(\n                    preset,\n                    mesh_npx,\n                    name=tile_filename.split(\".\")[0],\n                    color=color,\n                )\n                scene_npx = write_field_scene.deepcopy_node(name=mesh_npx.name)\n                scene_npx.position = [center_x, center_y, 0]\n                scene_npx.append_node(structure_npx)\n                scenes_npx.append(scene_npx)\n\n                # Add to results (not part of any npx-related things)\n                results.append(((i, j), (center_x, center_y), multipolygon))\n\n        output_group.add_child(*scenes_npx)\n\n        # Print information about each tile if verbose\n        for (i, j), center, multipolygon in results:\n            print(f\"Tile ({i}, {j}) at center {center}:\")\n            print(f\"  Contains {len(multipolygon.geoms)} polygons\")\n            print(f\"  Total area: {multipolygon.area}\")\n            print()\n        project.load_resources(meshes_npx)\n        return output_group\n\n    @verbose_output()\n    def _gds_printing(\n        self,\n        project: Project,\n        preset: Preset,\n        cell_name: Optional[str],\n        write_field_scene: Optional[Scene],\n        layer_to_print: Tuple[int, int],\n        extrusion: float,\n        hollow: bool,\n        hollow_scale: float,\n        hollow_shift_z: float,\n        tile_size: float,\n        epsilon: float,\n        skip_if_exists: bool,\n        color: str,\n        _verbose: bool,\n    ) -&gt; Group:\n        cell = (\n            self.layout.top_cell()\n            if cell_name is None\n            else self.get_cell_by_name(cell_name)\n        )\n        print(f\"Cell: {cell.name}\")\n        cell_group = Group(f\"Cell: {cell.name} Layer:{layer_to_print}\")\n        for instance in cell.each_inst():\n\n            # Get the child cell\n            child_cell = self.layout.cell(instance.cell_index)\n\n            # Get the transformation of the instance\n            trans = instance.trans\n\n            # Extract the displacement vector (relative translation)\n            displacement = trans.disp\n            rotation = (\n                trans.rot * 90\n            )  # outputs are ints (0,1,2,3) for multiples of 90 deg\n            # Convert the displacement to microns (if needed)\n            displacement_in_microns = displacement.to_dtype(self.layout.dbu)\n\n            print(f\"Child cell: {child_cell.name}\")\n            # print(f\"Relative displacement (in database units): {displacement}\")\n            print(\n                f\"Relative displacement (in microns): {displacement_in_microns.x, displacement_in_microns.y}\"\n            )\n            print(\"---\")\n\n            if self._cell_has_direct_polygons(child_cell, layer_to_print):\n                polygons = self._gather_polygons_in_child_cell(\n                    child_cell, layer_to_print\n                )\n                tile_dict = self._tile_polygons(\n                    polygons, tile_size=tile_size, epsilon=epsilon\n                )\n                self._tile_polygons_2D_extrusion(\n                    extrusion=extrusion,\n                    tile_dict=tile_dict,\n                    child_cell=child_cell,\n                    target_layer=layer_to_print,\n                    skip_if_exists=skip_if_exists,\n                    hollow=hollow,\n                    hollow_scale=hollow_scale,\n                    hollow_shift_z=hollow_shift_z,\n                )\n                child_cell_group = self._build_nano_leaf_group(\n                    tile_dict,\n                    tile_size,\n                    project,\n                    preset,\n                    child_cell,\n                    group_xy=[\n                        displacement_in_microns.x,\n                        displacement_in_microns.y,\n                    ],\n                    rotation=rotation,\n                    write_field_scene=write_field_scene,\n                    layer_to_print=layer_to_print,\n                    color=color,\n                )\n\n            else:\n                child_cell_group = Group(\n                    name=child_cell.name,\n                    position=[\n                        displacement_in_microns.x,\n                        displacement_in_microns.y,\n                        0,\n                    ],\n                    rotation=[0, 0, rotation],\n                )\n                print(\"No direct polygons found in top cell\")\n\n            #  Do NOT assume you could shove this in the if-statement above\n            if not child_cell.is_leaf():\n                child_cell_group.add_child(\n                    self.gds_printing(\n                        project,\n                        preset,\n                        cell_name=child_cell.name,\n                        write_field_scene=write_field_scene,\n                        layer_to_print=layer_to_print,\n                        extrusion=extrusion,\n                        hollow=hollow,\n                        hollow_scale=hollow_scale,\n                        hollow_shift_z=hollow_shift_z,\n                        tile_size=tile_size,\n                        epsilon=epsilon,\n                        color=color,\n                        _verbose=_verbose,\n                    )\n                )\n            else:\n                cell_group.add_child(child_cell_group)\n\n                print(\"LEAF!\")\n\n        return cell_group\n\n    def _decompose(self, geometry):\n        \"\"\"Decompose a geometry into a list of Polygon(s).\"\"\"\n        if isinstance(geometry, MultiPolygon):\n            return list(geometry.geoms)\n        elif isinstance(geometry, Polygon):\n            return [geometry]\n        else:\n            raise ValueError(\"Unsupported geometry type\")\n\n    def _get_polygon_coords(self, polygon):\n        \"\"\"Extract all coordinates from a polygon (exterior and interiors).\"\"\"\n        exterior = list(polygon.exterior.coords)\n        interiors = []\n        for interior in polygon.interiors:\n            interiors.extend(interior.coords)\n        return np.array(exterior + interiors)\n\n    def _normalize_polygon(self, polygon):\n        \"\"\"Normalize a polygon's position, rotation, and orientation.\"\"\"\n        # Translate to centroid origin\n        centroid = polygon.centroid\n        translated = translate(polygon, -centroid.x, -centroid.y)\n\n        # Get coordinates for PCA\n        coords = self._get_polygon_coords(translated)\n        if len(coords) &lt; 2:\n            return translated  # Not enough points for PCA\n\n        # Compute PCA to find the principal axis\n        centered = coords - np.mean(coords, axis=0)\n        cov = np.cov(centered.T)\n        eigenvalues, eigenvectors = np.linalg.eig(cov)\n        principal = eigenvectors[:, np.argmax(eigenvalues)]\n        angle = np.arctan2(principal[1], principal[0])\n\n        # Rotate to align principal axis with x-axis\n        rotated = rotate(translated, -np.degrees(angle), origin=(0, 0))\n\n        # Heuristic to ensure consistent orientation (flip if necessary)\n        coords_rotated = list(rotated.exterior.coords)\n        if len(coords_rotated) &gt;= 2:\n            dx = coords_rotated[1][0] - coords_rotated[0][0]\n            dy = coords_rotated[1][1] - coords_rotated[0][1]\n            if dx &lt; 0 or (dx == 0 and dy &lt; 0):\n                # Reflect across x-axis\n                return rotate(rotated, 180, origin=(0, 0))\n        return rotated\n\n    def _are_geometries_equivalent(self, geom1, geom2, tolerance=1e-6):\n        \"\"\"Check if two geometries are equivalent in shape and size.\"\"\"\n        # Decompose into individual polygons\n        polys1 = self._decompose(geom1)\n        polys2 = self._decompose(geom2)\n        if len(polys1) != len(polys2):\n            return False\n\n        # Normalize and sort polygons for comparison\n        def sort_key(p):\n            return (-p.area, -p.length, list(p.exterior.coords))\n\n        normalized1 = sorted(\n            [self._normalize_polygon(p) for p in polys1], key=sort_key\n        )\n        normalized2 = sorted(\n            [self._normalize_polygon(p) for p in polys2], key=sort_key\n        )\n\n        # Compare each pair of polygons\n        for p1, p2 in zip(normalized1, normalized2):\n            if not p1.equals_exact(p2, tolerance):\n                return False\n        return True\n\n    def _merge_touching_polygons(self, polygons):\n        \"\"\"\n        Merge polygons that touch or intersect, including newly formed ones.\n        Returns a list of merged geometries (Polygon/MultiPolygon).\n        \"\"\"\n        processed = [False] * len(polygons)\n        result = []\n\n        for i in range(len(polygons)):\n            if not processed[i]:\n                # Start a new connected component\n                component = [polygons[i]]\n                processed[i] = True\n                queue = [i]\n\n                # Find all connected polygons using BFS\n                while queue:\n                    current_idx = queue.pop(0)\n                    current_poly = polygons[current_idx]\n\n                    # Check against all other polygons\n                    for j in range(len(polygons)):\n                        if not processed[j]:\n                            other_poly = polygons[j]\n                            if current_poly.intersects(other_poly):\n                                component.append(other_poly)\n                                processed[j] = True\n                                queue.append(j)\n\n                # Merge the component into a single geometry\n                merged = unary_union(component)\n                result.append(merged)\n\n        return result\n\n    def _ensure_folder_exist_else_create(self, path):\n        try:\n            if os.path.exists(path):\n                pass\n            else:\n                os.makedirs(path)\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n\n    def marker_aligned_printing(\n        self,\n        project: Project,\n        presets: List[Preset],\n        meshes: List[Mesh],\n        marker_height: float = 0.33,\n        marker_layer: Tuple[int, int] = (10, 10),\n        mesh_spots_layers: List[Tuple[int, int]] = [(100, 100)],\n        cell_origin_offset: Tuple[float, float] = (0.0, 0.0),\n        cell_name: Optional[str] = None,\n        image_resource: Optional[Image] = None,\n        interface_aligner_node: Optional[InterfaceAligner] = None,\n        marker_aligner_node: Optional[MarkerAligner] = None,\n        colors: Optional[List[str]] = None,\n        marker_aligner_kwargs: Optional[Dict] = None,\n        structure_kwargs: Optional[Dict] = None,\n        _verbose: bool = False,\n    ) -&gt; Group:\n        \"\"\"Create a hierarchical printing group with marker-based alignment.\n\n        Args:\n            project: Parent Project for resource management\n            presets: List of Preset configurations for printing\n            meshes: List of Mesh objects to print\n            marker_height: Z-height for marker structures\n            marker_layer: Layer/datatype for alignment markers\n            mesh_spots_layers: List of layers containing print locations\n            cell_origin_offset: Coordinate offset for cell origin\n            cell_name: Cell to start traversing from (uses top cell if None)\n            image_resource: Pre-configured Image resource for markers\n            interface_aligner_node: InterfaceAligner configuration template\n            marker_aligner_node: MarkerAligner configuration template\n            colors: Color codes for visualization\n            marker_aligner_kwargs: Additional MarkerAligner parameters\n            structure_kwargs: Additional Structure parameters\n            _verbose: Enable debug output\n\n        Returns:\n            Group: Hierarchical printing structure with alignment\n\n        Raises:\n            ValueError: Invalid input dimensions, values, or formats\n            TypeError: Incorrect argument types\n            RuntimeError: Marker processing failure\n        \"\"\"\n        DeprecationWarning(\n            \"The method .marker_aligned_printing() is deprecated\"\n            \" and will be removed in a future release. Use the \"\n            \" method .get_scenes() instead.\"\n        )\n        # Initialize mutable defaults safely\n        marker_aligner_kwargs = marker_aligner_kwargs or {}\n        structure_kwargs = structure_kwargs or {}\n        colors = colors or [\"#16506B\"] * len(meshes)\n\n        # Comprehensive type validation\n        if not isinstance(project, Project):\n            raise TypeError(\"project must be a Project instance\")\n        if not isinstance(presets, list):\n            raise TypeError(\"presets must be a list\")\n        if not isinstance(meshes, list):\n            raise TypeError(\"meshes must be a list\")\n        if not isinstance(mesh_spots_layers, list):\n            raise TypeError(\"mesh_spots_layers must be a list\")\n\n        # Validate numerical parameters\n        if not isinstance(marker_height, (int, float)):\n            raise TypeError(\"marker_height must be numeric\")\n        if (\n            not isinstance(cell_origin_offset, tuple)\n            or len(cell_origin_offset) != 2\n        ):\n            raise TypeError(\"cell_origin_offset must be a 2-element tuple\")\n        if not all(isinstance(x, (int, float)) for x in cell_origin_offset):\n            raise TypeError(\"cell_origin_offset elements must be numeric\")\n\n        # Validate layer specifications\n        layer_valid = (\n            lambda l: isinstance(l, tuple)\n            and len(l) == 2\n            and all(isinstance(n, int) for n in l)\n        )\n        if not layer_valid(marker_layer):\n            raise TypeError(\"marker_layer must be a (int, int) tuple\")\n        if not all(layer_valid(l) for l in mesh_spots_layers):\n            raise TypeError(\n                \"All mesh_spots_layers elements must be (int, int) tuples\"\n            )\n\n        # Validate list contents\n        for i, preset in enumerate(presets):\n            if not isinstance(preset, Preset):\n                raise TypeError(f\"presets[{i}] must be a Preset instance\")\n        for i, mesh in enumerate(meshes):\n            if not isinstance(mesh, Mesh):\n                raise TypeError(f\"meshes[{i}] must be a Mesh instance\")\n\n        # Validate optional parameters\n        if cell_name is not None and not isinstance(cell_name, str):\n            raise TypeError(\"cell_name must be a string or None\")\n        if image_resource is not None and not isinstance(\n            image_resource, Image\n        ):\n            raise TypeError(\"image_resource must be an Image instance or None\")\n        if interface_aligner_node is not None and not isinstance(\n            interface_aligner_node, InterfaceAligner\n        ):\n            raise TypeError(\n                \"interface_aligner_node must be an InterfaceAligner instance or None\"\n            )\n        if marker_aligner_node is not None and not isinstance(\n            marker_aligner_node, MarkerAligner\n        ):\n            raise TypeError(\n                \"marker_aligner_node must be a MarkerAligner instance or None\"\n            )\n\n        # Validate dictionary parameters\n        if not isinstance(marker_aligner_kwargs, dict):\n            raise TypeError(\"marker_aligner_kwargs must be a dictionary\")\n        if not isinstance(structure_kwargs, dict):\n            raise TypeError(\"structure_kwargs must be a dictionary\")\n        if not isinstance(_verbose, bool):\n            raise TypeError(\"_verbose must be a boolean\")\n\n        # Validate dimensional consistency\n        if (\n            len(presets) != len(meshes)\n            or len(presets) != len(mesh_spots_layers)\n            or len(presets) != len(colors)\n        ):\n            raise ValueError(\"All input lists must have equal length\")\n        if not presets:\n            raise ValueError(\"At least one preset must be provided\")\n\n        marker_aligned_printing_group_raw = self._marker_aligned_printing(\n            project,\n            presets,\n            meshes,\n            cell_name=cell_name,\n            cell_origin_offset=cell_origin_offset,\n            image_resource=image_resource,\n            interface_aligner_node=interface_aligner_node,\n            marker_aligner_node=marker_aligner_node,\n            marker_height=marker_height,\n            marker_layer=marker_layer,\n            mesh_spots_layers=mesh_spots_layers,\n            colors=colors,\n            marker_aligner_kwargs=marker_aligner_kwargs,\n            structure_kwargs=structure_kwargs,\n            _verbose=_verbose,\n        )\n\n        # Clean up nodes that do not contain any structures\n        marker_aligned_printing_group = (\n            marker_aligned_printing_group_raw.deepcopy_node(\n                copy_children=False\n            )\n        )\n        for node in marker_aligned_printing_group_raw.children_nodes:\n            for node_descendant in node.all_descendants:\n                if node_descendant._type == \"structure\":\n                    marker_aligned_printing_group.add_child(node)\n                    break\n        return marker_aligned_printing_group.translate(\n            [-cell_origin_offset[0], -cell_origin_offset[1], 0]\n        )\n\n    @verbose_output()\n    def get_scenes(\n        self,\n        scene_layer: Tuple[int, int],\n        project: Project,\n        presets: List[Preset],\n        meshes: Optional[List[Mesh]] = None,\n        marker_layer: Optional[Tuple[int, int]] = None,\n        marker_region_layer: Optional[Tuple[int, int]] = None,\n        marker_height: float = 0.33,\n        image_resource: Optional[str] = None,\n        marker_aligner_node: Optional[MarkerAligner] = None,\n        interface_aligner_node: Optional[InterfaceAligner] = None,\n        interface_aligner_layer: Optional[Tuple[int, int]] = None,\n        mesh_spots_layers: Optional[List[Tuple[int, int]]] = None,\n        cell_name: Optional[str] = None,\n        colors: Optional[List[str]] = None,\n        structure_kwargs: Optional[Dict[str, Any]] = None,\n        _verbose: bool = False,\n    ) -&gt; Group:\n        \"\"\"\n        Process scenes from GDS layout and generate structured print scenes.\n\n        This method takes a scene layer as designation for the print scene and checks\n        for markers lying inside the scene as provided by marker_layer.\n        In case the marker pattern consists of disjoint polygons,\n        it is necessary to provide a marker_region_layer that defines the\n        image frame for every single marker to ensure correct image generation.\n        Markers may have different orientations but always have to have the same\n        size/shape per layer.\n\n        Args:\n            scene_layer: Layer specification for scene regions\n            project: Project instance in which read-out markers from GDS are loaded to.\n            presets: Bijective list of Preset instances for each mesh (referred to by index)\n            meshes: List of mesh objects (optional)\n            marker_layer: Layer specification for markers\n            marker_region_layer: Layer specification for marker regions\n            marker_height: Height value for markers\n            image_resource: Path to an alternative image resource (optional)\n            marker_aligner_node: Custom marker alignment node (optional)\n            interface_aligner_node: Custom interface alignment node (optional)\n            interface_aligner_layer: Layer specification for interface alignment (optional)\n            mesh_spots_layers: List of layer specifications for mesh spots (optional)\n            cell_name: Name of the GDS cell to process (optional)\n            colors: Bijective list of colors for structures (optional)\n            structure_kwargs: Additional dictionary for keyword arguments for all structures\n            _verbose: Verbose output flag\n\n        Returns:\n            Group: Group node containing all generated scenes\n        \"\"\"\n        # Initialize default values\n        structure_kwargs = structure_kwargs or {}\n\n        # Check if all interface aligner related parameters are None\n        _no_interfacealigner_if_all_None = all(\n            v is None\n            for v in [\n                meshes,\n                marker_layer,\n                interface_aligner_node,\n                interface_aligner_layer,\n            ]\n        )\n\n        # Validation checks\n        if marker_layer is None and marker_region_layer is not None:\n            raise ValueError(\n                \"marker_layer must not be None if a marker_region_layer was specified.\\n\"\n                \"Either specify a marker_layer or set marker_region_layer=None as well.\"\n            )\n\n        if marker_layer is None:\n            marker_layer = (1_000_000, 1_000_000)\n\n        # Input layers\n        _marker_layer = self.layout.layer(*marker_layer)  # Target shapes\n        _marker_region_layer = (\n            self.layout.layer(*marker_region_layer)\n            if marker_region_layer is not None\n            else self.layout.layer(*marker_layer)\n        )  # Target regions\n        _scene_layer = self.layout.layer(*scene_layer)  # Region definition\n\n        # Create regions\n        top_cell = (\n            self.layout.top_cell()\n            if cell_name is None\n            else self.get_cell_by_name(cell_name=cell_name, layout=self.layout)\n        )\n        scene_region = pya.Region(top_cell.begin_shapes_rec(_scene_layer))\n        marker_region = pya.Region(top_cell.begin_shapes_rec(_marker_layer))\n        marker_region_region = pya.Region(\n            top_cell.begin_shapes_rec(_marker_region_layer)\n        )\n\n        if interface_aligner_layer is not None:\n            _interface_aligner_layer = self.layout.layer(\n                *interface_aligner_layer\n            )\n            ia_region = pya.Region(\n                top_cell.begin_shapes_rec(_interface_aligner_layer)\n            )\n\n        if mesh_spots_layers is not None:\n            _mesh_spots_layers = [\n                self.layout.layer(*mesh_spots_layer)\n                for mesh_spots_layer in mesh_spots_layers\n            ]\n            mesh_spots_regions = [\n                pya.Region(top_cell.begin_shapes_rec(_mesh_spots_layer))\n                for _mesh_spots_layer in _mesh_spots_layers\n            ]\n\n        # Compute the intersection to reduce sample size\n        marker_region_region_in_scene_region = (\n            marker_region_region &amp; scene_region\n        )\n        marker_region_in_scene_region = marker_region &amp; scene_region\n\n        # Iterate through all polygon patches in scene layer\n        all_scenes = []\n        file_path = None  # resets file_path each run to ensure the directory gets recreated and not skipped\n\n        for idx, scene in enumerate(scene_region.each()):\n            single_scene_reg = pya.Region(scene)\n            # Determine absolute centroid position of scene(s)\n            scene_pos = (\n                single_scene_reg.bbox().center().x / 1000,\n                single_scene_reg.bbox().center().y / 1000,\n                0,\n            )\n\n            # Prepare Scene with interface alignment\n            scene_npx = Scene(\n                position=scene_pos,\n                name=f\"scene_{scene_layer[0]}_{scene_layer[1]}_{idx}\",\n            )\n            interface_aligner_npx = (\n                InterfaceAligner()\n                if interface_aligner_node is None\n                else interface_aligner_node.deepcopy_node(copy_children=False)\n            )\n\n            # Return only scenes if all listed are None\n            if not _no_interfacealigner_if_all_None:\n                interface_aligner_npx.name = (\n                    f\"ia_in_scene_{scene_layer[0]}_{scene_layer[1]}_{idx}\"\n                )\n                scene_npx.append_node(interface_aligner_npx)\n\n            # Pass alignment anchors and scan area sizes from polygons in interface alignment layer\n            # if any was specified\n            if interface_aligner_layer is not None:\n                ia_regions_in_single_scene = ia_region &amp; single_scene_reg\n                ia_anchor_pos_list = [\n                    [\n                        ia_region_poly.bbox().center().x / 1000 - scene_pos[0],\n                        ia_region_poly.bbox().center().y / 1000 - scene_pos[1],\n                    ]\n                    for ia_region_poly in ia_regions_in_single_scene.each()\n                ]\n                ia_scan_area_sizes = [\n                    [\n                        ia_region_poly.bbox().width() / 1000,\n                        ia_region_poly.bbox().height() / 1000,\n                    ]\n                    for ia_region_poly in ia_regions_in_single_scene.each()\n                ]\n                interface_aligner_npx.set_interface_anchors_at(\n                    positions=ia_anchor_pos_list,\n                    scan_area_sizes=ia_scan_area_sizes,\n                )\n                interface_aligner_npx.name = f\"ia_{interface_aligner_layer[0]}_{interface_aligner_layer[1]}_in_scene_{scene_layer[0]}_{scene_layer[1]}_{idx}\"\n\n            # Process all positions defined by mesh spots per layer if any were given\n            all_structures = []\n            if mesh_spots_layers is not None and meshes is not None:\n                colors = (\n                    len(mesh_spots_layers) * [\"yellow\"]\n                    if colors is None\n                    else colors\n                )\n                for mesh_spots_region, mesh, preset, color, name in zip(\n                    mesh_spots_regions,\n                    meshes,\n                    presets,\n                    colors,\n                    mesh_spots_layers,\n                ):\n                    mesh_spots_in_single_scene_reg = (\n                        mesh_spots_region &amp; single_scene_reg\n                    )\n                    ms_pos_single_layer_positions = [\n                        [\n                            ms_region_poly.bbox().center().x / 1000\n                            - scene_pos[0],\n                            ms_region_poly.bbox().center().y / 1000\n                            - scene_pos[1],\n                            0 - scene_pos[2],\n                        ]\n                        for ms_region_poly in mesh_spots_in_single_scene_reg\n                    ]\n\n                    # Assign meshes to structures and append them to current scene\n                    structures = [\n                        Structure(\n                            name=mesh.name + \"_in_\" + name,\n                            mesh=mesh,\n                            preset=preset,\n                            color=color,\n                            position=position,\n                            **structure_kwargs,\n                        )\n                        for position in ms_pos_single_layer_positions\n                    ]\n                    all_structures.extend(structures)\n            elif meshes is not None:\n                colors = len(meshes) * [\"red\"] if colors is None else colors\n                structures = [\n                    Structure(\n                        mesh=mesh,\n                        preset=preset,\n                        color=color,\n                        name=mesh.name,\n                        **structure_kwargs,\n                    )\n                    for mesh, preset, color in zip(meshes, presets, colors)\n                ]\n                all_structures.extend(structures)\n\n            # Get marker_region parts within this specific single scene\n            marker_regions_in_single_scene = (\n                marker_region_region_in_scene_region &amp; single_scene_reg\n            )\n\n            if marker_region_layer is None:\n                marker_regions_in_single_scene.merge()\n\n            # Create list containing relative coordinates of markers in respective scene\n            marker_pos_list = [\n                [\n                    marker_region_poly.bbox().center().x / 1000 - scene_pos[0],\n                    marker_region_poly.bbox().center().y / 1000 - scene_pos[1],\n                    marker_height,\n                ]\n                for marker_region_poly in marker_regions_in_single_scene.each()\n            ]\n\n            # Additional processing per patch\n            if not marker_regions_in_single_scene.is_empty():\n                # Collect shapes and convert to Shapely polygons\n                polygons_to_unify = []\n                shapely_polys = []\n\n                for marker_region in marker_regions_in_single_scene.each():\n                    single_marker_reg = pya.Region(marker_region)\n                    single_marker_reg_iter = pya.RecursiveShapeIterator(\n                        self.layout, top_cell, _marker_layer, single_marker_reg\n                    )\n                    polygons_to_unify = []\n                    while not single_marker_reg_iter.at_end():\n                        marker_shape = single_marker_reg_iter.shape()\n                        marker_trans = single_marker_reg_iter.trans()\n\n                        if (\n                            marker_shape.is_polygon()\n                            or marker_shape.is_box()\n                            or marker_shape.is_path()\n                        ):\n                            klayout_poly = marker_shape.polygon.transformed(\n                                marker_trans\n                            )\n\n                            # Extract hull points\n                            hull_points = list(klayout_poly.each_point_hull())\n                            exterior = [(p.x, p.y) for p in hull_points]\n\n                            # Extract holes\n                            interiors = []\n                            for h in range(klayout_poly.holes()):\n                                hole_points = list(\n                                    klayout_poly.each_point_hole(h)\n                                )\n                                interiors.append(\n                                    [(p.x, p.y) for p in hole_points]\n                                )\n\n                            # Create Shapely polygon\n                            poly = Polygon(exterior, interiors)\n                            polygons_to_unify.append(poly)\n\n                        single_marker_reg_iter.next()\n\n                    shapely_polys.append(MultiPolygon(polygons_to_unify))\n\n                img_dir = f\"./images_{self.gds_name}_scene_{scene_layer[0]}_{scene_layer[1]}\"\n                png_name = f\"marker_{marker_layer[0]}_{marker_layer[1]}.png\"\n                if file_path != os.path.join(img_dir, png_name):\n                    file_path = os.path.join(img_dir, png_name)\n                    os.makedirs(img_dir, exist_ok=True)\n                    _, marker_orientations = (\n                        self._group_equivalent_polygons_and_output_image(\n                            shapely_polys, file_path=file_path\n                        )\n                    )\n                    assert len(marker_orientations) == len(marker_pos_list), (\n                        \"marker position count does not coincide with marker \"\n                        \"orientation count. Marker layer polygons are probably \"\n                        \"not grouped properly.\\n\"\n                        f\"len of marker_orientations : {len(marker_orientations)}\\n\"\n                        f\"len of marker_pos_list : {len(marker_pos_list)}\"\n                    )\n\n                    image_resource = (\n                        Image(file_path, png_name)\n                        if image_resource is None\n                        else image_resource\n                    )\n                    project.load_resources(image_resource)\n\n                    marker_aligner_npx = (\n                        MarkerAligner(\n                            image_resource,\n                            marker_size=[\n                                single_marker_reg.bbox().width() / 1000,\n                                single_marker_reg.bbox().height() / 1000,\n                            ],\n                            max_outliers=len(marker_pos_list) - 3,\n                        )\n                        if marker_aligner_node is None\n                        else marker_aligner_node.deepcopy_node()\n                    )\n                    marker_aligner_npx.set_markers_at(\n                        marker_pos_list, marker_orientations\n                    )\n\n                copied_marker_aligner_npx = marker_aligner_npx.deepcopy_node(\n                    name=f\"marker_{marker_layer[0]}_{marker_layer[1]}_in_scene_{scene_layer[0]}_{scene_layer[1]}_{idx}\"\n                ).add_child(*all_structures)\n                scene_npx.append_node(copied_marker_aligner_npx)\n            all_scenes.append(scene_npx)\n\n        output_group = Group(f\"scene_layer_{scene_layer[0]}_{scene_layer[1]}\")\n        output_group.add_child(*all_scenes)\n        return output_group\n\n    @verbose_output()\n    def _marker_aligned_printing(\n        self,\n        project: Project,\n        presets: List[Preset],\n        meshes: List[Mesh],\n        marker_height: float,\n        marker_layer: Tuple[int, int],\n        mesh_spots_layers: List[Tuple[int, int]],\n        cell_origin_offset: Tuple[float, float],\n        cell_name: Optional[str],\n        image_resource: Optional[Image],\n        interface_aligner_node: Optional[InterfaceAligner],\n        marker_aligner_node: Optional[MarkerAligner],\n        colors: List[str],\n        marker_aligner_kwargs: Dict,\n        structure_kwargs: Dict,\n        _verbose: bool,\n    ) -&gt; Group:\n        \"\"\"Internal implementation of marker-aligned printing.\"\"\"\n        cell = (\n            self.layout.top_cell()\n            if cell_name is None\n            else self.get_cell_by_name(cell_name)\n        )\n        print(f\"Cell: {cell.name}\")\n        cell_group = Group(f\"Cell: {cell.name} markers:{marker_layer}\")\n        for instance in cell.each_inst():\n\n            # Get the child cell\n            child_cell = self.layout.cell(instance.cell_index)\n\n            # Get the transformation of the instance\n            trans = instance.trans\n\n            # Extract the displacement vector (relative translation)\n            displacement = trans.disp\n            rotation = (\n                trans.rot * 90\n            )  # outputs are ints (0,1,2,3) for multiples of 90 deg\n            # Convert the displacement to microns (if needed)\n            displacement_in_microns = displacement.to_dtype(self.layout.dbu)\n\n            print(f\"Child cell: {child_cell.name}\")\n            # print(f\"Relative displacement (in database units): {displacement}\")\n            print(\n                f\"Relative displacement (in microns): {displacement_in_microns.x, displacement_in_microns.y}\"\n            )\n            print(f\"Rotation: {rotation}, type: {type(rotation)}\")\n            print(\"---\")\n\n            if self._cell_has_direct_polygons(child_cell, marker_layer):\n                child_cell_group = Group(\n                    name=child_cell.name,\n                    position=[\n                        displacement_in_microns.x,\n                        displacement_in_microns.y,\n                        0,\n                    ],\n                    rotation=[0, 0, rotation],\n                )\n                image_file_path = f\"./images_{self.gds_name}_{marker_layer}/marker_{marker_layer}.png\"\n                self._ensure_folder_exist_else_create(\n                    f\"./images_{self.gds_name}_{marker_layer}\"\n                )\n                scene = Scene(name=child_cell.name)\n\n                polygons = self._gather_polygons_in_child_cell(\n                    child_cell, marker_layer\n                )\n                shapely_polygons = self._polygons_to_shapely(polygons)\n                marker_polygons = self._merge_touching_polygons(\n                    shapely_polygons\n                )\n                _, marker_orientations = (\n                    self._group_equivalent_polygons_and_output_image(\n                        marker_polygons, file_path=image_file_path\n                    )\n                )\n\n                _image = (\n                    Image(name=f\"{marker_layer}\", file_path=image_file_path)\n                    if image_resource is None\n                    else image_resource\n                )\n                if (\n                    self._previous_image_safe_path_marker_aligned_printing.split(\n                        \"/\"\n                    )[\n                        1\n                    ]\n                    != _image.safe_path.split(\"/\")[1]\n                ):\n\n                    self._image = (\n                        Image(\n                            name=f\"{marker_layer}\", file_path=image_file_path\n                        )\n                        if image_resource is None\n                        else image_resource\n                    )\n                    self._previous_image_safe_path_marker_aligned_printing = (\n                        self._image.safe_path\n                    )\n                    project.load_resources(self._image)\n\n                marker_size = [\n                    marker_polygons[0].bounds[2]\n                    - marker_polygons[0].bounds[0],\n                    marker_polygons[0].bounds[3]\n                    - marker_polygons[0].bounds[1],\n                ]\n                marker_positions = [\n                    [m_pol.centroid.x, m_pol.centroid.y, marker_height]\n                    for m_pol in marker_polygons\n                ]\n\n                if \"max_outliers\" not in marker_aligner_kwargs:\n                    marker_aligner_kwargs[\"max_outliers\"] = (\n                        len(marker_positions) - 3\n                        if len(marker_positions) &gt;= 3\n                        else 0\n                    )\n                marker_aligner = (\n                    MarkerAligner(\n                        name=f\"{marker_layer}\",\n                        image=self._image,\n                        marker_size=marker_size,\n                        **marker_aligner_kwargs,\n                    )\n                    if marker_aligner_node is None\n                    else marker_aligner_node.deepcopy_node()\n                )\n\n                marker_aligner.set_markers_at(\n                    positions=marker_positions,\n                    orientations=marker_orientations,\n                )\n\n                for mesh, preset, mesh_spots_layer, color in zip(\n                    meshes, presets, mesh_spots_layers, colors\n                ):\n                    if self._cell_has_direct_polygons(\n                        child_cell, mesh_spots_layer\n                    ):\n                        mesh_spots_polygons = (\n                            self._gather_polygons_in_child_cell(\n                                child_cell, mesh_spots_layer\n                            )\n                        )\n                        mesh_spots_shapely_polygons = (\n                            self._polygons_to_shapely(mesh_spots_polygons)\n                        )\n                        structures = [\n                            Structure(\n                                mesh=mesh,\n                                preset=preset,\n                                name=mesh.name,\n                                position=[\n                                    mesh_spot_shapely_polygon.centroid.x,\n                                    mesh_spot_shapely_polygon.centroid.y,\n                                    0,\n                                ],\n                                color=color,\n                                **structure_kwargs,\n                            )\n                            for mesh_spot_shapely_polygon in mesh_spots_shapely_polygons\n                        ]\n                        marker_aligner.add_child(*structures)\n\n                interface_aligner = (\n                    InterfaceAligner()\n                    if interface_aligner_node is None\n                    else interface_aligner_node.deepcopy_node()\n                )\n\n                cell_origin_offset_group = Group(\n                    name=\"cell_origin_offset\",\n                    position=[\n                        cell_origin_offset[0],\n                        cell_origin_offset[1],\n                        0,\n                    ],\n                )\n                child_cell_group.append_node(\n                    scene,\n                    interface_aligner,\n                    cell_origin_offset_group,\n                    marker_aligner,\n                )\n\n            else:\n                child_cell_group = Group(\n                    name=child_cell.name,\n                    position=[\n                        displacement_in_microns.x,\n                        displacement_in_microns.y,\n                        0,\n                    ],\n                    rotation=[0, 0, rotation],\n                )\n                print(\"No direct polygons found in top cell\")\n\n            #  Do NOT assume you could shove this in the if-statement above\n            if not child_cell.is_leaf():\n                cell_group.add_child(child_cell_group)\n                child_cell_group.add_child(\n                    self.marker_aligned_printing(\n                        project,\n                        presets,\n                        meshes,\n                        cell_name=child_cell.name,\n                        cell_origin_offset=cell_origin_offset,\n                        image_resource=image_resource,\n                        interface_aligner_node=interface_aligner_node,\n                        marker_aligner_node=marker_aligner_node,\n                        marker_height=marker_height,\n                        marker_layer=marker_layer,\n                        mesh_spots_layers=mesh_spots_layers,\n                        colors=colors,\n                        marker_aligner_kwargs=marker_aligner_kwargs,\n                        structure_kwargs=structure_kwargs,\n                        _verbose=_verbose,\n                    )\n                )\n\n            else:\n                cell_group.add_child(child_cell_group)\n\n                print(\"LEAF!\")\n\n        return cell_group\n\n    def _get_geometry_coords(self, geometry):\n        \"\"\"Extract all coordinates from a geometry (Polygon or MultiPolygon).\"\"\"\n        coords = []\n        if isinstance(geometry, MultiPolygon):\n            for polygon in geometry.geoms:\n                exterior = list(polygon.exterior.coords)\n                coords.extend(exterior)\n                for interior in polygon.interiors:\n                    coords.extend(interior.coords)\n        elif isinstance(geometry, Polygon):\n            exterior = list(geometry.exterior.coords)\n            coords.extend(exterior)\n            for interior in geometry.interiors:\n                coords.extend(interior.coords)\n        else:\n            raise ValueError(\"Unsupported geometry type\")\n        return np.array(coords)\n\n    def _normalize_geometry_with_rotation(self, geometry):\n        \"\"\"Normalize a geometry and return the normalized version and rotation applied.\"\"\"\n        centroid = geometry.centroid\n        translated = translate(geometry, -centroid.x, -centroid.y)\n\n        coords = self._get_geometry_coords(translated)\n        if len(coords) &lt; 2:\n            return translated, 0.0\n\n        centered = coords - np.mean(coords, axis=0)\n        cov = np.cov(centered.T)\n        eigenvalues, eigenvectors = np.linalg.eig(cov)\n        principal = eigenvectors[:, np.argmax(eigenvalues)]\n        angle_rad = np.arctan2(principal[1], principal[0])\n        angle_deg = np.degrees(angle_rad)\n        rotated1 = rotate(translated, -angle_deg, origin=(0, 0))\n\n        # Check orientation\n        if isinstance(rotated1, MultiPolygon):\n            first_poly = rotated1.geoms[0]\n            coords_rotated = list(first_poly.exterior.coords)\n        else:\n            coords_rotated = list(rotated1.exterior.coords)\n\n        flip = False\n        if len(coords_rotated) &gt;= 2:\n            dx = coords_rotated[1][0] - coords_rotated[0][0]\n            dy = coords_rotated[1][1] - coords_rotated[0][1]\n            if dx &lt; 0 or (dx == 0 and dy &lt; 0):\n                flip = True\n\n        if flip:\n            rotated_final = rotate(rotated1, 180, origin=(0, 0))\n            total_rotation = -angle_deg + 180\n        else:\n            rotated_final = rotated1\n            total_rotation = -angle_deg\n\n        return rotated_final, total_rotation\n\n    def _group_equivalent_polygons_and_output_image(\n        self, polygons, tolerance=1e-6, file_path=\"./images/marker.png\"\n    ):\n        \"\"\"\n        Groups polygons into equivalence classes based on shape and size, ignoring position and rotation.\n        Returns unique representatives and their relative orientations.\n        \"\"\"\n        groups = []  # Each entry is (original_geo, rotation, normalized_geo)\n        angle_groups = []\n\n        for geo in polygons:\n            normalized, rotation = self._normalize_geometry_with_rotation(geo)\n            found = False\n            for i, (orig_rep, rot_rep, norm_rep) in enumerate(groups):\n                if self._are_geometries_equivalent(\n                    normalized, norm_rep, tolerance\n                ):\n                    rel_angle = (rot_rep - rotation) % 360.0\n                    angle_groups[i].append(rel_angle)\n                    found = True\n                    break\n            if not found:\n                groups.append((geo, rotation, normalized))\n                angle_groups.append([0.0])\n\n        unique_geometries = [orig_rep for orig_rep, _, _ in groups]\n\n        # Generate Image for MarkerAligner\n        self._save_geometry_as_png(unique_geometries[0], output_file=file_path)\n\n        return unique_geometries, angle_groups[0]  # TODO: Fix this maybe?\n\n    def _calculate_bounds(self, geometry):\n        \"\"\"\n        Calculate the bounding box of a Shapely Polygon or MultiPolygon.\n        \"\"\"\n        if isinstance(geometry, MultiPolygon):\n            # Get bounds for all polygons in the MultiPolygon\n            bounds = [polygon.bounds for polygon in geometry.geoms]\n            min_x = min(b[0] for b in bounds)\n            min_y = min(b[1] for b in bounds)\n            max_x = max(b[2] for b in bounds)\n            max_y = max(b[3] for b in bounds)\n            return min_x, min_y, max_x, max_y\n        elif isinstance(geometry, Polygon):\n            # Get bounds for a single Polygon\n            return geometry.bounds\n        else:\n            raise ValueError(\n                \"Unsupported geometry type. Expected Polygon or MultiPolygon.\"\n            )\n\n    def _rescale_coords(self, coords, min_x, min_y, scaling_factor):\n        \"\"\"\n        Rescale coordinates based on a scaling factor.\n        \"\"\"\n        return [\n            ((x - min_x) * scaling_factor, (y - min_y) * scaling_factor)\n            for x, y in coords\n        ]\n\n    def _draw_polygon(\n        self, draw, polygon, min_x, min_y, scaling_factor, fill_color\n    ):\n        \"\"\"\n        Draw a rescaled polygon (with holes) on an image.\n        \"\"\"\n        # Rescale and draw the exterior\n        rescaled_exterior = self._rescale_coords(\n            polygon.exterior.coords, min_x, min_y, scaling_factor\n        )\n        draw.polygon(rescaled_exterior, fill=fill_color)\n\n        # Rescale and draw the holes (interiors)\n        for interior in polygon.interiors:\n            rescaled_interior = self._rescale_coords(\n                interior.coords, min_x, min_y, scaling_factor\n            )\n            draw.polygon(rescaled_interior, fill=\"white\")\n\n    def _save_geometry_as_png(\n        self,\n        geometry,\n        target_resolution=600,\n        output_file=\"output.png\",\n        fill_color=\"black\",\n    ):\n        \"\"\"\n        Save a Shapely Polygon or MultiPolygon as a PNG image.\n        \"\"\"\n        # Calculate the bounds of the geometry\n        min_x, min_y, max_x, max_y = self._calculate_bounds(geometry)\n\n        # Calculate the width and height of the bounding box\n        width = max_x - min_x\n        height = max_y - min_y\n\n        # Determine the scaling factor to fit the geometry into the target resolution\n        scaling_factor = min(\n            target_resolution / width, target_resolution / height\n        )\n\n        # Calculate the new image size based on the scaling factor\n        new_width = int(width * scaling_factor)\n        new_height = int(height * scaling_factor)\n\n        # Create a blank image with a white background\n        image = PIL.Image.new(\"RGB\", (new_width, new_height), \"white\")\n        draw = PIL.ImageDraw.Draw(image)\n\n        # Draw each polygon in the MultiPolygon (or the single Polygon)\n        if isinstance(geometry, MultiPolygon):\n            for polygon in geometry.geoms:\n                self._draw_polygon(\n                    draw, polygon, min_x, min_y, scaling_factor, fill_color\n                )\n        else:\n            self._draw_polygon(\n                draw, geometry, min_x, min_y, scaling_factor, fill_color\n            )\n\n        # Save the image as a PNG file\n        image.save(output_file)\n        print(f\"Image saved as {output_file}\")\n\n    def get_cell_by_name(self, cell_name: str) -&gt; pya.Cell:\n        \"\"\"Retrieve a cell by its name from the GDS layout.\n\n        Args:\n            cell_name: Name of the cell to retrieve. Case-sensitive.\n\n        Returns:\n            pya.Cell: The requested cell object.\n\n        Raises:\n            TypeError: If input is not a string\n            KeyError: If no cell with specified name exists\n        \"\"\"\n        # Input validation\n        if not isinstance(cell_name, str):\n            raise TypeError(\n                f\"Expected string for cell name, got {type(cell_name)}\"\n            )\n\n        # Efficient search using layout's cell dictionary\n        cell = self.layout.cell(cell_name)\n        if cell is None:\n            available_cells = [c.name for c in self.layout.each_cell()]\n            raise KeyError(\n                f\"Cell '{cell_name}' not found in GDS layout. \"\n                f\"Available cells: {', '.join(available_cells[:5])}...\"\n            )\n        return cell\n\n    def _merged_polygons_and_their_positions(self, child_cell, layer, z_pos):\n\n        polygons = self._gather_polygons_in_child_cell(child_cell, layer)\n        shapely_polygons = self._polygons_to_shapely(polygons)\n        merged_polygons = self._merge_touching_polygons(shapely_polygons)\n\n        positions = [\n            [m_pol.centroid.x, m_pol.centroid.y, z_pos]\n            for m_pol in merged_polygons\n        ]\n        return merged_polygons, positions\n\n    def get_marker_aligner(\n        self,\n        cell_name: str,\n        project: Optional[Project] = None,\n        marker_layer: Tuple[int, int] = (254, 254),\n        marker_height: float = 0.33,\n        image_resource: Optional[Image] = None,\n        **marker_aligner_kwargs: Dict,\n    ) -&gt; MarkerAligner:\n        \"\"\"Create and configure a MarkerAligner from GDS markers.\n\n        Args:\n            cell_name: Name of the cell containing markers\n            project: Optional Project for resource management\n            marker_layer: Layer/datatype tuple for marker identification\n            marker_height: Z-height for marker polygons\n            image_resource: Optional pre-configured Image resource\n            **marker_aligner_kwargs: Additional MarkerAligner configuration\n\n        Returns:\n            Configured MarkerAligner instance\n\n        Raises:\n            ValueError: If no markers found or invalid input dimensions\n            TypeError: For invalid input types\n            RuntimeError: If image processing fails\n        \"\"\"\n        # Input validation\n        if not isinstance(marker_layer, tuple) or len(marker_layer) != 2:\n            raise TypeError(\"marker_layer must be a (int, int) tuple\")\n        if marker_height &lt; 0:\n            raise ValueError(\"marker_height must be non-negative\")\n\n        try:\n            cell = self.get_cell_by_name(cell_name)\n        except KeyError as e:\n            raise ValueError(f\"Cell '{cell_name}' not found in layout\") from e\n\n        # Polygon processing\n        marker_polygons, marker_positions = (\n            self._merged_polygons_and_their_positions(\n                cell, marker_layer, marker_height\n            )\n        )\n\n        if not marker_polygons:\n            raise ValueError(f\"No markers found on layer {marker_layer}\")\n        if len(marker_positions) &lt; 3:\n            raise ValueError(\"At least 3 markers required for alignment\")\n\n        # Image resource handling\n        image_dir = f\"./images_{self.gds_name}_{marker_layer}\"\n        self._ensure_folder_exist_else_create(image_dir)\n\n        image_file_path = os.path.join(image_dir, f\"marker_{marker_layer}.png\")\n        _image = image_resource or Image(\n            name=str(marker_layer), file_path=image_file_path\n        )\n\n        if project is not None:\n            if not isinstance(project, Project):\n                raise TypeError(\"project must be a Project instance\")\n            project.load_resources(_image)\n\n        # Marker processing\n        _, marker_orientations = (\n            self._group_equivalent_polygons_and_output_image(\n                marker_polygons, file_path=image_file_path\n            )\n        )\n\n        try:\n            marker_size = [\n                marker_polygons[0].bounds[2] - marker_polygons[0].bounds[0],\n                marker_polygons[0].bounds[3] - marker_polygons[0].bounds[1],\n            ]\n        except:\n            UserWarning(\n                \"Failed to calculate marker sizes based on GDS-polygons.\"\n                \" Default [5.0,5.0] will be used instead.\"\n            )\n            marker_size = [5.0, 5.0]\n\n        if \"max_outliers\" not in marker_aligner_kwargs:\n            marker_aligner_kwargs[\"max_outliers\"] = (\n                len(marker_positions) - 3 if len(marker_positions) &gt;= 3 else 0\n            )\n        marker_aligner = MarkerAligner(\n            name=f\"{marker_layer}\",\n            image=_image,\n            marker_size=marker_size,\n            **marker_aligner_kwargs,\n        )\n\n        marker_aligner.set_markers_at(\n            positions=marker_positions,\n            orientations=marker_orientations,\n        )\n\n        return marker_aligner\n\n    def get_coarse_aligner(\n        self,\n        cell_name: str,\n        coarse_layer: Tuple[int, int] = (200, 200),\n        residual_threshold: float = 10.0,\n    ) -&gt; CoarseAligner:\n        \"\"\"Create a CoarseAligner from anchor points in GDS.\n\n        Args:\n            cell_name: Name of the cell containing coarse alignment features\n            coarse_layer: Layer/datatype tuple for anchor identification\n            residual_threshold: Maximum allowed alignment residual\n\n        Returns:\n            Configured CoarseAligner instance\n\n        Raises:\n            ValueError: If no anchors found or invalid threshold\n        \"\"\"\n        if not isinstance(coarse_layer, tuple) or len(coarse_layer) != 2:\n            raise TypeError(\"marker_layer must be a (int, int) tuple\")\n        if residual_threshold &lt;= 0:\n            raise ValueError(\"residual_threshold must be positive\")\n\n        cell = self.get_cell_by_name(cell_name)\n        _, anchor_positions = self._merged_polygons_and_their_positions(\n            cell, coarse_layer, 0\n        )\n\n        return CoarseAligner(\n            name=f\"{cell.name}{coarse_layer}\",\n            residual_threshold=residual_threshold,\n        ).set_coarse_anchors_at(anchor_positions)\n\n    def get_custom_interface_aligner(\n        self,\n        cell_name: str,\n        interface_layer: Tuple[int, int] = (255, 255),\n        scan_area_sizes: Optional[List[List[float]]] = None,\n        **interface_aligner_kwargs: Dict,\n    ) -&gt; InterfaceAligner:\n        \"\"\"Create an InterfaceAligner with custom scan areas from GDS.\n\n        Args:\n            cell_name: Name of the cell containing interface features\n            interface_layer: Layer/datatype tuple for scan areas\n            scan_area_sizes: Optional list of [width, height] pairs\n            **interface_aligner_kwargs: Additional InterfaceAligner config\n\n        Returns:\n            Configured InterfaceAligner instance\n        \"\"\"\n        if not isinstance(interface_layer, tuple) or len(interface_layer) != 2:\n            raise TypeError(\"marker_layer must be a (int, int) tuple\")\n\n        cell = self.get_cell_by_name(cell_name)\n        scan_area_sizes_polygons, anchor_positions = (\n            self._merged_polygons_and_their_positions(cell, interface_layer, 0)\n        )\n\n        scan_area_sizes = (\n            [\n                [\n                    scan_area_sizes_polygons[i].bounds[2]\n                    - scan_area_sizes_polygons[i].bounds[0],\n                    scan_area_sizes_polygons[i].bounds[3]\n                    - scan_area_sizes_polygons[i].bounds[1],\n                ]\n                for i in range(len(scan_area_sizes_polygons))\n            ]\n            if scan_area_sizes is None\n            else scan_area_sizes\n        )\n\n        return InterfaceAligner(\n            name=f\"{cell.name}{interface_layer}\",\n            **interface_aligner_kwargs,\n        ).set_interface_anchors_at(\n            positions=anchor_positions,\n            scan_area_sizes=scan_area_sizes,\n        )\n</code></pre>"},{"location":"gds/GDSParser/#npxpy.gds.GDSParser.gds_file","title":"<code>gds_file</code>  <code>property</code> <code>writable</code>","text":"<p>Get path to loaded GDS file.</p>"},{"location":"gds/GDSParser/#npxpy.gds.GDSParser.gds_name","title":"<code>gds_name</code>  <code>property</code>","text":"<p>Get base name of GDS file without extension.</p>"},{"location":"gds/GDSParser/#npxpy.gds.GDSParser.layout","title":"<code>layout</code>  <code>property</code>","text":"<p>Get parsed GDS layout object.</p>"},{"location":"gds/GDSParser/#npxpy.gds.GDSParser.__init__","title":"<code>__init__(gds_file)</code>","text":"<p>Initialize GDS parser with file validation and dependency checks.</p> <p>Parameters:</p> Name Type Description Default <code>gds_file</code> <code>str</code> <p>Path to GDSII file to load</p> required <p>Raises:</p> Type Description <code>ImportError</code> <p>If required dependencies are missing</p> <code>FileNotFoundError</code> <p>If specified file doesn't exist</p> <code>ValueError</code> <p>For invalid file types or parsing errors</p> Source code in <code>npxpy/gds.py</code> <pre><code>def __init__(self, gds_file: str) -&gt; None:\n    \"\"\"Initialize GDS parser with file validation and dependency checks.\n\n    Args:\n        gds_file: Path to GDSII file to load\n\n    Raises:\n        ImportError: If required dependencies are missing\n        FileNotFoundError: If specified file doesn't exist\n        ValueError: For invalid file types or parsing errors\n    \"\"\"\n    self.gds_file = gds_file  # Validated through property setter\n    self._layout = pya.Layout()\n    self._layout.read(gds_file)  # Let pya exceptions bubble up\n    self._plot_tiles_flag = False\n    self._previous_image_safe_path_marker_aligned_printing = \"0/0\"\n    self._check_dependencies()\n</code></pre>"},{"location":"gds/GDSParser/#npxpy.gds.GDSParser.gds_printing","title":"<code>gds_printing(project, preset, cell_name=None, write_field_scene=None, layer=(1, 0), epsilon=1.0, tile_size=(200.0, 200.0), extrusion=20.0, skip_if_exists=False, color='#16506B', iterate_over_each_polygon=False, hollow=True, hollow_scale=0.9, hollow_shift_z=-2.0, layer_to_print=None, _verbose=False)</code>","text":"<p>Process GDS layout to generate tiled scenes for 3D printing.</p> <p>This method processes a GDS layout, divides it into tiles, creates 3D extrusions from the polygons, and generates scenes for each tile with appropriate positioning.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>Project instance to which generated meshes are loaded to.</p> required <code>preset</code> <code>Preset</code> <p>Preset instance for printing.</p> required <code>cell_name</code> <code>Optional[str]</code> <p>Name of the cell in GDS to process.</p> <code>None</code> <code>write_field_scene</code> <code>Optional[Scene]</code> <p>Scene template for writing fields.</p> <code>None</code> <code>layer</code> <code>Tuple[int, int]</code> <p>Layer containing polygons that are supposed to be extruded and printed.</p> <code>(1, 0)</code> <code>extrusion</code> <code>float</code> <p>Thickness for 3D extrusion.</p> <code>20.0</code> <code>tile_size</code> <code>Tuple[float, float]</code> <p>Size of each tile in micrometers.</p> <code>(200.0, 200.0)</code> <code>epsilon</code> <code>float</code> <p>Overlap value between tiles in micrometers.</p> <code>1.0</code> <code>skip_if_exists</code> <code>bool</code> <p>Skip processing if output files already exist.</p> <code>False</code> <code>color</code> <code>str</code> <p>Color for generated structures in viewer.</p> <code>'#16506B'</code> <code>iterate_over_each_polygon</code> <code>bool</code> <p>Tile each polygon individually if True</p> <code>False</code> <code>hollow</code> <code>bool</code> <p>Create hollow structures if True</p> <code>True</code> <code>hollow_scale</code> <code>float</code> <p>Scaling factor for hollow structures</p> <code>0.9</code> <code>hollow_shift_z</code> <code>float</code> <p>Z-axis shift for hollow structures</p> <code>-2.0</code> <code>_verbose</code> <code>bool</code> <p>Verbose output flag (for debugging/developing)</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Group</code> <code>Group</code> <p>Group instance containing all generated tile scenes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Invalid input parameters</p> <code>TypeError</code> <p>Incorrect argument types</p> <code>RuntimeError</code> <p>Polygon processing failure</p> Source code in <code>npxpy/gds.py</code> <pre><code>def gds_printing(\n    self,\n    project: Project,\n    preset: Preset,\n    cell_name: Optional[str] = None,\n    write_field_scene: Optional[Scene] = None,\n    layer: Tuple[int, int] = (1, 0),\n    epsilon: float = 1.0,\n    tile_size: Tuple[float, float] = (200.0, 200.0),\n    extrusion: float = 20.0,\n    skip_if_exists: bool = False,\n    color: str = \"#16506B\",\n    iterate_over_each_polygon: bool = False,\n    hollow: bool = True,\n    hollow_scale: float = 0.9,\n    hollow_shift_z: float = -2.0,\n    layer_to_print=None,\n    _verbose: bool = False,\n) -&gt; Group:\n    \"\"\"\n    Process GDS layout to generate tiled scenes for 3D printing.\n\n    This method processes a GDS layout, divides it into tiles, creates 3D extrusions\n    from the polygons, and generates scenes for each tile with appropriate positioning.\n\n    Args:\n        project: Project instance to which generated meshes are loaded to.\n        preset: Preset instance for printing.\n        cell_name: Name of the cell in GDS to process.\n        write_field_scene: Scene template for writing fields.\n        layer: Layer containing polygons that are supposed to be extruded and printed.\n        extrusion: Thickness for 3D extrusion.\n        tile_size: Size of each tile in micrometers.\n        epsilon: Overlap value between tiles in micrometers.\n        skip_if_exists: Skip processing if output files already exist.\n        color: Color for generated structures in viewer.\n        iterate_over_each_polygon: Tile each polygon individually if True\n        hollow: Create hollow structures if True\n        hollow_scale: Scaling factor for hollow structures\n        hollow_shift_z: Z-axis shift for hollow structures\n        _verbose: Verbose output flag (for debugging/developing)\n\n    Returns:\n        Group: Group instance containing all generated tile scenes.\n\n    Raises:\n        ValueError: Invalid input parameters\n        TypeError: Incorrect argument types\n        RuntimeError: Polygon processing failure\n    \"\"\"\n    # Input validation\n    if not isinstance(project, Project):\n        raise TypeError(\"project must be a Project instance\")\n    if not isinstance(preset, Preset):\n        raise TypeError(\"preset must be a Preset instance\")\n    if cell_name is not None and not isinstance(cell_name, str):\n        raise TypeError(\"cell_name must be a string or None\")\n    if write_field_scene is not None and not isinstance(\n        write_field_scene, Scene\n    ):\n        raise TypeError(\n            \"write_field_scene must be a Scene instance or None\"\n        )\n    if layer == (1, 0) and layer_to_print is not None:\n        DeprecationWarning(\n            \"Argument layer_to_print is deprecated and will \"\n            \"be removed in a future release. Use layer instead.\"\n        )\n        layer = layer_to_print\n    elif layer_to_print is not None:\n        DeprecationWarning(\n            \"Argument layer_to_print is deprecated and will be removed \"\n            \"in a future release. Argument layer will be used instead. \"\n        )\n    # Validate layer_to_print structure and content\n    if not isinstance(layer, tuple) or len(layer) != 2:\n        raise TypeError(\"layer must be a tuple of two integers\")\n    if not all(isinstance(x, int) for x in layer):\n        raise TypeError(\"Both elements in layer must be integers\")\n\n    # Validate numerical parameters\n    if not isinstance(extrusion, (int, float)):\n        raise TypeError(\"extrusion must be a numeric value\")\n    if not isinstance(tile_size, tuple) or len(layer) != 2:\n        raise TypeError(\"tile_size must be a tuple of two integers\")\n    if not all(isinstance(x, (int, float)) for x in tile_size):\n        raise TypeError(\n            \"All elements in tile_size must be numbers (int or float)\"\n        )\n    if not all(x &gt; 0 for x in tile_size):\n        raise ValueError(\"All elements in tile_size must be positive\")\n\n    if not isinstance(epsilon, (int, float)):\n        raise TypeError(\"epsilon must be a numeric value\")\n    if epsilon &lt; 0:\n        raise ValueError(\"epsilon must be non-negative\")\n    if not isinstance(hollow_scale, (int, float)):\n        raise TypeError(\n            \"hollow_scale must be a numeric value between 0 and 1.\"\n        )\n    if hollow_scale &lt; 0 or hollow_scale &gt; 1:\n        raise TypeError(\n            \"hollow_scale must be a numeric value between 0 and 1.\"\n        )\n    if not isinstance(hollow_shift_z, (int, float)):\n        raise TypeError(\"hollow_shift_z must be a numeric value.\")\n\n    # Validate boolean parameters\n    if not isinstance(skip_if_exists, bool):\n        raise TypeError(\"skip_if_exists must be a boolean\")\n    if not isinstance(iterate_over_each_polygon, bool):\n        raise TypeError(\"iterate_over_each_polygon must be a boolean\")\n    if not isinstance(hollow, bool):\n        raise TypeError(\"hollow must be a boolean\")\n    if not isinstance(_verbose, bool):\n        raise TypeError(\"_verbose must be a boolean\")\n\n    gds_printing_group = self._gds_printing_new(\n        project,\n        preset,\n        cell_name=cell_name,\n        write_field_scene=write_field_scene,\n        layer=layer,\n        extrusion=extrusion,\n        hollow=hollow,\n        hollow_scale=hollow_scale,\n        hollow_shift_z=hollow_shift_z,\n        tile_size=tile_size,\n        epsilon=epsilon,\n        skip_if_exists=skip_if_exists,\n        color=color,\n        iterate_over_each_polygon=iterate_over_each_polygon,\n        _verbose=_verbose,\n    )\n\n    return gds_printing_group\n</code></pre>"},{"location":"gds/GDSParser/#npxpy.gds.GDSParser.get_cell_by_name","title":"<code>get_cell_by_name(cell_name)</code>","text":"<p>Retrieve a cell by its name from the GDS layout.</p> <p>Parameters:</p> Name Type Description Default <code>cell_name</code> <code>str</code> <p>Name of the cell to retrieve. Case-sensitive.</p> required <p>Returns:</p> Type Description <code>Cell</code> <p>pya.Cell: The requested cell object.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input is not a string</p> <code>KeyError</code> <p>If no cell with specified name exists</p> Source code in <code>npxpy/gds.py</code> <pre><code>def get_cell_by_name(self, cell_name: str) -&gt; pya.Cell:\n    \"\"\"Retrieve a cell by its name from the GDS layout.\n\n    Args:\n        cell_name: Name of the cell to retrieve. Case-sensitive.\n\n    Returns:\n        pya.Cell: The requested cell object.\n\n    Raises:\n        TypeError: If input is not a string\n        KeyError: If no cell with specified name exists\n    \"\"\"\n    # Input validation\n    if not isinstance(cell_name, str):\n        raise TypeError(\n            f\"Expected string for cell name, got {type(cell_name)}\"\n        )\n\n    # Efficient search using layout's cell dictionary\n    cell = self.layout.cell(cell_name)\n    if cell is None:\n        available_cells = [c.name for c in self.layout.each_cell()]\n        raise KeyError(\n            f\"Cell '{cell_name}' not found in GDS layout. \"\n            f\"Available cells: {', '.join(available_cells[:5])}...\"\n        )\n    return cell\n</code></pre>"},{"location":"gds/GDSParser/#npxpy.gds.GDSParser.get_coarse_aligner","title":"<code>get_coarse_aligner(cell_name, coarse_layer=(200, 200), residual_threshold=10.0)</code>","text":"<p>Create a CoarseAligner from anchor points in GDS.</p> <p>Parameters:</p> Name Type Description Default <code>cell_name</code> <code>str</code> <p>Name of the cell containing coarse alignment features</p> required <code>coarse_layer</code> <code>Tuple[int, int]</code> <p>Layer/datatype tuple for anchor identification</p> <code>(200, 200)</code> <code>residual_threshold</code> <code>float</code> <p>Maximum allowed alignment residual</p> <code>10.0</code> <p>Returns:</p> Type Description <code>CoarseAligner</code> <p>Configured CoarseAligner instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no anchors found or invalid threshold</p> Source code in <code>npxpy/gds.py</code> <pre><code>def get_coarse_aligner(\n    self,\n    cell_name: str,\n    coarse_layer: Tuple[int, int] = (200, 200),\n    residual_threshold: float = 10.0,\n) -&gt; CoarseAligner:\n    \"\"\"Create a CoarseAligner from anchor points in GDS.\n\n    Args:\n        cell_name: Name of the cell containing coarse alignment features\n        coarse_layer: Layer/datatype tuple for anchor identification\n        residual_threshold: Maximum allowed alignment residual\n\n    Returns:\n        Configured CoarseAligner instance\n\n    Raises:\n        ValueError: If no anchors found or invalid threshold\n    \"\"\"\n    if not isinstance(coarse_layer, tuple) or len(coarse_layer) != 2:\n        raise TypeError(\"marker_layer must be a (int, int) tuple\")\n    if residual_threshold &lt;= 0:\n        raise ValueError(\"residual_threshold must be positive\")\n\n    cell = self.get_cell_by_name(cell_name)\n    _, anchor_positions = self._merged_polygons_and_their_positions(\n        cell, coarse_layer, 0\n    )\n\n    return CoarseAligner(\n        name=f\"{cell.name}{coarse_layer}\",\n        residual_threshold=residual_threshold,\n    ).set_coarse_anchors_at(anchor_positions)\n</code></pre>"},{"location":"gds/GDSParser/#npxpy.gds.GDSParser.get_custom_interface_aligner","title":"<code>get_custom_interface_aligner(cell_name, interface_layer=(255, 255), scan_area_sizes=None, **interface_aligner_kwargs)</code>","text":"<p>Create an InterfaceAligner with custom scan areas from GDS.</p> <p>Parameters:</p> Name Type Description Default <code>cell_name</code> <code>str</code> <p>Name of the cell containing interface features</p> required <code>interface_layer</code> <code>Tuple[int, int]</code> <p>Layer/datatype tuple for scan areas</p> <code>(255, 255)</code> <code>scan_area_sizes</code> <code>Optional[List[List[float]]]</code> <p>Optional list of [width, height] pairs</p> <code>None</code> <code>**interface_aligner_kwargs</code> <code>Dict</code> <p>Additional InterfaceAligner config</p> <code>{}</code> <p>Returns:</p> Type Description <code>InterfaceAligner</code> <p>Configured InterfaceAligner instance</p> Source code in <code>npxpy/gds.py</code> <pre><code>def get_custom_interface_aligner(\n    self,\n    cell_name: str,\n    interface_layer: Tuple[int, int] = (255, 255),\n    scan_area_sizes: Optional[List[List[float]]] = None,\n    **interface_aligner_kwargs: Dict,\n) -&gt; InterfaceAligner:\n    \"\"\"Create an InterfaceAligner with custom scan areas from GDS.\n\n    Args:\n        cell_name: Name of the cell containing interface features\n        interface_layer: Layer/datatype tuple for scan areas\n        scan_area_sizes: Optional list of [width, height] pairs\n        **interface_aligner_kwargs: Additional InterfaceAligner config\n\n    Returns:\n        Configured InterfaceAligner instance\n    \"\"\"\n    if not isinstance(interface_layer, tuple) or len(interface_layer) != 2:\n        raise TypeError(\"marker_layer must be a (int, int) tuple\")\n\n    cell = self.get_cell_by_name(cell_name)\n    scan_area_sizes_polygons, anchor_positions = (\n        self._merged_polygons_and_their_positions(cell, interface_layer, 0)\n    )\n\n    scan_area_sizes = (\n        [\n            [\n                scan_area_sizes_polygons[i].bounds[2]\n                - scan_area_sizes_polygons[i].bounds[0],\n                scan_area_sizes_polygons[i].bounds[3]\n                - scan_area_sizes_polygons[i].bounds[1],\n            ]\n            for i in range(len(scan_area_sizes_polygons))\n        ]\n        if scan_area_sizes is None\n        else scan_area_sizes\n    )\n\n    return InterfaceAligner(\n        name=f\"{cell.name}{interface_layer}\",\n        **interface_aligner_kwargs,\n    ).set_interface_anchors_at(\n        positions=anchor_positions,\n        scan_area_sizes=scan_area_sizes,\n    )\n</code></pre>"},{"location":"gds/GDSParser/#npxpy.gds.GDSParser.get_marker_aligner","title":"<code>get_marker_aligner(cell_name, project=None, marker_layer=(254, 254), marker_height=0.33, image_resource=None, **marker_aligner_kwargs)</code>","text":"<p>Create and configure a MarkerAligner from GDS markers.</p> <p>Parameters:</p> Name Type Description Default <code>cell_name</code> <code>str</code> <p>Name of the cell containing markers</p> required <code>project</code> <code>Optional[Project]</code> <p>Optional Project for resource management</p> <code>None</code> <code>marker_layer</code> <code>Tuple[int, int]</code> <p>Layer/datatype tuple for marker identification</p> <code>(254, 254)</code> <code>marker_height</code> <code>float</code> <p>Z-height for marker polygons</p> <code>0.33</code> <code>image_resource</code> <code>Optional[Image]</code> <p>Optional pre-configured Image resource</p> <code>None</code> <code>**marker_aligner_kwargs</code> <code>Dict</code> <p>Additional MarkerAligner configuration</p> <code>{}</code> <p>Returns:</p> Type Description <code>MarkerAligner</code> <p>Configured MarkerAligner instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no markers found or invalid input dimensions</p> <code>TypeError</code> <p>For invalid input types</p> <code>RuntimeError</code> <p>If image processing fails</p> Source code in <code>npxpy/gds.py</code> <pre><code>def get_marker_aligner(\n    self,\n    cell_name: str,\n    project: Optional[Project] = None,\n    marker_layer: Tuple[int, int] = (254, 254),\n    marker_height: float = 0.33,\n    image_resource: Optional[Image] = None,\n    **marker_aligner_kwargs: Dict,\n) -&gt; MarkerAligner:\n    \"\"\"Create and configure a MarkerAligner from GDS markers.\n\n    Args:\n        cell_name: Name of the cell containing markers\n        project: Optional Project for resource management\n        marker_layer: Layer/datatype tuple for marker identification\n        marker_height: Z-height for marker polygons\n        image_resource: Optional pre-configured Image resource\n        **marker_aligner_kwargs: Additional MarkerAligner configuration\n\n    Returns:\n        Configured MarkerAligner instance\n\n    Raises:\n        ValueError: If no markers found or invalid input dimensions\n        TypeError: For invalid input types\n        RuntimeError: If image processing fails\n    \"\"\"\n    # Input validation\n    if not isinstance(marker_layer, tuple) or len(marker_layer) != 2:\n        raise TypeError(\"marker_layer must be a (int, int) tuple\")\n    if marker_height &lt; 0:\n        raise ValueError(\"marker_height must be non-negative\")\n\n    try:\n        cell = self.get_cell_by_name(cell_name)\n    except KeyError as e:\n        raise ValueError(f\"Cell '{cell_name}' not found in layout\") from e\n\n    # Polygon processing\n    marker_polygons, marker_positions = (\n        self._merged_polygons_and_their_positions(\n            cell, marker_layer, marker_height\n        )\n    )\n\n    if not marker_polygons:\n        raise ValueError(f\"No markers found on layer {marker_layer}\")\n    if len(marker_positions) &lt; 3:\n        raise ValueError(\"At least 3 markers required for alignment\")\n\n    # Image resource handling\n    image_dir = f\"./images_{self.gds_name}_{marker_layer}\"\n    self._ensure_folder_exist_else_create(image_dir)\n\n    image_file_path = os.path.join(image_dir, f\"marker_{marker_layer}.png\")\n    _image = image_resource or Image(\n        name=str(marker_layer), file_path=image_file_path\n    )\n\n    if project is not None:\n        if not isinstance(project, Project):\n            raise TypeError(\"project must be a Project instance\")\n        project.load_resources(_image)\n\n    # Marker processing\n    _, marker_orientations = (\n        self._group_equivalent_polygons_and_output_image(\n            marker_polygons, file_path=image_file_path\n        )\n    )\n\n    try:\n        marker_size = [\n            marker_polygons[0].bounds[2] - marker_polygons[0].bounds[0],\n            marker_polygons[0].bounds[3] - marker_polygons[0].bounds[1],\n        ]\n    except:\n        UserWarning(\n            \"Failed to calculate marker sizes based on GDS-polygons.\"\n            \" Default [5.0,5.0] will be used instead.\"\n        )\n        marker_size = [5.0, 5.0]\n\n    if \"max_outliers\" not in marker_aligner_kwargs:\n        marker_aligner_kwargs[\"max_outliers\"] = (\n            len(marker_positions) - 3 if len(marker_positions) &gt;= 3 else 0\n        )\n    marker_aligner = MarkerAligner(\n        name=f\"{marker_layer}\",\n        image=_image,\n        marker_size=marker_size,\n        **marker_aligner_kwargs,\n    )\n\n    marker_aligner.set_markers_at(\n        positions=marker_positions,\n        orientations=marker_orientations,\n    )\n\n    return marker_aligner\n</code></pre>"},{"location":"gds/GDSParser/#npxpy.gds.GDSParser.get_scenes","title":"<code>get_scenes(scene_layer, project, presets, meshes=None, marker_layer=None, marker_region_layer=None, marker_height=0.33, image_resource=None, marker_aligner_node=None, interface_aligner_node=None, interface_aligner_layer=None, mesh_spots_layers=None, cell_name=None, colors=None, structure_kwargs=None, _verbose=False)</code>","text":"<p>Process scenes from GDS layout and generate structured print scenes.</p> <p>This method takes a scene layer as designation for the print scene and checks for markers lying inside the scene as provided by marker_layer. In case the marker pattern consists of disjoint polygons, it is necessary to provide a marker_region_layer that defines the image frame for every single marker to ensure correct image generation. Markers may have different orientations but always have to have the same size/shape per layer.</p> <p>Parameters:</p> Name Type Description Default <code>scene_layer</code> <code>Tuple[int, int]</code> <p>Layer specification for scene regions</p> required <code>project</code> <code>Project</code> <p>Project instance in which read-out markers from GDS are loaded to.</p> required <code>presets</code> <code>List[Preset]</code> <p>Bijective list of Preset instances for each mesh (referred to by index)</p> required <code>meshes</code> <code>Optional[List[Mesh]]</code> <p>List of mesh objects (optional)</p> <code>None</code> <code>marker_layer</code> <code>Optional[Tuple[int, int]]</code> <p>Layer specification for markers</p> <code>None</code> <code>marker_region_layer</code> <code>Optional[Tuple[int, int]]</code> <p>Layer specification for marker regions</p> <code>None</code> <code>marker_height</code> <code>float</code> <p>Height value for markers</p> <code>0.33</code> <code>image_resource</code> <code>Optional[str]</code> <p>Path to an alternative image resource (optional)</p> <code>None</code> <code>marker_aligner_node</code> <code>Optional[MarkerAligner]</code> <p>Custom marker alignment node (optional)</p> <code>None</code> <code>interface_aligner_node</code> <code>Optional[InterfaceAligner]</code> <p>Custom interface alignment node (optional)</p> <code>None</code> <code>interface_aligner_layer</code> <code>Optional[Tuple[int, int]]</code> <p>Layer specification for interface alignment (optional)</p> <code>None</code> <code>mesh_spots_layers</code> <code>Optional[List[Tuple[int, int]]]</code> <p>List of layer specifications for mesh spots (optional)</p> <code>None</code> <code>cell_name</code> <code>Optional[str]</code> <p>Name of the GDS cell to process (optional)</p> <code>None</code> <code>colors</code> <code>Optional[List[str]]</code> <p>Bijective list of colors for structures (optional)</p> <code>None</code> <code>structure_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Additional dictionary for keyword arguments for all structures</p> <code>None</code> <code>_verbose</code> <code>bool</code> <p>Verbose output flag</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Group</code> <code>Group</code> <p>Group node containing all generated scenes</p> Source code in <code>npxpy/gds.py</code> <pre><code>@verbose_output()\ndef get_scenes(\n    self,\n    scene_layer: Tuple[int, int],\n    project: Project,\n    presets: List[Preset],\n    meshes: Optional[List[Mesh]] = None,\n    marker_layer: Optional[Tuple[int, int]] = None,\n    marker_region_layer: Optional[Tuple[int, int]] = None,\n    marker_height: float = 0.33,\n    image_resource: Optional[str] = None,\n    marker_aligner_node: Optional[MarkerAligner] = None,\n    interface_aligner_node: Optional[InterfaceAligner] = None,\n    interface_aligner_layer: Optional[Tuple[int, int]] = None,\n    mesh_spots_layers: Optional[List[Tuple[int, int]]] = None,\n    cell_name: Optional[str] = None,\n    colors: Optional[List[str]] = None,\n    structure_kwargs: Optional[Dict[str, Any]] = None,\n    _verbose: bool = False,\n) -&gt; Group:\n    \"\"\"\n    Process scenes from GDS layout and generate structured print scenes.\n\n    This method takes a scene layer as designation for the print scene and checks\n    for markers lying inside the scene as provided by marker_layer.\n    In case the marker pattern consists of disjoint polygons,\n    it is necessary to provide a marker_region_layer that defines the\n    image frame for every single marker to ensure correct image generation.\n    Markers may have different orientations but always have to have the same\n    size/shape per layer.\n\n    Args:\n        scene_layer: Layer specification for scene regions\n        project: Project instance in which read-out markers from GDS are loaded to.\n        presets: Bijective list of Preset instances for each mesh (referred to by index)\n        meshes: List of mesh objects (optional)\n        marker_layer: Layer specification for markers\n        marker_region_layer: Layer specification for marker regions\n        marker_height: Height value for markers\n        image_resource: Path to an alternative image resource (optional)\n        marker_aligner_node: Custom marker alignment node (optional)\n        interface_aligner_node: Custom interface alignment node (optional)\n        interface_aligner_layer: Layer specification for interface alignment (optional)\n        mesh_spots_layers: List of layer specifications for mesh spots (optional)\n        cell_name: Name of the GDS cell to process (optional)\n        colors: Bijective list of colors for structures (optional)\n        structure_kwargs: Additional dictionary for keyword arguments for all structures\n        _verbose: Verbose output flag\n\n    Returns:\n        Group: Group node containing all generated scenes\n    \"\"\"\n    # Initialize default values\n    structure_kwargs = structure_kwargs or {}\n\n    # Check if all interface aligner related parameters are None\n    _no_interfacealigner_if_all_None = all(\n        v is None\n        for v in [\n            meshes,\n            marker_layer,\n            interface_aligner_node,\n            interface_aligner_layer,\n        ]\n    )\n\n    # Validation checks\n    if marker_layer is None and marker_region_layer is not None:\n        raise ValueError(\n            \"marker_layer must not be None if a marker_region_layer was specified.\\n\"\n            \"Either specify a marker_layer or set marker_region_layer=None as well.\"\n        )\n\n    if marker_layer is None:\n        marker_layer = (1_000_000, 1_000_000)\n\n    # Input layers\n    _marker_layer = self.layout.layer(*marker_layer)  # Target shapes\n    _marker_region_layer = (\n        self.layout.layer(*marker_region_layer)\n        if marker_region_layer is not None\n        else self.layout.layer(*marker_layer)\n    )  # Target regions\n    _scene_layer = self.layout.layer(*scene_layer)  # Region definition\n\n    # Create regions\n    top_cell = (\n        self.layout.top_cell()\n        if cell_name is None\n        else self.get_cell_by_name(cell_name=cell_name, layout=self.layout)\n    )\n    scene_region = pya.Region(top_cell.begin_shapes_rec(_scene_layer))\n    marker_region = pya.Region(top_cell.begin_shapes_rec(_marker_layer))\n    marker_region_region = pya.Region(\n        top_cell.begin_shapes_rec(_marker_region_layer)\n    )\n\n    if interface_aligner_layer is not None:\n        _interface_aligner_layer = self.layout.layer(\n            *interface_aligner_layer\n        )\n        ia_region = pya.Region(\n            top_cell.begin_shapes_rec(_interface_aligner_layer)\n        )\n\n    if mesh_spots_layers is not None:\n        _mesh_spots_layers = [\n            self.layout.layer(*mesh_spots_layer)\n            for mesh_spots_layer in mesh_spots_layers\n        ]\n        mesh_spots_regions = [\n            pya.Region(top_cell.begin_shapes_rec(_mesh_spots_layer))\n            for _mesh_spots_layer in _mesh_spots_layers\n        ]\n\n    # Compute the intersection to reduce sample size\n    marker_region_region_in_scene_region = (\n        marker_region_region &amp; scene_region\n    )\n    marker_region_in_scene_region = marker_region &amp; scene_region\n\n    # Iterate through all polygon patches in scene layer\n    all_scenes = []\n    file_path = None  # resets file_path each run to ensure the directory gets recreated and not skipped\n\n    for idx, scene in enumerate(scene_region.each()):\n        single_scene_reg = pya.Region(scene)\n        # Determine absolute centroid position of scene(s)\n        scene_pos = (\n            single_scene_reg.bbox().center().x / 1000,\n            single_scene_reg.bbox().center().y / 1000,\n            0,\n        )\n\n        # Prepare Scene with interface alignment\n        scene_npx = Scene(\n            position=scene_pos,\n            name=f\"scene_{scene_layer[0]}_{scene_layer[1]}_{idx}\",\n        )\n        interface_aligner_npx = (\n            InterfaceAligner()\n            if interface_aligner_node is None\n            else interface_aligner_node.deepcopy_node(copy_children=False)\n        )\n\n        # Return only scenes if all listed are None\n        if not _no_interfacealigner_if_all_None:\n            interface_aligner_npx.name = (\n                f\"ia_in_scene_{scene_layer[0]}_{scene_layer[1]}_{idx}\"\n            )\n            scene_npx.append_node(interface_aligner_npx)\n\n        # Pass alignment anchors and scan area sizes from polygons in interface alignment layer\n        # if any was specified\n        if interface_aligner_layer is not None:\n            ia_regions_in_single_scene = ia_region &amp; single_scene_reg\n            ia_anchor_pos_list = [\n                [\n                    ia_region_poly.bbox().center().x / 1000 - scene_pos[0],\n                    ia_region_poly.bbox().center().y / 1000 - scene_pos[1],\n                ]\n                for ia_region_poly in ia_regions_in_single_scene.each()\n            ]\n            ia_scan_area_sizes = [\n                [\n                    ia_region_poly.bbox().width() / 1000,\n                    ia_region_poly.bbox().height() / 1000,\n                ]\n                for ia_region_poly in ia_regions_in_single_scene.each()\n            ]\n            interface_aligner_npx.set_interface_anchors_at(\n                positions=ia_anchor_pos_list,\n                scan_area_sizes=ia_scan_area_sizes,\n            )\n            interface_aligner_npx.name = f\"ia_{interface_aligner_layer[0]}_{interface_aligner_layer[1]}_in_scene_{scene_layer[0]}_{scene_layer[1]}_{idx}\"\n\n        # Process all positions defined by mesh spots per layer if any were given\n        all_structures = []\n        if mesh_spots_layers is not None and meshes is not None:\n            colors = (\n                len(mesh_spots_layers) * [\"yellow\"]\n                if colors is None\n                else colors\n            )\n            for mesh_spots_region, mesh, preset, color, name in zip(\n                mesh_spots_regions,\n                meshes,\n                presets,\n                colors,\n                mesh_spots_layers,\n            ):\n                mesh_spots_in_single_scene_reg = (\n                    mesh_spots_region &amp; single_scene_reg\n                )\n                ms_pos_single_layer_positions = [\n                    [\n                        ms_region_poly.bbox().center().x / 1000\n                        - scene_pos[0],\n                        ms_region_poly.bbox().center().y / 1000\n                        - scene_pos[1],\n                        0 - scene_pos[2],\n                    ]\n                    for ms_region_poly in mesh_spots_in_single_scene_reg\n                ]\n\n                # Assign meshes to structures and append them to current scene\n                structures = [\n                    Structure(\n                        name=mesh.name + \"_in_\" + name,\n                        mesh=mesh,\n                        preset=preset,\n                        color=color,\n                        position=position,\n                        **structure_kwargs,\n                    )\n                    for position in ms_pos_single_layer_positions\n                ]\n                all_structures.extend(structures)\n        elif meshes is not None:\n            colors = len(meshes) * [\"red\"] if colors is None else colors\n            structures = [\n                Structure(\n                    mesh=mesh,\n                    preset=preset,\n                    color=color,\n                    name=mesh.name,\n                    **structure_kwargs,\n                )\n                for mesh, preset, color in zip(meshes, presets, colors)\n            ]\n            all_structures.extend(structures)\n\n        # Get marker_region parts within this specific single scene\n        marker_regions_in_single_scene = (\n            marker_region_region_in_scene_region &amp; single_scene_reg\n        )\n\n        if marker_region_layer is None:\n            marker_regions_in_single_scene.merge()\n\n        # Create list containing relative coordinates of markers in respective scene\n        marker_pos_list = [\n            [\n                marker_region_poly.bbox().center().x / 1000 - scene_pos[0],\n                marker_region_poly.bbox().center().y / 1000 - scene_pos[1],\n                marker_height,\n            ]\n            for marker_region_poly in marker_regions_in_single_scene.each()\n        ]\n\n        # Additional processing per patch\n        if not marker_regions_in_single_scene.is_empty():\n            # Collect shapes and convert to Shapely polygons\n            polygons_to_unify = []\n            shapely_polys = []\n\n            for marker_region in marker_regions_in_single_scene.each():\n                single_marker_reg = pya.Region(marker_region)\n                single_marker_reg_iter = pya.RecursiveShapeIterator(\n                    self.layout, top_cell, _marker_layer, single_marker_reg\n                )\n                polygons_to_unify = []\n                while not single_marker_reg_iter.at_end():\n                    marker_shape = single_marker_reg_iter.shape()\n                    marker_trans = single_marker_reg_iter.trans()\n\n                    if (\n                        marker_shape.is_polygon()\n                        or marker_shape.is_box()\n                        or marker_shape.is_path()\n                    ):\n                        klayout_poly = marker_shape.polygon.transformed(\n                            marker_trans\n                        )\n\n                        # Extract hull points\n                        hull_points = list(klayout_poly.each_point_hull())\n                        exterior = [(p.x, p.y) for p in hull_points]\n\n                        # Extract holes\n                        interiors = []\n                        for h in range(klayout_poly.holes()):\n                            hole_points = list(\n                                klayout_poly.each_point_hole(h)\n                            )\n                            interiors.append(\n                                [(p.x, p.y) for p in hole_points]\n                            )\n\n                        # Create Shapely polygon\n                        poly = Polygon(exterior, interiors)\n                        polygons_to_unify.append(poly)\n\n                    single_marker_reg_iter.next()\n\n                shapely_polys.append(MultiPolygon(polygons_to_unify))\n\n            img_dir = f\"./images_{self.gds_name}_scene_{scene_layer[0]}_{scene_layer[1]}\"\n            png_name = f\"marker_{marker_layer[0]}_{marker_layer[1]}.png\"\n            if file_path != os.path.join(img_dir, png_name):\n                file_path = os.path.join(img_dir, png_name)\n                os.makedirs(img_dir, exist_ok=True)\n                _, marker_orientations = (\n                    self._group_equivalent_polygons_and_output_image(\n                        shapely_polys, file_path=file_path\n                    )\n                )\n                assert len(marker_orientations) == len(marker_pos_list), (\n                    \"marker position count does not coincide with marker \"\n                    \"orientation count. Marker layer polygons are probably \"\n                    \"not grouped properly.\\n\"\n                    f\"len of marker_orientations : {len(marker_orientations)}\\n\"\n                    f\"len of marker_pos_list : {len(marker_pos_list)}\"\n                )\n\n                image_resource = (\n                    Image(file_path, png_name)\n                    if image_resource is None\n                    else image_resource\n                )\n                project.load_resources(image_resource)\n\n                marker_aligner_npx = (\n                    MarkerAligner(\n                        image_resource,\n                        marker_size=[\n                            single_marker_reg.bbox().width() / 1000,\n                            single_marker_reg.bbox().height() / 1000,\n                        ],\n                        max_outliers=len(marker_pos_list) - 3,\n                    )\n                    if marker_aligner_node is None\n                    else marker_aligner_node.deepcopy_node()\n                )\n                marker_aligner_npx.set_markers_at(\n                    marker_pos_list, marker_orientations\n                )\n\n            copied_marker_aligner_npx = marker_aligner_npx.deepcopy_node(\n                name=f\"marker_{marker_layer[0]}_{marker_layer[1]}_in_scene_{scene_layer[0]}_{scene_layer[1]}_{idx}\"\n            ).add_child(*all_structures)\n            scene_npx.append_node(copied_marker_aligner_npx)\n        all_scenes.append(scene_npx)\n\n    output_group = Group(f\"scene_layer_{scene_layer[0]}_{scene_layer[1]}\")\n    output_group.add_child(*all_scenes)\n    return output_group\n</code></pre>"},{"location":"gds/GDSParser/#npxpy.gds.GDSParser.marker_aligned_printing","title":"<code>marker_aligned_printing(project, presets, meshes, marker_height=0.33, marker_layer=(10, 10), mesh_spots_layers=[(100, 100)], cell_origin_offset=(0.0, 0.0), cell_name=None, image_resource=None, interface_aligner_node=None, marker_aligner_node=None, colors=None, marker_aligner_kwargs=None, structure_kwargs=None, _verbose=False)</code>","text":"<p>Create a hierarchical printing group with marker-based alignment.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>Parent Project for resource management</p> required <code>presets</code> <code>List[Preset]</code> <p>List of Preset configurations for printing</p> required <code>meshes</code> <code>List[Mesh]</code> <p>List of Mesh objects to print</p> required <code>marker_height</code> <code>float</code> <p>Z-height for marker structures</p> <code>0.33</code> <code>marker_layer</code> <code>Tuple[int, int]</code> <p>Layer/datatype for alignment markers</p> <code>(10, 10)</code> <code>mesh_spots_layers</code> <code>List[Tuple[int, int]]</code> <p>List of layers containing print locations</p> <code>[(100, 100)]</code> <code>cell_origin_offset</code> <code>Tuple[float, float]</code> <p>Coordinate offset for cell origin</p> <code>(0.0, 0.0)</code> <code>cell_name</code> <code>Optional[str]</code> <p>Cell to start traversing from (uses top cell if None)</p> <code>None</code> <code>image_resource</code> <code>Optional[Image]</code> <p>Pre-configured Image resource for markers</p> <code>None</code> <code>interface_aligner_node</code> <code>Optional[InterfaceAligner]</code> <p>InterfaceAligner configuration template</p> <code>None</code> <code>marker_aligner_node</code> <code>Optional[MarkerAligner]</code> <p>MarkerAligner configuration template</p> <code>None</code> <code>colors</code> <code>Optional[List[str]]</code> <p>Color codes for visualization</p> <code>None</code> <code>marker_aligner_kwargs</code> <code>Optional[Dict]</code> <p>Additional MarkerAligner parameters</p> <code>None</code> <code>structure_kwargs</code> <code>Optional[Dict]</code> <p>Additional Structure parameters</p> <code>None</code> <code>_verbose</code> <code>bool</code> <p>Enable debug output</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Group</code> <code>Group</code> <p>Hierarchical printing structure with alignment</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Invalid input dimensions, values, or formats</p> <code>TypeError</code> <p>Incorrect argument types</p> <code>RuntimeError</code> <p>Marker processing failure</p> Source code in <code>npxpy/gds.py</code> <pre><code>def marker_aligned_printing(\n    self,\n    project: Project,\n    presets: List[Preset],\n    meshes: List[Mesh],\n    marker_height: float = 0.33,\n    marker_layer: Tuple[int, int] = (10, 10),\n    mesh_spots_layers: List[Tuple[int, int]] = [(100, 100)],\n    cell_origin_offset: Tuple[float, float] = (0.0, 0.0),\n    cell_name: Optional[str] = None,\n    image_resource: Optional[Image] = None,\n    interface_aligner_node: Optional[InterfaceAligner] = None,\n    marker_aligner_node: Optional[MarkerAligner] = None,\n    colors: Optional[List[str]] = None,\n    marker_aligner_kwargs: Optional[Dict] = None,\n    structure_kwargs: Optional[Dict] = None,\n    _verbose: bool = False,\n) -&gt; Group:\n    \"\"\"Create a hierarchical printing group with marker-based alignment.\n\n    Args:\n        project: Parent Project for resource management\n        presets: List of Preset configurations for printing\n        meshes: List of Mesh objects to print\n        marker_height: Z-height for marker structures\n        marker_layer: Layer/datatype for alignment markers\n        mesh_spots_layers: List of layers containing print locations\n        cell_origin_offset: Coordinate offset for cell origin\n        cell_name: Cell to start traversing from (uses top cell if None)\n        image_resource: Pre-configured Image resource for markers\n        interface_aligner_node: InterfaceAligner configuration template\n        marker_aligner_node: MarkerAligner configuration template\n        colors: Color codes for visualization\n        marker_aligner_kwargs: Additional MarkerAligner parameters\n        structure_kwargs: Additional Structure parameters\n        _verbose: Enable debug output\n\n    Returns:\n        Group: Hierarchical printing structure with alignment\n\n    Raises:\n        ValueError: Invalid input dimensions, values, or formats\n        TypeError: Incorrect argument types\n        RuntimeError: Marker processing failure\n    \"\"\"\n    DeprecationWarning(\n        \"The method .marker_aligned_printing() is deprecated\"\n        \" and will be removed in a future release. Use the \"\n        \" method .get_scenes() instead.\"\n    )\n    # Initialize mutable defaults safely\n    marker_aligner_kwargs = marker_aligner_kwargs or {}\n    structure_kwargs = structure_kwargs or {}\n    colors = colors or [\"#16506B\"] * len(meshes)\n\n    # Comprehensive type validation\n    if not isinstance(project, Project):\n        raise TypeError(\"project must be a Project instance\")\n    if not isinstance(presets, list):\n        raise TypeError(\"presets must be a list\")\n    if not isinstance(meshes, list):\n        raise TypeError(\"meshes must be a list\")\n    if not isinstance(mesh_spots_layers, list):\n        raise TypeError(\"mesh_spots_layers must be a list\")\n\n    # Validate numerical parameters\n    if not isinstance(marker_height, (int, float)):\n        raise TypeError(\"marker_height must be numeric\")\n    if (\n        not isinstance(cell_origin_offset, tuple)\n        or len(cell_origin_offset) != 2\n    ):\n        raise TypeError(\"cell_origin_offset must be a 2-element tuple\")\n    if not all(isinstance(x, (int, float)) for x in cell_origin_offset):\n        raise TypeError(\"cell_origin_offset elements must be numeric\")\n\n    # Validate layer specifications\n    layer_valid = (\n        lambda l: isinstance(l, tuple)\n        and len(l) == 2\n        and all(isinstance(n, int) for n in l)\n    )\n    if not layer_valid(marker_layer):\n        raise TypeError(\"marker_layer must be a (int, int) tuple\")\n    if not all(layer_valid(l) for l in mesh_spots_layers):\n        raise TypeError(\n            \"All mesh_spots_layers elements must be (int, int) tuples\"\n        )\n\n    # Validate list contents\n    for i, preset in enumerate(presets):\n        if not isinstance(preset, Preset):\n            raise TypeError(f\"presets[{i}] must be a Preset instance\")\n    for i, mesh in enumerate(meshes):\n        if not isinstance(mesh, Mesh):\n            raise TypeError(f\"meshes[{i}] must be a Mesh instance\")\n\n    # Validate optional parameters\n    if cell_name is not None and not isinstance(cell_name, str):\n        raise TypeError(\"cell_name must be a string or None\")\n    if image_resource is not None and not isinstance(\n        image_resource, Image\n    ):\n        raise TypeError(\"image_resource must be an Image instance or None\")\n    if interface_aligner_node is not None and not isinstance(\n        interface_aligner_node, InterfaceAligner\n    ):\n        raise TypeError(\n            \"interface_aligner_node must be an InterfaceAligner instance or None\"\n        )\n    if marker_aligner_node is not None and not isinstance(\n        marker_aligner_node, MarkerAligner\n    ):\n        raise TypeError(\n            \"marker_aligner_node must be a MarkerAligner instance or None\"\n        )\n\n    # Validate dictionary parameters\n    if not isinstance(marker_aligner_kwargs, dict):\n        raise TypeError(\"marker_aligner_kwargs must be a dictionary\")\n    if not isinstance(structure_kwargs, dict):\n        raise TypeError(\"structure_kwargs must be a dictionary\")\n    if not isinstance(_verbose, bool):\n        raise TypeError(\"_verbose must be a boolean\")\n\n    # Validate dimensional consistency\n    if (\n        len(presets) != len(meshes)\n        or len(presets) != len(mesh_spots_layers)\n        or len(presets) != len(colors)\n    ):\n        raise ValueError(\"All input lists must have equal length\")\n    if not presets:\n        raise ValueError(\"At least one preset must be provided\")\n\n    marker_aligned_printing_group_raw = self._marker_aligned_printing(\n        project,\n        presets,\n        meshes,\n        cell_name=cell_name,\n        cell_origin_offset=cell_origin_offset,\n        image_resource=image_resource,\n        interface_aligner_node=interface_aligner_node,\n        marker_aligner_node=marker_aligner_node,\n        marker_height=marker_height,\n        marker_layer=marker_layer,\n        mesh_spots_layers=mesh_spots_layers,\n        colors=colors,\n        marker_aligner_kwargs=marker_aligner_kwargs,\n        structure_kwargs=structure_kwargs,\n        _verbose=_verbose,\n    )\n\n    # Clean up nodes that do not contain any structures\n    marker_aligned_printing_group = (\n        marker_aligned_printing_group_raw.deepcopy_node(\n            copy_children=False\n        )\n    )\n    for node in marker_aligned_printing_group_raw.children_nodes:\n        for node_descendant in node.all_descendants:\n            if node_descendant._type == \"structure\":\n                marker_aligned_printing_group.add_child(node)\n                break\n    return marker_aligned_printing_group.translate(\n        [-cell_origin_offset[0], -cell_origin_offset[1], 0]\n    )\n</code></pre>"},{"location":"howtocite/howtocite/","title":"How to Cite","text":"<p>If npxpy contributes to your research, software, or project, we kindly request that you cite it in your publications using the provided DOI above.</p>"},{"location":"nodes/Node/","title":"npxpy.nodes.node.Node","text":"<p>A class to represent a node object of nanoPrintX with various attributes and methods for managing node hierarchy.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>Type of the node.</p> <code>name</code> <code>str</code> <p>Name of the node.</p> <code>position</code> <code>List[float]</code> <p>Position of the node [x, y, z].</p> <code>rotation</code> <code>List[float]</code> <p>Rotation of the node [psi, theta, phi].</p> <code>children</code> <code>List[str]</code> <p>List of children node IDs.</p> <code>children_nodes</code> <code>List[Node]</code> <p>List of children nodes.</p> <code>properties</code> <code>Any</code> <p>Properties of the node.</p> <code>geometry</code> <code>Any</code> <p>Geometry of the node.</p> <code>unique_attributes</code> <code>Dict[str, Any]</code> <p>Additional dynamic attributes.</p> Source code in <code>npxpy/nodes/node.py</code> <pre><code>class Node:\n    \"\"\"\n    A class to represent a node object of nanoPrintX with various attributes\n    and methods for managing node hierarchy.\n\n    Attributes:\n        type (str): Type of the node.\n        name (str): Name of the node.\n        position (List[float]): Position of the node [x, y, z].\n        rotation (List[float]): Rotation of the node [psi, theta, phi].\n        children (List[str]): List of children node IDs.\n        children_nodes (List[Node]): List of children nodes.\n        properties (Any): Properties of the node.\n        geometry (Any): Geometry of the node.\n        unique_attributes (Dict[str, Any]): Additional dynamic attributes.\n    \"\"\"\n\n    def __init__(\n        self,\n        node_type: str,\n        name: str,\n        position: List[float] = [0.0, 0.0, 0.0],\n        rotation: List[float] = [0.0, 0.0, 0.0],\n    ):\n        \"\"\"\n        Initialize a Node instance with the specified parameters.\n\n        Parameters:\n            node_type (str): Type of the node.\n            name (str): Name of the node.\n            properties (Any, optional): Properties of the node. Defaults to None.\n            geometry (Any, optional): Geometry of the node. Defaults to None.\n            **kwargs (Any): Additional dynamic attributes.\n        \"\"\"\n\n        self.id = str(uuid.uuid4())\n        self._type = node_type\n        self.name = name\n        self.position = position\n        self.rotation = rotation\n        self.properties = {}\n        self.geometry = {}\n\n        self.children: List[str] = []\n        self.children_nodes: List[Node] = []\n        self.all_descendants: List[Node] = self._generate_all_descendants()\n\n        self.parent_node: List[Node] = []\n        self.all_ancestors: List[Node] = []\n\n    @property\n    def name(self):\n        \"\"\"Return the name of the node.\"\"\"\n        return self._name\n\n    @property\n    def node_type(self):\n        \"\"\"Return the type of the node.\"\"\"\n        return self._type\n\n    @name.setter\n    def name(self, value: str):\n        value = str(value)\n        \"\"\"Set the name of the node with validation to ensure it is a non-empty string.\"\"\"\n        if not isinstance(value, str) or not value.strip():\n            raise ValueError(\"name must be a non-empty string.\")\n        self._name = value\n\n    @property\n    def _visibility_in_plotter_disabled(self):\n        return self.__visibility_in_plotter_disabled\n\n    @_visibility_in_plotter_disabled.setter\n    def _visibility_in_plotter_disabled(self, value):\n        # Check if value is already an iterable (but not a string!)\n        # If it's not an iterable (or is just a single string), wrap it in a list.\n        if isinstance(value, str) or not hasattr(value, \"__iter__\"):\n            value = [value]\n\n        # Optionally convert it to a list if it's, say, a tuple or another iterable\n        self.__visibility_in_plotter_disabled = list(value)\n\n    def add_child(self, *child_nodes: \"Node\"):\n        \"\"\"\n        Add child node(s) to the current node.\n\n        Parameters:\n            child_node (Node): The child node(s) to add.\n        \"\"\"\n        for child_node in child_nodes:\n            if not all(\n                hasattr(child_node, attr)\n                for attr in [\"_type\", \"all_descendants\", \"all_ancestors\"]\n            ):\n                raise TypeError(\n                    \"Only instances of nodes can be added as children to nodes!\"\n                )\n            elif self._type == \"structure\":\n                raise ValueError(\n                    \"Structure, Text and Lens are terminal nodes! They cannot have children!\"\n                )\n            elif child_node._type == \"project\":\n                raise ValueError(\n                    \"A project node can never be a child to any node!\"\n                )\n            elif child_node._type == \"scene\":\n                if self._has_ancestor_of_type(\"scene\"):\n                    raise ValueError(\"Nested scenes are not allowed!\")\n            elif self in child_node.all_descendants:\n                raise ValueError(\n                    \"This node cannot be added since it is a ancestor to the current node!\"\n                )\n\n            child_node.parent_node.append(self)\n            self.children_nodes.append(child_node)\n            # Update descendants list of parent\n\n            self.all_descendants += [child_node] + child_node.all_descendants\n\n            for child in [child_node] + child_node.all_descendants:\n                child.all_ancestors = (\n                    child._generate_all_ancestors()\n                )  # Update ancestors list (_generate_all_ancestors() inexpensive and easy!)\n\n            for (\n                ancestor\n            ) in (\n                self.all_ancestors\n            ):  # Update descendants for the parent's ancestors\n                ancestor.all_descendants += [\n                    child_node\n                ] + child_node.all_descendants\n\n        return self\n\n    def _has_ancestor_of_type(self, node_type: str) -&gt; bool:\n        \"\"\"\n        Check if the current node has an ancestor of the specified type.\n\n        Parameters:\n            node_type (str): The type of the ancestor node to check for.\n\n        Returns:\n            bool: True if an ancestor of the specified type exists, False otherwise.\n        \"\"\"\n        current_node = self\n        while current_node:\n            if current_node._type == node_type:\n                return True\n            current_node = getattr(\n                current_node, \"parent\", None\n            )  # Assumes a parent attribute is set for each node\n        return False\n\n    def tree(\n        self,\n        level: int = 0,\n        show_type: bool = True,\n        show_id: bool = False,\n        is_last: bool = True,\n        prefix: str = \"\",\n    ):\n        \"\"\"\n        Print the tree structure of the node and its descendants.\n\n        Parameters:\n            level (int, optional): The current level in the tree. Defaults to 0.\n            show_type (bool, optional): Whether to show the node type. Defaults to True.\n            show_id (bool, optional): Whether to show the node ID. Defaults to False.\n            is_last (bool, optional): Whether the node is the last child. Defaults to True.\n            prefix (str, optional): The prefix for the current level. Defaults to ''.\n        \"\"\"\n        indent = (\n            \"\" if level == 0 else prefix + (\"\u2514\" if is_last else \"\u251c\") + \"\u2500\u2500\"\n        )\n        output = (\n            f\"{indent}{self.name} ({self._type})\"\n            if show_type\n            else f\"{indent}{self.name}\"\n        )\n        if show_id:\n            output += f\" (ID: {self.id})\"\n        print(output)\n        new_prefix = prefix + (\"    \" if is_last else \"\u2502   \")\n        child_count = len(self.children_nodes)\n        for index, child in enumerate(self.children_nodes):\n            child.tree(\n                level + 1,\n                show_type,\n                show_id,\n                is_last=(index == child_count - 1),\n                prefix=new_prefix,\n            )\n\n    def deepcopy_node(self, copy_children: bool = True, name: Optional[str] = None) -&gt; Self:\n        \"\"\"\n        Create a deep copy of the node.\n\n        Parameters:\n            copy_children (bool, optional): Whether to copy children nodes. Defaults to True.\n            name (str, optional): New name for the copied node. Defaults to None.\n\n        Returns:\n            Node: A deep copy of the current node.\n        \"\"\"\n\n        copied_node = copy.deepcopy(self)\n        copied_node.id = str(uuid.uuid4())\n        copied_node.children_nodes = []\n        copied_node.all_descendants = []\n        copied_node.parent_node = []\n        copied_node.all_ancestors = []\n\n        if copy_children:\n            copied_children = [\n                child.deepcopy_node() for child in self.children_nodes\n            ]\n            copied_node.add_child(*copied_children)\n\n        if name is not None:\n            copied_node.name = name\n        return copied_node\n\n    def _reset_ids(self, node: \"Node\"):\n        \"\"\"\n        Reset the IDs of the node and its descendants.\n\n        Parameters:\n            node (Node): The node to reset IDs for.\n        \"\"\"\n        node.id = str(uuid.uuid4())\n        for child in node.children_nodes:\n            self._reset_ids(child)\n\n    def grab_node(self, *node_types_with_indices: Tuple[str, int]) -&gt; \"Node\":\n        \"\"\"\n        Grab nodes based on the specified types and indices.\n\n        Parameters:\n            node_types_with_indices (Tuple[str, int]):\n            Tuples of arbitrary amount containing node type and index.\n\n        Returns:\n            Node: The node found based on the specified types and indices.\n        \"\"\"\n        current_level_nodes = [self]\n        for node_type, index in node_types_with_indices:\n            next_level_nodes = []\n            for node in current_level_nodes:\n                filtered_nodes = [\n                    child\n                    for child in node.children_nodes\n                    if child._type == node_type\n                ]\n                if len(filtered_nodes) &gt; index:\n                    next_level_nodes.append(filtered_nodes[index])\n            current_level_nodes = next_level_nodes\n        return current_level_nodes[0]\n\n    def _generate_all_descendants(self) -&gt; List[\"Node\"]:\n        \"\"\"\n        Generate a list of all descendant nodes.\n\n        Returns:\n            List[Node]: List of all descendant nodes.\n        \"\"\"\n        descendants = []\n        nodes_to_check = [self]\n        while nodes_to_check:\n            current_node = nodes_to_check.pop()\n            descendants.extend(current_node.children_nodes)\n            nodes_to_check.extend(current_node.children_nodes)\n        return descendants\n\n    def _generate_all_ancestors(self) -&gt; List[\"Node\"]:\n        \"\"\"\n        Generate a list of all ancestor nodes.\n\n        Returns:\n            List[Node]: List of all descendant nodes.\n        \"\"\"\n        ancestors = []\n        nodes_to_check = [self]\n        while nodes_to_check:\n            current_node = nodes_to_check.pop()\n            ancestors.extend(current_node.parent_node)\n            nodes_to_check.extend(current_node.parent_node)\n        return ancestors\n\n    def grab_all_nodes_bfs(self, node_type: str) -&gt; List[\"Node\"]:\n        \"\"\"\n        Grab all nodes of the specified type using breadth-first search.\n\n        Parameters:\n            node_type (str): The type of nodes to grab.\n\n        Returns:\n            List[Node]: List of nodes of the specified type.\n        \"\"\"\n        result = []\n        nodes_to_check = [self]\n        while nodes_to_check:\n            current_node = nodes_to_check.pop(0)  # Dequeue from the front\n            if current_node._type == node_type:\n                result.append(current_node)\n            nodes_to_check.extend(\n                current_node.children_nodes\n            )  # Enqueue children\n        return result\n\n    def append_node(self, *nodes_to_append: \"Node\"):\n        \"\"\"\n        Append a node to the deepest descendant on the highest branch.\n\n        Parameters:\n            node_to_append (Node): The node to append.\n        \"\"\"\n        for node_to_append in nodes_to_append:\n            grandest_grandchild = self._find_grandest_grandchild(self)\n            grandest_grandchild.add_child(node_to_append)\n        return self\n\n    def _find_grandest_grandchild(self, current_node: \"Node\") -&gt; \"Node\":\n        \"\"\"\n        Find the deepest descendant node.\n\n        Parameters:\n            current_node (Node): The current node to start the search from.\n\n        Returns:\n            Node: The deepest descendant node.\n        \"\"\"\n        if not current_node.children_nodes:\n            return current_node\n        else:\n            grandest_children = [\n                self._find_grandest_grandchild(child)\n                for child in current_node.children_nodes\n            ]\n            return max(grandest_children, key=lambda node: self._depth(node))\n\n    def _depth(self, node: \"Node\") -&gt; int:\n        \"\"\"\n        Calculate the depth of a node.\n\n        Parameters:\n            node (Node): The node to calculate the depth for.\n\n        Returns:\n            int: The depth of the node.\n        \"\"\"\n        depth = 0\n        current = node\n        while current.children_nodes:\n            current = current.children_nodes[0]\n            depth += 1\n        return depth\n\n    def _lazy_import_wrapper(self):\n        from . import _viewport_helpers\n\n        return _viewport_helpers._lazy_import()\n\n    def viewport(\n        self,\n        title: Optional[str] = None,\n        disable: Optional[Union[str, List[str]]] = None,\n        include_ancestor_transforms: Optional[bool] = True,\n    ):\n        \"\"\"\n        Opens a PyVista viewport visualizing the attached objects in this node.\n        Notes\n        -----\n        - Does not visualize multiplications caused by Arrays yet.\n        - Lenses might not be displayed accurately in the viewport visualization.\n          However, this does not affect the final printed output.\n        - Supports multiple node types such as `scene`, `structure`, `coarse_alignment`,\n          `interface_alignment`, `fiber_core_alignment`, `marker_alignment`, `edge_alignment`,\n          and `dose_compensation`.\n\n        Parameters\n        ----------\n        title : str, optional\n            Title to display in the PyVista window. Defaults to the name of the calling node.\n        disable : str or list of str, optional\n            One or more group names to disable visibility for. These groups will not be visible\n            in the viewport. For example, `\"scene\"` or `[\"scene\", \"coarse_alignment\"]`.\n        include_ancestor_transforms : bool, optional\n            Whether to apply transformations (position and rotation) from ancestor nodes to the\n            visualized objects. Defaults to `True`.\n\n        Returns\n        -------\n        _GroupedPlotter\n            A customized plotter instance after rendering all meshes, including any\n            transformations or visibility settings applied.\n\n        Examples\n        --------\n        ```python\n        &gt;&gt;&gt; # Basic usage without disabling any groups\n        &gt;&gt;&gt; node.viewport()\n\n        &gt;&gt;&gt; # Disable visibility for \"scene\" and \"coarse_alignment\" groups\n        &gt;&gt;&gt; node.viewport(disable=[\"scene\", \"coarse_alignment\"])\n\n        &gt;&gt;&gt; # Exclude transformations from ancestor nodes\n        &gt;&gt;&gt; node.viewport(include_ancestor_transforms=False)\n        ```\n        \"\"\"\n        _GroupedPlotter, _apply_transforms, _meshbuilder, blocks = (\n            self._lazy_import_wrapper()\n        )\n\n        block_dicts_list = []\n\n        if disable is None:\n            disable = []\n        if title is None:\n            title = self.name\n        # Create the plotter\n        plotter = _GroupedPlotter(\n            title=f\"npxpy - Project Viewport ({title})\",\n            update_app_icon=False,\n        )\n\n        # Grid, axes, background\n        plotter.show_grid(\n            grid=\"back\",\n            location=\"outer\",\n            color=\"gray\",\n            xtitle=\"x\",\n            ytitle=\"y\",\n            ztitle=\"z\",\n            show_zlabels=True,\n            padding=0.1,\n            font_size=8,\n        )\n        plotter.show_axes()\n        plotter.view_isometric()\n        plotter.set_background(\"white\")\n\n        # Add logo widget\n        logo_path = str(files(\"npxpy.images\").joinpath(\"logo.png\"))\n        plotter.add_logo_widget(\n            logo=logo_path,\n            opacity=0.75,\n            size=(0.15, 0.15),\n            position=(0.84, 0.86),\n        )\n        # init the meshbuilder\n        meshbuilder = _meshbuilder()\n\n        for node in [self] + self.all_descendants:\n            all_rotations = [\n                getattr(ancestor, \"rotation\", [0, 0, 0])\n                for ancestor in node.all_ancestors\n            ]\n            all_rotations.reverse()\n\n            all_positions = [\n                getattr(ancestor, \"position\", [0, 0, 0])\n                for ancestor in node.all_ancestors\n            ]\n            all_positions.reverse()\n\n            # If False, only go as far as node calling viewport()\n            if not include_ancestor_transforms:\n                if node != self:\n                    dummy = node.all_ancestors.copy()\n                    dummy.reverse()\n                    start = dummy.index(self)\n                    all_positions = all_positions[start:]\n                    all_rotations = all_rotations[start:]\n                else:\n                    all_positions = [[0, 0, 0]]\n                    all_rotations = [[0, 0, 0]]\n\n            if node._type == \"scene\":\n                scene = node\n                # Create the circle representing the scene\n                if len(scene.all_ancestors) != 0 and hasattr(\n                    scene.all_ancestors[-1], \"objective\"\n                ):\n                    ronin_node = False\n                    objective = scene.all_ancestors[-1].objective\n                else:\n                    print(\n                        (\n                            f\"{self.name} not attached to any project node.\\n\"\n                            \"Objective is thus assumed to be x63.\"\n                        )\n                    )\n                    ronin_node = True\n                    objective = \"\"  # dummy. wont do anything in this case\n\n                scene_mesh, scene_mesh_dict = _meshbuilder.scene_mesh(\n                    objective, ronin_node\n                )\n                # apply first all_ancestors' rots\n\n                _apply_transforms(\n                    scene_mesh,\n                    all_positions=all_positions + [scene.position],\n                    all_rotations=all_rotations + [scene.rotation],\n                )\n\n                # Add to plotter as 'scene' group\n                plotter.add_mesh(scene_mesh, **scene_mesh_dict)\n                # blocks.append(scene_mesh)\n                # block_dicts_list.append(scene_mesh_dict)\n            # Structure\n            if node._type == \"structure\" and node._mesh:\n                structure = node\n                loaded_mesh = _meshbuilder.load_mesh(structure.mesh.file_path)\n                # apply initial mesh transformation\n                _apply_transforms(\n                    mesh=loaded_mesh,\n                    all_positions=[structure.mesh.translation],\n                    all_rotations=[structure.mesh.rotation],\n                )\n\n                # apply all_ancestors' rots and afterwards structure rotation\n                _apply_transforms(\n                    mesh=loaded_mesh,\n                    all_rotations=all_rotations + [structure.rotation],\n                    all_positions=all_positions + [structure.position],\n                )\n\n                # Add to plotter\n                plotter.add_mesh(\n                    loaded_mesh, color=structure.color, group=structure._type\n                )\n                # blocks.append(loaded_mesh)\n                # block_dicts_list.append(\n                #    {\"color\": structure.color, \"group\": structure._type}\n                # )\n            # Text (structure)\n            if node._type == \"structure\" and hasattr(node, \"font_size\"):\n                text_node = node\n                text_mesh, text_mesh_dict = _meshbuilder.txt_mesh(text_node)\n                # apply all_ancestors' rots and afterwards structure rotation\n                _apply_transforms(\n                    mesh=text_mesh,\n                    all_rotations=all_rotations + [text_node.rotation],\n                    all_positions=all_positions + [text_node.position],\n                )\n\n                plotter.add_mesh(text_mesh, **text_mesh_dict)\n                # blocks.append(text_mesh)\n                # block_dicts_list.append(text_mesh_dict)\n            # Lens (structure)\n            elif (\n                node._type == \"structure\"\n                and not node._mesh\n                and not hasattr(node, \"font_size\")\n            ):\n                lens = node\n                geometry = lens.to_dict()[\"geometry\"]\n                del (\n                    geometry[\"type\"],\n                    geometry[\"nr_radial_segments\"],\n                    geometry[\"nr_phi_segments\"],\n                )\n                lens_mesh = meshbuilder.lens_mesh(**geometry)\n\n                _apply_transforms(\n                    mesh=lens_mesh,\n                    all_rotations=all_rotations + [lens.rotation],\n                    all_positions=all_positions + [lens.position],\n                )\n\n                lens_mesh_dict = {\n                    \"color\": lens.color,\n                    \"group\": \"structure_lens\",\n                }\n                plotter.add_mesh(lens_mesh, **lens_mesh_dict)\n                # blocks.append(lens_mesh)\n                # block_dicts_list.append(lens_mesh_dict)\n            # Coarse aligners\n            if node._type == \"coarse_alignment\":\n                coarse_aligner = node\n                coarse_anchor_mesh, coarse_anchor_mesh_dict = (\n                    _meshbuilder.ca_mesh(coarse_aligner)\n                )\n                # for coarse_anchor_mesh in coarse_anchor_meshes:\n                # apply all_ancestors' rots and afterwards mesh rotation\n                _apply_transforms(\n                    mesh=coarse_anchor_mesh,\n                    all_rotations=all_rotations,\n                    all_positions=all_positions,\n                )\n\n                plotter.add_mesh(coarse_anchor_mesh, **coarse_anchor_mesh_dict)\n                # blocks.append(coarse_anchor_mesh)\n                # block_dicts_list.append(coarse_anchor_mesh_dict)\n            # interface aligners\n            if node._type == \"interface_alignment\":\n                interface_aligner = node\n\n                ia_mesh, ia_mesh_dict = meshbuilder.ia_mesh(\n                    interface_aligner_node=interface_aligner\n                )\n\n                _apply_transforms(\n                    mesh=ia_mesh,\n                    all_rotations=all_rotations,\n                    all_positions=all_positions,\n                )\n\n                plotter.add_mesh(ia_mesh, **ia_mesh_dict)\n                # blocks.append(ia_mesh)\n                # block_dicts_list.append(ia_mesh_dict)\n            # fiber aligners\n            if node._type == \"fiber_core_alignment\":\n                fiber_aligner = node\n                fa_mesh, fa_mesh_dict = meshbuilder.fa_mesh(fiber_aligner)\n\n                _apply_transforms(\n                    mesh=fa_mesh,\n                    all_rotations=all_rotations,\n                    all_positions=all_positions,\n                )\n\n                plotter.add_mesh(fa_mesh, **fa_mesh_dict)\n                # blocks.append(fa_mesh)\n                # block_dicts_list.append(fa_mesh_dict)\n            # Marker aligners\n            if node._type == \"marker_alignment\":\n                marker_aligner = node\n                ma_meshes, ma_label_meshes, ma_mesh_dict, ma_label_dict = (\n                    _meshbuilder.ma_mesh(marker_aligner)\n                )\n\n                for ma_mesh, ma_label_mesh in zip(ma_meshes, ma_label_meshes):\n\n                    # apply all_ancestors' rots\n                    _apply_transforms(\n                        mesh=ma_mesh,\n                        all_rotations=all_rotations,\n                        all_positions=all_positions,\n                    )\n                    # apply all_ancestors' rots\n                    _apply_transforms(\n                        mesh=ma_label_mesh,\n                        all_rotations=all_rotations,\n                        all_positions=all_positions,\n                    )\n\n                    plotter.add_mesh(ma_mesh, **ma_mesh_dict)\n                    # blocks.append(ma_mesh)\n                    # block_dicts_list.append(ma_mesh_dict)\n                    plotter.add_mesh(ma_label_mesh, **ma_label_dict)\n                    # blocks.append(ma_label_mesh)\n                    # block_dicts_list.append(ma_label_dict)\n\n            #  Edge aligners\n            if node._type == \"edge_alignment\":\n                edge_aligner = node\n                edge_aligner_meshes, edge_aligner_meshes_dicts = (\n                    _meshbuilder.ea_mesh(edge_aligner)\n                )\n\n                for mesh, mesh_dict in zip(\n                    edge_aligner_meshes, edge_aligner_meshes_dicts\n                ):\n\n                    _apply_transforms(\n                        mesh,\n                        all_positions=[edge_aligner.edge_location + [0]],\n                        all_rotations=[\n                            [0, 0, edge_aligner.edge_orientation]\n                        ],  # (in-plane rotation only)\n                    )\n\n                    # apply all_ancestors' rots\n                    _apply_transforms(\n                        mesh,\n                        all_rotations=all_rotations,\n                        all_positions=all_positions,\n                    )\n\n                    plotter.add_mesh(mesh, **mesh_dict)\n                    # blocks.append(mesh)\n                    # block_dicts_list.append(mesh_dict)\n            # Dose compensation\n            if node._type == \"dose_compensation\":\n                dose_compensation = node\n\n                for mesh, kwargs in _meshbuilder.dc_meshes(\n                    dose_compensation.domain_size\n                ):\n                    _apply_transforms(\n                        mesh=mesh,\n                        all_rotations=all_rotations\n                        + [[0, 0, dose_compensation.edge_orientation]],\n                        all_positions=all_positions\n                        + [dose_compensation.edge_location],\n                    )\n\n                    plotter.add_mesh(mesh, **kwargs)\n                    # blocks.append(mesh)\n                    # block_dicts_list.append(kwargs)\n            # Capture\n            if node._type == \"capture\":\n                capture = node\n\n                capt_mesh, capt_mesh_dict = _meshbuilder.capture_mesh(capture)\n\n                _apply_transforms(\n                    mesh=capt_mesh,\n                    all_rotations=all_rotations,\n                    all_positions=all_positions,\n                )\n\n                plotter.add_mesh(capt_mesh, **capt_mesh_dict)\n                # blocks.append(capt_mesh)\n                # block_dicts_list.append(capt_mesh_dict)\n\n        actor, mapper = plotter.add_composite(blocks)\n        for idx, block_dict in enumerate(block_dicts_list, start=1):\n            for key, value in block_dict.items():\n                setattr(mapper.block_attr[idx], key, value)\n\n        # Disable visibility for certain groups if requested\n        self._visibility_in_plotter_disabled = disable\n        for grp in self._visibility_in_plotter_disabled:\n            plotter.disable(grp)\n\n        plotter._add_custom_axes()\n        # Show the viewport\n        plotter.show()\n\n        return plotter\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Convert the node and its attributes to a dictionary format.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of the node.\n        \"\"\"\n        self.children = [i.id for i in self.children_nodes]\n        node_dict = {\n            \"type\": self._type,\n            \"id\": self.id,\n            \"name\": self.name,\n            \"position\": self.position,\n            \"rotation\": self.rotation,\n            \"children\": self.children,\n            \"properties\": self.properties,\n            # \"geometry\": self.geometry,\n        }\n\n        return node_dict\n</code></pre>"},{"location":"nodes/Node/#npxpy.nodes.node.Node.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":"<p>Return the name of the node.</p>"},{"location":"nodes/Node/#npxpy.nodes.node.Node.node_type","title":"<code>node_type</code>  <code>property</code>","text":"<p>Return the type of the node.</p>"},{"location":"nodes/Node/#npxpy.nodes.node.Node.__init__","title":"<code>__init__(node_type, name, position=[0.0, 0.0, 0.0], rotation=[0.0, 0.0, 0.0])</code>","text":"<p>Initialize a Node instance with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>node_type</code> <code>str</code> <p>Type of the node.</p> required <code>name</code> <code>str</code> <p>Name of the node.</p> required <code>properties</code> <code>Any</code> <p>Properties of the node. Defaults to None.</p> required <code>geometry</code> <code>Any</code> <p>Geometry of the node. Defaults to None.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional dynamic attributes.</p> required Source code in <code>npxpy/nodes/node.py</code> <pre><code>def __init__(\n    self,\n    node_type: str,\n    name: str,\n    position: List[float] = [0.0, 0.0, 0.0],\n    rotation: List[float] = [0.0, 0.0, 0.0],\n):\n    \"\"\"\n    Initialize a Node instance with the specified parameters.\n\n    Parameters:\n        node_type (str): Type of the node.\n        name (str): Name of the node.\n        properties (Any, optional): Properties of the node. Defaults to None.\n        geometry (Any, optional): Geometry of the node. Defaults to None.\n        **kwargs (Any): Additional dynamic attributes.\n    \"\"\"\n\n    self.id = str(uuid.uuid4())\n    self._type = node_type\n    self.name = name\n    self.position = position\n    self.rotation = rotation\n    self.properties = {}\n    self.geometry = {}\n\n    self.children: List[str] = []\n    self.children_nodes: List[Node] = []\n    self.all_descendants: List[Node] = self._generate_all_descendants()\n\n    self.parent_node: List[Node] = []\n    self.all_ancestors: List[Node] = []\n</code></pre>"},{"location":"nodes/Node/#npxpy.nodes.node.Node.add_child","title":"<code>add_child(*child_nodes)</code>","text":"<p>Add child node(s) to the current node.</p> <p>Parameters:</p> Name Type Description Default <code>child_node</code> <code>Node</code> <p>The child node(s) to add.</p> required Source code in <code>npxpy/nodes/node.py</code> <pre><code>def add_child(self, *child_nodes: \"Node\"):\n    \"\"\"\n    Add child node(s) to the current node.\n\n    Parameters:\n        child_node (Node): The child node(s) to add.\n    \"\"\"\n    for child_node in child_nodes:\n        if not all(\n            hasattr(child_node, attr)\n            for attr in [\"_type\", \"all_descendants\", \"all_ancestors\"]\n        ):\n            raise TypeError(\n                \"Only instances of nodes can be added as children to nodes!\"\n            )\n        elif self._type == \"structure\":\n            raise ValueError(\n                \"Structure, Text and Lens are terminal nodes! They cannot have children!\"\n            )\n        elif child_node._type == \"project\":\n            raise ValueError(\n                \"A project node can never be a child to any node!\"\n            )\n        elif child_node._type == \"scene\":\n            if self._has_ancestor_of_type(\"scene\"):\n                raise ValueError(\"Nested scenes are not allowed!\")\n        elif self in child_node.all_descendants:\n            raise ValueError(\n                \"This node cannot be added since it is a ancestor to the current node!\"\n            )\n\n        child_node.parent_node.append(self)\n        self.children_nodes.append(child_node)\n        # Update descendants list of parent\n\n        self.all_descendants += [child_node] + child_node.all_descendants\n\n        for child in [child_node] + child_node.all_descendants:\n            child.all_ancestors = (\n                child._generate_all_ancestors()\n            )  # Update ancestors list (_generate_all_ancestors() inexpensive and easy!)\n\n        for (\n            ancestor\n        ) in (\n            self.all_ancestors\n        ):  # Update descendants for the parent's ancestors\n            ancestor.all_descendants += [\n                child_node\n            ] + child_node.all_descendants\n\n    return self\n</code></pre>"},{"location":"nodes/Node/#npxpy.nodes.node.Node.append_node","title":"<code>append_node(*nodes_to_append)</code>","text":"<p>Append a node to the deepest descendant on the highest branch.</p> <p>Parameters:</p> Name Type Description Default <code>node_to_append</code> <code>Node</code> <p>The node to append.</p> required Source code in <code>npxpy/nodes/node.py</code> <pre><code>def append_node(self, *nodes_to_append: \"Node\"):\n    \"\"\"\n    Append a node to the deepest descendant on the highest branch.\n\n    Parameters:\n        node_to_append (Node): The node to append.\n    \"\"\"\n    for node_to_append in nodes_to_append:\n        grandest_grandchild = self._find_grandest_grandchild(self)\n        grandest_grandchild.add_child(node_to_append)\n    return self\n</code></pre>"},{"location":"nodes/Node/#npxpy.nodes.node.Node.deepcopy_node","title":"<code>deepcopy_node(copy_children=True, name=None)</code>","text":"<p>Create a deep copy of the node.</p> <p>Parameters:</p> Name Type Description Default <code>copy_children</code> <code>bool</code> <p>Whether to copy children nodes. Defaults to True.</p> <code>True</code> <code>name</code> <code>str</code> <p>New name for the copied node. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Node</code> <code>Self</code> <p>A deep copy of the current node.</p> Source code in <code>npxpy/nodes/node.py</code> <pre><code>def deepcopy_node(self, copy_children: bool = True, name: Optional[str] = None) -&gt; Self:\n    \"\"\"\n    Create a deep copy of the node.\n\n    Parameters:\n        copy_children (bool, optional): Whether to copy children nodes. Defaults to True.\n        name (str, optional): New name for the copied node. Defaults to None.\n\n    Returns:\n        Node: A deep copy of the current node.\n    \"\"\"\n\n    copied_node = copy.deepcopy(self)\n    copied_node.id = str(uuid.uuid4())\n    copied_node.children_nodes = []\n    copied_node.all_descendants = []\n    copied_node.parent_node = []\n    copied_node.all_ancestors = []\n\n    if copy_children:\n        copied_children = [\n            child.deepcopy_node() for child in self.children_nodes\n        ]\n        copied_node.add_child(*copied_children)\n\n    if name is not None:\n        copied_node.name = name\n    return copied_node\n</code></pre>"},{"location":"nodes/Node/#npxpy.nodes.node.Node.grab_all_nodes_bfs","title":"<code>grab_all_nodes_bfs(node_type)</code>","text":"<p>Grab all nodes of the specified type using breadth-first search.</p> <p>Parameters:</p> Name Type Description Default <code>node_type</code> <code>str</code> <p>The type of nodes to grab.</p> required <p>Returns:</p> Type Description <code>List[Node]</code> <p>List[Node]: List of nodes of the specified type.</p> Source code in <code>npxpy/nodes/node.py</code> <pre><code>def grab_all_nodes_bfs(self, node_type: str) -&gt; List[\"Node\"]:\n    \"\"\"\n    Grab all nodes of the specified type using breadth-first search.\n\n    Parameters:\n        node_type (str): The type of nodes to grab.\n\n    Returns:\n        List[Node]: List of nodes of the specified type.\n    \"\"\"\n    result = []\n    nodes_to_check = [self]\n    while nodes_to_check:\n        current_node = nodes_to_check.pop(0)  # Dequeue from the front\n        if current_node._type == node_type:\n            result.append(current_node)\n        nodes_to_check.extend(\n            current_node.children_nodes\n        )  # Enqueue children\n    return result\n</code></pre>"},{"location":"nodes/Node/#npxpy.nodes.node.Node.grab_node","title":"<code>grab_node(*node_types_with_indices)</code>","text":"<p>Grab nodes based on the specified types and indices.</p> <p>Parameters:</p> Name Type Description Default <code>node_types_with_indices</code> <code>Tuple[str, int]</code> <code>()</code> <p>Returns:</p> Name Type Description <code>Node</code> <code>Node</code> <p>The node found based on the specified types and indices.</p> Source code in <code>npxpy/nodes/node.py</code> <pre><code>def grab_node(self, *node_types_with_indices: Tuple[str, int]) -&gt; \"Node\":\n    \"\"\"\n    Grab nodes based on the specified types and indices.\n\n    Parameters:\n        node_types_with_indices (Tuple[str, int]):\n        Tuples of arbitrary amount containing node type and index.\n\n    Returns:\n        Node: The node found based on the specified types and indices.\n    \"\"\"\n    current_level_nodes = [self]\n    for node_type, index in node_types_with_indices:\n        next_level_nodes = []\n        for node in current_level_nodes:\n            filtered_nodes = [\n                child\n                for child in node.children_nodes\n                if child._type == node_type\n            ]\n            if len(filtered_nodes) &gt; index:\n                next_level_nodes.append(filtered_nodes[index])\n        current_level_nodes = next_level_nodes\n    return current_level_nodes[0]\n</code></pre>"},{"location":"nodes/Node/#npxpy.nodes.node.Node.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the node and its attributes to a dictionary format.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of the node.</p> Source code in <code>npxpy/nodes/node.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert the node and its attributes to a dictionary format.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of the node.\n    \"\"\"\n    self.children = [i.id for i in self.children_nodes]\n    node_dict = {\n        \"type\": self._type,\n        \"id\": self.id,\n        \"name\": self.name,\n        \"position\": self.position,\n        \"rotation\": self.rotation,\n        \"children\": self.children,\n        \"properties\": self.properties,\n        # \"geometry\": self.geometry,\n    }\n\n    return node_dict\n</code></pre>"},{"location":"nodes/Node/#npxpy.nodes.node.Node.tree","title":"<code>tree(level=0, show_type=True, show_id=False, is_last=True, prefix='')</code>","text":"<p>Print the tree structure of the node and its descendants.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>The current level in the tree. Defaults to 0.</p> <code>0</code> <code>show_type</code> <code>bool</code> <p>Whether to show the node type. Defaults to True.</p> <code>True</code> <code>show_id</code> <code>bool</code> <p>Whether to show the node ID. Defaults to False.</p> <code>False</code> <code>is_last</code> <code>bool</code> <p>Whether the node is the last child. Defaults to True.</p> <code>True</code> <code>prefix</code> <code>str</code> <p>The prefix for the current level. Defaults to ''.</p> <code>''</code> Source code in <code>npxpy/nodes/node.py</code> <pre><code>def tree(\n    self,\n    level: int = 0,\n    show_type: bool = True,\n    show_id: bool = False,\n    is_last: bool = True,\n    prefix: str = \"\",\n):\n    \"\"\"\n    Print the tree structure of the node and its descendants.\n\n    Parameters:\n        level (int, optional): The current level in the tree. Defaults to 0.\n        show_type (bool, optional): Whether to show the node type. Defaults to True.\n        show_id (bool, optional): Whether to show the node ID. Defaults to False.\n        is_last (bool, optional): Whether the node is the last child. Defaults to True.\n        prefix (str, optional): The prefix for the current level. Defaults to ''.\n    \"\"\"\n    indent = (\n        \"\" if level == 0 else prefix + (\"\u2514\" if is_last else \"\u251c\") + \"\u2500\u2500\"\n    )\n    output = (\n        f\"{indent}{self.name} ({self._type})\"\n        if show_type\n        else f\"{indent}{self.name}\"\n    )\n    if show_id:\n        output += f\" (ID: {self.id})\"\n    print(output)\n    new_prefix = prefix + (\"    \" if is_last else \"\u2502   \")\n    child_count = len(self.children_nodes)\n    for index, child in enumerate(self.children_nodes):\n        child.tree(\n            level + 1,\n            show_type,\n            show_id,\n            is_last=(index == child_count - 1),\n            prefix=new_prefix,\n        )\n</code></pre>"},{"location":"nodes/Node/#npxpy.nodes.node.Node.viewport","title":"<code>viewport(title=None, disable=None, include_ancestor_transforms=True)</code>","text":"<p>Opens a PyVista viewport visualizing the attached objects in this node. Notes</p> <ul> <li>Does not visualize multiplications caused by Arrays yet.</li> <li>Lenses might not be displayed accurately in the viewport visualization.   However, this does not affect the final printed output.</li> <li>Supports multiple node types such as <code>scene</code>, <code>structure</code>, <code>coarse_alignment</code>,   <code>interface_alignment</code>, <code>fiber_core_alignment</code>, <code>marker_alignment</code>, <code>edge_alignment</code>,   and <code>dose_compensation</code>.</li> </ul>"},{"location":"nodes/Node/#npxpy.nodes.node.Node.viewport--parameters","title":"Parameters","text":"<p>title : str, optional     Title to display in the PyVista window. Defaults to the name of the calling node. disable : str or list of str, optional     One or more group names to disable visibility for. These groups will not be visible     in the viewport. For example, <code>\"scene\"</code> or <code>[\"scene\", \"coarse_alignment\"]</code>. include_ancestor_transforms : bool, optional     Whether to apply transformations (position and rotation) from ancestor nodes to the     visualized objects. Defaults to <code>True</code>.</p>"},{"location":"nodes/Node/#npxpy.nodes.node.Node.viewport--returns","title":"Returns","text":"<p>_GroupedPlotter     A customized plotter instance after rendering all meshes, including any     transformations or visibility settings applied.</p>"},{"location":"nodes/Node/#npxpy.nodes.node.Node.viewport--examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; # Basic usage without disabling any groups\n&gt;&gt;&gt; node.viewport()\n\n&gt;&gt;&gt; # Disable visibility for \"scene\" and \"coarse_alignment\" groups\n&gt;&gt;&gt; node.viewport(disable=[\"scene\", \"coarse_alignment\"])\n\n&gt;&gt;&gt; # Exclude transformations from ancestor nodes\n&gt;&gt;&gt; node.viewport(include_ancestor_transforms=False)\n</code></pre> Source code in <code>npxpy/nodes/node.py</code> <pre><code>def viewport(\n    self,\n    title: Optional[str] = None,\n    disable: Optional[Union[str, List[str]]] = None,\n    include_ancestor_transforms: Optional[bool] = True,\n):\n    \"\"\"\n    Opens a PyVista viewport visualizing the attached objects in this node.\n    Notes\n    -----\n    - Does not visualize multiplications caused by Arrays yet.\n    - Lenses might not be displayed accurately in the viewport visualization.\n      However, this does not affect the final printed output.\n    - Supports multiple node types such as `scene`, `structure`, `coarse_alignment`,\n      `interface_alignment`, `fiber_core_alignment`, `marker_alignment`, `edge_alignment`,\n      and `dose_compensation`.\n\n    Parameters\n    ----------\n    title : str, optional\n        Title to display in the PyVista window. Defaults to the name of the calling node.\n    disable : str or list of str, optional\n        One or more group names to disable visibility for. These groups will not be visible\n        in the viewport. For example, `\"scene\"` or `[\"scene\", \"coarse_alignment\"]`.\n    include_ancestor_transforms : bool, optional\n        Whether to apply transformations (position and rotation) from ancestor nodes to the\n        visualized objects. Defaults to `True`.\n\n    Returns\n    -------\n    _GroupedPlotter\n        A customized plotter instance after rendering all meshes, including any\n        transformations or visibility settings applied.\n\n    Examples\n    --------\n    ```python\n    &gt;&gt;&gt; # Basic usage without disabling any groups\n    &gt;&gt;&gt; node.viewport()\n\n    &gt;&gt;&gt; # Disable visibility for \"scene\" and \"coarse_alignment\" groups\n    &gt;&gt;&gt; node.viewport(disable=[\"scene\", \"coarse_alignment\"])\n\n    &gt;&gt;&gt; # Exclude transformations from ancestor nodes\n    &gt;&gt;&gt; node.viewport(include_ancestor_transforms=False)\n    ```\n    \"\"\"\n    _GroupedPlotter, _apply_transforms, _meshbuilder, blocks = (\n        self._lazy_import_wrapper()\n    )\n\n    block_dicts_list = []\n\n    if disable is None:\n        disable = []\n    if title is None:\n        title = self.name\n    # Create the plotter\n    plotter = _GroupedPlotter(\n        title=f\"npxpy - Project Viewport ({title})\",\n        update_app_icon=False,\n    )\n\n    # Grid, axes, background\n    plotter.show_grid(\n        grid=\"back\",\n        location=\"outer\",\n        color=\"gray\",\n        xtitle=\"x\",\n        ytitle=\"y\",\n        ztitle=\"z\",\n        show_zlabels=True,\n        padding=0.1,\n        font_size=8,\n    )\n    plotter.show_axes()\n    plotter.view_isometric()\n    plotter.set_background(\"white\")\n\n    # Add logo widget\n    logo_path = str(files(\"npxpy.images\").joinpath(\"logo.png\"))\n    plotter.add_logo_widget(\n        logo=logo_path,\n        opacity=0.75,\n        size=(0.15, 0.15),\n        position=(0.84, 0.86),\n    )\n    # init the meshbuilder\n    meshbuilder = _meshbuilder()\n\n    for node in [self] + self.all_descendants:\n        all_rotations = [\n            getattr(ancestor, \"rotation\", [0, 0, 0])\n            for ancestor in node.all_ancestors\n        ]\n        all_rotations.reverse()\n\n        all_positions = [\n            getattr(ancestor, \"position\", [0, 0, 0])\n            for ancestor in node.all_ancestors\n        ]\n        all_positions.reverse()\n\n        # If False, only go as far as node calling viewport()\n        if not include_ancestor_transforms:\n            if node != self:\n                dummy = node.all_ancestors.copy()\n                dummy.reverse()\n                start = dummy.index(self)\n                all_positions = all_positions[start:]\n                all_rotations = all_rotations[start:]\n            else:\n                all_positions = [[0, 0, 0]]\n                all_rotations = [[0, 0, 0]]\n\n        if node._type == \"scene\":\n            scene = node\n            # Create the circle representing the scene\n            if len(scene.all_ancestors) != 0 and hasattr(\n                scene.all_ancestors[-1], \"objective\"\n            ):\n                ronin_node = False\n                objective = scene.all_ancestors[-1].objective\n            else:\n                print(\n                    (\n                        f\"{self.name} not attached to any project node.\\n\"\n                        \"Objective is thus assumed to be x63.\"\n                    )\n                )\n                ronin_node = True\n                objective = \"\"  # dummy. wont do anything in this case\n\n            scene_mesh, scene_mesh_dict = _meshbuilder.scene_mesh(\n                objective, ronin_node\n            )\n            # apply first all_ancestors' rots\n\n            _apply_transforms(\n                scene_mesh,\n                all_positions=all_positions + [scene.position],\n                all_rotations=all_rotations + [scene.rotation],\n            )\n\n            # Add to plotter as 'scene' group\n            plotter.add_mesh(scene_mesh, **scene_mesh_dict)\n            # blocks.append(scene_mesh)\n            # block_dicts_list.append(scene_mesh_dict)\n        # Structure\n        if node._type == \"structure\" and node._mesh:\n            structure = node\n            loaded_mesh = _meshbuilder.load_mesh(structure.mesh.file_path)\n            # apply initial mesh transformation\n            _apply_transforms(\n                mesh=loaded_mesh,\n                all_positions=[structure.mesh.translation],\n                all_rotations=[structure.mesh.rotation],\n            )\n\n            # apply all_ancestors' rots and afterwards structure rotation\n            _apply_transforms(\n                mesh=loaded_mesh,\n                all_rotations=all_rotations + [structure.rotation],\n                all_positions=all_positions + [structure.position],\n            )\n\n            # Add to plotter\n            plotter.add_mesh(\n                loaded_mesh, color=structure.color, group=structure._type\n            )\n            # blocks.append(loaded_mesh)\n            # block_dicts_list.append(\n            #    {\"color\": structure.color, \"group\": structure._type}\n            # )\n        # Text (structure)\n        if node._type == \"structure\" and hasattr(node, \"font_size\"):\n            text_node = node\n            text_mesh, text_mesh_dict = _meshbuilder.txt_mesh(text_node)\n            # apply all_ancestors' rots and afterwards structure rotation\n            _apply_transforms(\n                mesh=text_mesh,\n                all_rotations=all_rotations + [text_node.rotation],\n                all_positions=all_positions + [text_node.position],\n            )\n\n            plotter.add_mesh(text_mesh, **text_mesh_dict)\n            # blocks.append(text_mesh)\n            # block_dicts_list.append(text_mesh_dict)\n        # Lens (structure)\n        elif (\n            node._type == \"structure\"\n            and not node._mesh\n            and not hasattr(node, \"font_size\")\n        ):\n            lens = node\n            geometry = lens.to_dict()[\"geometry\"]\n            del (\n                geometry[\"type\"],\n                geometry[\"nr_radial_segments\"],\n                geometry[\"nr_phi_segments\"],\n            )\n            lens_mesh = meshbuilder.lens_mesh(**geometry)\n\n            _apply_transforms(\n                mesh=lens_mesh,\n                all_rotations=all_rotations + [lens.rotation],\n                all_positions=all_positions + [lens.position],\n            )\n\n            lens_mesh_dict = {\n                \"color\": lens.color,\n                \"group\": \"structure_lens\",\n            }\n            plotter.add_mesh(lens_mesh, **lens_mesh_dict)\n            # blocks.append(lens_mesh)\n            # block_dicts_list.append(lens_mesh_dict)\n        # Coarse aligners\n        if node._type == \"coarse_alignment\":\n            coarse_aligner = node\n            coarse_anchor_mesh, coarse_anchor_mesh_dict = (\n                _meshbuilder.ca_mesh(coarse_aligner)\n            )\n            # for coarse_anchor_mesh in coarse_anchor_meshes:\n            # apply all_ancestors' rots and afterwards mesh rotation\n            _apply_transforms(\n                mesh=coarse_anchor_mesh,\n                all_rotations=all_rotations,\n                all_positions=all_positions,\n            )\n\n            plotter.add_mesh(coarse_anchor_mesh, **coarse_anchor_mesh_dict)\n            # blocks.append(coarse_anchor_mesh)\n            # block_dicts_list.append(coarse_anchor_mesh_dict)\n        # interface aligners\n        if node._type == \"interface_alignment\":\n            interface_aligner = node\n\n            ia_mesh, ia_mesh_dict = meshbuilder.ia_mesh(\n                interface_aligner_node=interface_aligner\n            )\n\n            _apply_transforms(\n                mesh=ia_mesh,\n                all_rotations=all_rotations,\n                all_positions=all_positions,\n            )\n\n            plotter.add_mesh(ia_mesh, **ia_mesh_dict)\n            # blocks.append(ia_mesh)\n            # block_dicts_list.append(ia_mesh_dict)\n        # fiber aligners\n        if node._type == \"fiber_core_alignment\":\n            fiber_aligner = node\n            fa_mesh, fa_mesh_dict = meshbuilder.fa_mesh(fiber_aligner)\n\n            _apply_transforms(\n                mesh=fa_mesh,\n                all_rotations=all_rotations,\n                all_positions=all_positions,\n            )\n\n            plotter.add_mesh(fa_mesh, **fa_mesh_dict)\n            # blocks.append(fa_mesh)\n            # block_dicts_list.append(fa_mesh_dict)\n        # Marker aligners\n        if node._type == \"marker_alignment\":\n            marker_aligner = node\n            ma_meshes, ma_label_meshes, ma_mesh_dict, ma_label_dict = (\n                _meshbuilder.ma_mesh(marker_aligner)\n            )\n\n            for ma_mesh, ma_label_mesh in zip(ma_meshes, ma_label_meshes):\n\n                # apply all_ancestors' rots\n                _apply_transforms(\n                    mesh=ma_mesh,\n                    all_rotations=all_rotations,\n                    all_positions=all_positions,\n                )\n                # apply all_ancestors' rots\n                _apply_transforms(\n                    mesh=ma_label_mesh,\n                    all_rotations=all_rotations,\n                    all_positions=all_positions,\n                )\n\n                plotter.add_mesh(ma_mesh, **ma_mesh_dict)\n                # blocks.append(ma_mesh)\n                # block_dicts_list.append(ma_mesh_dict)\n                plotter.add_mesh(ma_label_mesh, **ma_label_dict)\n                # blocks.append(ma_label_mesh)\n                # block_dicts_list.append(ma_label_dict)\n\n        #  Edge aligners\n        if node._type == \"edge_alignment\":\n            edge_aligner = node\n            edge_aligner_meshes, edge_aligner_meshes_dicts = (\n                _meshbuilder.ea_mesh(edge_aligner)\n            )\n\n            for mesh, mesh_dict in zip(\n                edge_aligner_meshes, edge_aligner_meshes_dicts\n            ):\n\n                _apply_transforms(\n                    mesh,\n                    all_positions=[edge_aligner.edge_location + [0]],\n                    all_rotations=[\n                        [0, 0, edge_aligner.edge_orientation]\n                    ],  # (in-plane rotation only)\n                )\n\n                # apply all_ancestors' rots\n                _apply_transforms(\n                    mesh,\n                    all_rotations=all_rotations,\n                    all_positions=all_positions,\n                )\n\n                plotter.add_mesh(mesh, **mesh_dict)\n                # blocks.append(mesh)\n                # block_dicts_list.append(mesh_dict)\n        # Dose compensation\n        if node._type == \"dose_compensation\":\n            dose_compensation = node\n\n            for mesh, kwargs in _meshbuilder.dc_meshes(\n                dose_compensation.domain_size\n            ):\n                _apply_transforms(\n                    mesh=mesh,\n                    all_rotations=all_rotations\n                    + [[0, 0, dose_compensation.edge_orientation]],\n                    all_positions=all_positions\n                    + [dose_compensation.edge_location],\n                )\n\n                plotter.add_mesh(mesh, **kwargs)\n                # blocks.append(mesh)\n                # block_dicts_list.append(kwargs)\n        # Capture\n        if node._type == \"capture\":\n            capture = node\n\n            capt_mesh, capt_mesh_dict = _meshbuilder.capture_mesh(capture)\n\n            _apply_transforms(\n                mesh=capt_mesh,\n                all_rotations=all_rotations,\n                all_positions=all_positions,\n            )\n\n            plotter.add_mesh(capt_mesh, **capt_mesh_dict)\n            # blocks.append(capt_mesh)\n            # block_dicts_list.append(capt_mesh_dict)\n\n    actor, mapper = plotter.add_composite(blocks)\n    for idx, block_dict in enumerate(block_dicts_list, start=1):\n        for key, value in block_dict.items():\n            setattr(mapper.block_attr[idx], key, value)\n\n    # Disable visibility for certain groups if requested\n    self._visibility_in_plotter_disabled = disable\n    for grp in self._visibility_in_plotter_disabled:\n        plotter.disable(grp)\n\n    plotter._add_custom_axes()\n    # Show the viewport\n    plotter.show()\n\n    return plotter\n</code></pre>"},{"location":"nodes/Project/","title":"npxpy.nodes.project.Project","text":"<p>               Bases: <code>Node</code></p> <p>Class: project nodes.</p> <p>Attributes:</p> Name Type Description <code>presets</code> <code>list</code> <p>List of presets for the project.</p> <code>resources</code> <code>list</code> <p>List of resources for the project.</p> <code>project_info</code> <code>dict</code> <p>Information about the project including author, objective, resin, substrate, and creation date.</p> Source code in <code>npxpy/nodes/project.py</code> <pre><code>class Project(Node):\n    \"\"\"\n    Class: project nodes.\n\n    Attributes:\n        presets (list): List of presets for the project.\n        resources (list): List of resources for the project.\n        project_info (dict): Information about the project including author, objective, resin, substrate, and creation date.\n    \"\"\"\n\n    def __init__(\n        self,\n        objective: str,\n        resin: str,\n        substrate: str,\n        auto_load_presets: bool = False,\n        auto_load_meshes: bool = False,\n        auto_load_images: bool = False,\n    ):\n        \"\"\"\n        Initialize the project with the specified parameters.\n\n        Parameters:\n            objective (str): Objective of the project.\n            resin (str): Resin used in the project.\n            substrate (str): Substrate used in the project.\n            auto_load_presets (bool): Whether or not to automatically load any attached presets.\n            auto_load_meshes (bool): Whether or not to automatically load any attached meshes.\n            auto_load_images (bool): Whether or not to automatically load any attached images.\n\n        Raises:\n            ValueError: If any of the parameters have invalid values.\n        \"\"\"\n        super().__init__(node_type=\"project\", name=\"Project\")\n\n        self.objective = objective\n        self.resin = resin\n        self.substrate = substrate\n\n        self._presets = []\n        self._resources = []\n        self.project_info = {\n            \"author\": os.getlogin(),\n            \"objective\": objective,\n            \"resist\": resin,\n            \"substrate\": substrate,\n            \"creation_date\": datetime.now().replace(microsecond=0).isoformat(),\n        }\n        self._visibility_in_plotter_disabled = []\n        self._loaded_resource_ids = set()\n        self._loaded_preset_ids = set()\n        self._auto_load_presets = auto_load_presets\n        self._auto_load_meshes = auto_load_meshes\n        self._auto_load_images = auto_load_images\n\n    # Setters for the attributes with validation\n    @property\n    def objective(self):\n        return self._objective\n\n    @objective.setter\n    def objective(self, value: str):\n        if value == \"10x\":\n            self._objective = \"10xW\"\n        else:\n            valid_objectives = {\n                \"10xW\",\n                \"25x\",\n                \"63x\",\n                \"*\",\n            }\n            if value not in valid_objectives:\n                raise ValueError(\n                    f\"Invalid objective: {value}. Must be one of {valid_objectives}.\"\n                )\n            self._objective = value\n\n    @property\n    def resin(self):\n        return self._resin\n\n    @resin.setter\n    def resin(self, value: str):\n        valid_resins = {\n            \"IP-Dip\",\n            \"IP-Dip2\",\n            \"IP-L\",\n            \"IP-n162\",\n            \"IP-PDMS\",\n            \"IP-S\",\n            \"IP-Visio\",\n            \"IPX-Clear\",\n            \"IPX-Q\",\n            \"IPX-S\",\n            \"*\",\n        }\n        if value not in valid_resins:\n            raise ValueError(\n                f\"Invalid resin: {value}. Must be one of {valid_resins}.\"\n            )\n        self._resin = value\n\n    @property\n    def substrate(self):\n        return self._substrate\n\n    @substrate.setter\n    def substrate(self, value: str):\n        valid_substrates = {\"*\", \"Si\", \"FuSi\"}\n        if value not in valid_substrates:\n            raise ValueError(\n                f\"Invalid substrate: {value}. Must be one of {valid_substrates}.\"\n            )\n        self._substrate = value\n\n    # Read-only public properties\n    @property\n    def presets(self):\n        \"\"\"Get the list of presets.\"\"\"\n        return self._presets\n\n    @property\n    def resources(self):\n        \"\"\"Get the list of resources.\"\"\"\n        return self._resources\n\n    def load_resources(self, *resourcess: Union[Resource, List[Resource]]):\n        \"\"\"\n        Adds resources to the resources list, skipping duplicates based on UUID.\n        \"\"\"\n        for resources in resourcess:\n            if not isinstance(resources, list):\n                resources = [resources]\n\n            if not all(\n                isinstance(resource, Resource) for resource in resources\n            ):\n                raise TypeError(\n                    \"All resources must be instances of the Resource class or its subclasses.\"\n                )\n\n            for resource in resources:\n                if resource.id in self._loaded_resource_ids:\n                    warnings.warn(\n                        f\"Resource with ID {resource.id} already loaded. Skipping.\"\n                    )\n                    continue\n                self._resources.append(resource)\n                self._loaded_resource_ids.add(resource.id)\n\n    def load_presets(self, *presetss: Union[Preset, List[Preset]]):\n        \"\"\"\n        Adds presets to the presets list, skipping duplicates based on UUID.\n        \"\"\"\n        for presets in presetss:\n            if not isinstance(presets, list):\n                presets = [presets]\n\n            if not all(isinstance(preset, Preset) for preset in presets):\n                raise TypeError(\n                    \"All presets must be instances of the Preset class.\"\n                )\n\n            for preset in presets:\n                if preset.id in self._loaded_preset_ids:\n                    warnings.warn(\n                        f\"Preset with ID {preset.id} already loaded. Skipping.\"\n                    )\n                    continue\n                self._presets.append(preset)\n                self._loaded_preset_ids.add(preset.id)\n\n    def _auto_load_resources_presets(self):\n        \"\"\"\n        Loads all Resource/Preset nodes into the Project node they\n        are attached to.\n        \"\"\"\n        all_structures = self.grab_all_nodes_bfs(\"structure\")\n        all_marker_aligners = self.grab_all_nodes_bfs(\"marker_alignment\")\n\n        if self._auto_load_meshes:\n            all_meshes = [\n                structure.mesh\n                for structure in all_structures\n                if structure._mesh\n            ]\n            self.load_resources(all_meshes)\n\n        if self._auto_load_presets:\n            all_presets = [structure.preset for structure in all_structures]\n            self.load_presets(all_presets)\n\n        if self._auto_load_images:\n            all_images = [\n                marker_aligner.image for marker_aligner in all_marker_aligners\n            ]\n            self.load_resources(all_images)\n\n    def _create_toml_data(\n        self, presets: List[Any], resources: List[Any], nodes: List[Node]\n    ) -&gt; str:\n        \"\"\"\n        Creates TOML data for the project.\n        \"\"\"\n        data = {\n            \"presets\": [preset.to_dict() for preset in presets],\n            \"resources\": [resource.to_dict() for resource in resources],\n            \"nodes\": [node.to_dict() for node in nodes],\n        }\n        return toml.dumps(data)\n\n    def _create_project_info(self, project_info_json: Dict[str, Any]) -&gt; str:\n        \"\"\"\n        Creates JSON data for project info.\n        \"\"\"\n        return json.dumps(project_info_json, indent=4)\n\n    def _add_file_to_zip(\n        self, zip_file: zipfile.ZipFile, file_path: str, arcname: str\n    ):\n        \"\"\"\n        Adds a file to a zip archive.\n        \"\"\"\n        with open(file_path, \"rb\") as f:\n            zip_file.writestr(arcname, f.read())\n\n    def nano(self, project_name: str = \"Project\", path: str = \"./\"):\n        \"\"\"\n        Creates a .nano file for the project.\n        \"\"\"\n        print(\"npxpy: Attempting to create .nano-file...\")\n\n        # Trigger user warning if project contains structures outside scenes\n        for i_node in self.all_descendants:\n            if i_node._type == \"structure\":\n                if not \"scene\" in [i._type for i in self.all_ancestors]:\n                    UserWarning(\"Structures have to be inside Scene nodes!\")\n\n        # Autoload presets/resources if desired\n        if any(\n            [\n                self._auto_load_images,\n                self._auto_load_meshes,\n                self._auto_load_presets,\n            ]\n        ):\n            self._auto_load_resources_presets()\n\n        # Ensure the path ends with a slash\n        if not path.endswith(\"/\"):\n            path += \"/\"\n\n        # Prepare paths and data\n        nano_file_path = os.path.join(path, f\"{project_name}.nano\")\n        toml_data = self._create_toml_data(\n            self._presets, self._resources, [self] + self.all_descendants\n        )\n        project_info_data = self._create_project_info(self.project_info)\n\n        with zipfile.ZipFile(\n            nano_file_path, \"w\", zipfile.ZIP_STORED\n        ) as nano_zip:\n            # Add the __main__.toml to the zip file\n            nano_zip.writestr(\"__main__.toml\", toml_data)\n\n            # Add the project_info.json to the zip file\n            nano_zip.writestr(\"project_info.json\", project_info_data)\n\n            # Add the resources to the zip file\n            already_zipped_resources = set()\n            for resource in self._resources:\n                src_path = resource.file_path\n                arcname = resource.safe_path\n                if (\n                    os.path.isfile(src_path)\n                    and arcname not in already_zipped_resources\n                ):\n                    self._add_file_to_zip(nano_zip, src_path, arcname)\n                    already_zipped_resources.add(arcname)\n                elif not os.path.isfile(src_path):\n                    print(f\"File not found: {src_path}\")\n                else:\n                    print(f\"File already loaded: {src_path}\")\n        print(\"npxpy: .nano-file created successfully.\")\n\n    def to_dict(self) -&gt; Dict:\n        \"\"\"\n        Convert the Project object into a dictionary.\n        \"\"\"\n        node_dict = super().to_dict()\n        node_dict.update(\n            {\n                \"objective\": self.objective,\n                \"resin\": self.resin,\n                \"substrate\": self.substrate,\n            }\n        )\n        return node_dict\n</code></pre>"},{"location":"nodes/Project/#npxpy.nodes.project.Project.presets","title":"<code>presets</code>  <code>property</code>","text":"<p>Get the list of presets.</p>"},{"location":"nodes/Project/#npxpy.nodes.project.Project.resources","title":"<code>resources</code>  <code>property</code>","text":"<p>Get the list of resources.</p>"},{"location":"nodes/Project/#npxpy.nodes.project.Project.__init__","title":"<code>__init__(objective, resin, substrate, auto_load_presets=False, auto_load_meshes=False, auto_load_images=False)</code>","text":"<p>Initialize the project with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>objective</code> <code>str</code> <p>Objective of the project.</p> required <code>resin</code> <code>str</code> <p>Resin used in the project.</p> required <code>substrate</code> <code>str</code> <p>Substrate used in the project.</p> required <code>auto_load_presets</code> <code>bool</code> <p>Whether or not to automatically load any attached presets.</p> <code>False</code> <code>auto_load_meshes</code> <code>bool</code> <p>Whether or not to automatically load any attached meshes.</p> <code>False</code> <code>auto_load_images</code> <code>bool</code> <p>Whether or not to automatically load any attached images.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the parameters have invalid values.</p> Source code in <code>npxpy/nodes/project.py</code> <pre><code>def __init__(\n    self,\n    objective: str,\n    resin: str,\n    substrate: str,\n    auto_load_presets: bool = False,\n    auto_load_meshes: bool = False,\n    auto_load_images: bool = False,\n):\n    \"\"\"\n    Initialize the project with the specified parameters.\n\n    Parameters:\n        objective (str): Objective of the project.\n        resin (str): Resin used in the project.\n        substrate (str): Substrate used in the project.\n        auto_load_presets (bool): Whether or not to automatically load any attached presets.\n        auto_load_meshes (bool): Whether or not to automatically load any attached meshes.\n        auto_load_images (bool): Whether or not to automatically load any attached images.\n\n    Raises:\n        ValueError: If any of the parameters have invalid values.\n    \"\"\"\n    super().__init__(node_type=\"project\", name=\"Project\")\n\n    self.objective = objective\n    self.resin = resin\n    self.substrate = substrate\n\n    self._presets = []\n    self._resources = []\n    self.project_info = {\n        \"author\": os.getlogin(),\n        \"objective\": objective,\n        \"resist\": resin,\n        \"substrate\": substrate,\n        \"creation_date\": datetime.now().replace(microsecond=0).isoformat(),\n    }\n    self._visibility_in_plotter_disabled = []\n    self._loaded_resource_ids = set()\n    self._loaded_preset_ids = set()\n    self._auto_load_presets = auto_load_presets\n    self._auto_load_meshes = auto_load_meshes\n    self._auto_load_images = auto_load_images\n</code></pre>"},{"location":"nodes/Project/#npxpy.nodes.project.Project.load_presets","title":"<code>load_presets(*presetss)</code>","text":"<p>Adds presets to the presets list, skipping duplicates based on UUID.</p> Source code in <code>npxpy/nodes/project.py</code> <pre><code>def load_presets(self, *presetss: Union[Preset, List[Preset]]):\n    \"\"\"\n    Adds presets to the presets list, skipping duplicates based on UUID.\n    \"\"\"\n    for presets in presetss:\n        if not isinstance(presets, list):\n            presets = [presets]\n\n        if not all(isinstance(preset, Preset) for preset in presets):\n            raise TypeError(\n                \"All presets must be instances of the Preset class.\"\n            )\n\n        for preset in presets:\n            if preset.id in self._loaded_preset_ids:\n                warnings.warn(\n                    f\"Preset with ID {preset.id} already loaded. Skipping.\"\n                )\n                continue\n            self._presets.append(preset)\n            self._loaded_preset_ids.add(preset.id)\n</code></pre>"},{"location":"nodes/Project/#npxpy.nodes.project.Project.load_resources","title":"<code>load_resources(*resourcess)</code>","text":"<p>Adds resources to the resources list, skipping duplicates based on UUID.</p> Source code in <code>npxpy/nodes/project.py</code> <pre><code>def load_resources(self, *resourcess: Union[Resource, List[Resource]]):\n    \"\"\"\n    Adds resources to the resources list, skipping duplicates based on UUID.\n    \"\"\"\n    for resources in resourcess:\n        if not isinstance(resources, list):\n            resources = [resources]\n\n        if not all(\n            isinstance(resource, Resource) for resource in resources\n        ):\n            raise TypeError(\n                \"All resources must be instances of the Resource class or its subclasses.\"\n            )\n\n        for resource in resources:\n            if resource.id in self._loaded_resource_ids:\n                warnings.warn(\n                    f\"Resource with ID {resource.id} already loaded. Skipping.\"\n                )\n                continue\n            self._resources.append(resource)\n            self._loaded_resource_ids.add(resource.id)\n</code></pre>"},{"location":"nodes/Project/#npxpy.nodes.project.Project.nano","title":"<code>nano(project_name='Project', path='./')</code>","text":"<p>Creates a .nano file for the project.</p> Source code in <code>npxpy/nodes/project.py</code> <pre><code>def nano(self, project_name: str = \"Project\", path: str = \"./\"):\n    \"\"\"\n    Creates a .nano file for the project.\n    \"\"\"\n    print(\"npxpy: Attempting to create .nano-file...\")\n\n    # Trigger user warning if project contains structures outside scenes\n    for i_node in self.all_descendants:\n        if i_node._type == \"structure\":\n            if not \"scene\" in [i._type for i in self.all_ancestors]:\n                UserWarning(\"Structures have to be inside Scene nodes!\")\n\n    # Autoload presets/resources if desired\n    if any(\n        [\n            self._auto_load_images,\n            self._auto_load_meshes,\n            self._auto_load_presets,\n        ]\n    ):\n        self._auto_load_resources_presets()\n\n    # Ensure the path ends with a slash\n    if not path.endswith(\"/\"):\n        path += \"/\"\n\n    # Prepare paths and data\n    nano_file_path = os.path.join(path, f\"{project_name}.nano\")\n    toml_data = self._create_toml_data(\n        self._presets, self._resources, [self] + self.all_descendants\n    )\n    project_info_data = self._create_project_info(self.project_info)\n\n    with zipfile.ZipFile(\n        nano_file_path, \"w\", zipfile.ZIP_STORED\n    ) as nano_zip:\n        # Add the __main__.toml to the zip file\n        nano_zip.writestr(\"__main__.toml\", toml_data)\n\n        # Add the project_info.json to the zip file\n        nano_zip.writestr(\"project_info.json\", project_info_data)\n\n        # Add the resources to the zip file\n        already_zipped_resources = set()\n        for resource in self._resources:\n            src_path = resource.file_path\n            arcname = resource.safe_path\n            if (\n                os.path.isfile(src_path)\n                and arcname not in already_zipped_resources\n            ):\n                self._add_file_to_zip(nano_zip, src_path, arcname)\n                already_zipped_resources.add(arcname)\n            elif not os.path.isfile(src_path):\n                print(f\"File not found: {src_path}\")\n            else:\n                print(f\"File already loaded: {src_path}\")\n    print(\"npxpy: .nano-file created successfully.\")\n</code></pre>"},{"location":"nodes/Project/#npxpy.nodes.project.Project.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the Project object into a dictionary.</p> Source code in <code>npxpy/nodes/project.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n    \"\"\"\n    Convert the Project object into a dictionary.\n    \"\"\"\n    node_dict = super().to_dict()\n    node_dict.update(\n        {\n            \"objective\": self.objective,\n            \"resin\": self.resin,\n            \"substrate\": self.substrate,\n        }\n    )\n    return node_dict\n</code></pre>"},{"location":"nodes/aligners/CoarseAligner/","title":"npxpy.nodes.aligners.CoarseAligner","text":"<p>               Bases: <code>Node</code></p> <p>Class for coarse alignment nodes.</p> <p>Attributes:</p> Name Type Description <code>residual_threshold</code> <code>Union[float, int]</code> <p>The residual threshold for alignment.</p> <code>alignment_anchors</code> <code>List[Dict]</code> <p>List of alignment anchors with label and position.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>class CoarseAligner(Node):\n    \"\"\"\n    Class for coarse alignment nodes.\n\n    Attributes:\n        residual_threshold (Union[float, int]): The residual threshold for alignment.\n        alignment_anchors (List[Dict]): List of alignment anchors with label and position.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"Coarse aligner\",\n        residual_threshold: Union[float, int] = 10.0,\n    ):\n        \"\"\"\n        Initialize the coarse aligner with a name and a residual threshold.\n\n        Parameters:\n            name (str): The name of the coarse aligner node.\n            residual_threshold (Union[float, int]): The residual threshold for alignment. Must be greater than 0.\n\n        Raises:\n            ValueError: If residual_threshold is not greater than 0.\n        \"\"\"\n        super().__init__(\"coarse_alignment\", name)\n\n        self._alignment_anchors = []\n        self.residual_threshold = (\n            residual_threshold  # Using setter for validation\n        )\n\n    @property\n    def residual_threshold(self):\n        \"\"\"Get the residual threshold.\"\"\"\n        return self._residual_threshold\n\n    @residual_threshold.setter\n    def residual_threshold(self, value: Union[float, int]):\n        \"\"\"\n        Set the residual threshold for alignment.\n\n        Parameters:\n            value (Union[float, int]): Residual threshold, must be greater than 0.\n\n        Raises:\n            ValueError: If residual_threshold is not greater than 0.\n        \"\"\"\n        if not isinstance(value, (float, int)) or value &lt;= 0:\n            raise ValueError(\"residual_threshold must be a positive number.\")\n        self._residual_threshold = value\n\n    @property\n    def alignment_anchors(self):\n        \"\"\"Get the list of alignment anchors.\"\"\"\n        return self._alignment_anchors\n\n    def add_coarse_anchor(self, position: List[Union[float, int]], label: str):\n        \"\"\"\n        Add a single coarse anchor with a label and position.\n\n        Parameters:\n            label (str): The label for the anchor.\n            position (List[Union[float, int]]): The position [x, y, z] for the anchor.\n\n        Raises:\n            ValueError: If position does not contain exactly three elements.\n            TypeError: If any element in position is not a number.\n        \"\"\"\n        if not isinstance(label, str):\n            raise TypeError(\"label must be a string.\")\n        if len(position) != 3:\n            raise ValueError(\"position must be a list of three elements.\")\n        if not all(isinstance(p, (float, int)) for p in position):\n            raise TypeError(\"All position elements must be numbers.\")\n\n        self._alignment_anchors.append(\n            {\n                \"label\": label,\n                \"position\": position,\n            }\n        )\n        return self\n\n    def set_coarse_anchors_at(\n        self,\n        positions: List[List[Union[float, int]]],\n        labels: List[str] = None,\n    ):\n        \"\"\"\n        Create multiple coarse anchors at specified positions.\n\n        Parameters:\n            labels (List[str]): List of labels for the anchors.\n            positions (List[List[Union[float, int]]]): List of positions for the anchors, each position is [x, y, z].\n\n        Returns:\n            self: The instance of the CoarseAligner class.\n\n        Raises:\n            ValueError: If the number of labels does not match the number of positions.\n            TypeError: If any label is not a string or any position is not a list of numbers.\n        \"\"\"\n        if labels is None:\n            labels = [f\"anchor_{i}\" for i in range(len(positions))]\n        if len(labels) != len(positions):\n            raise ValueError(\n                \"The number of labels must match the number of positions.\"\n            )\n\n        for label in labels:\n            if not isinstance(label, str):\n                raise TypeError(\"All labels must be strings.\")\n\n        for position in positions:\n            if len(position) != 3:\n                raise ValueError(\n                    \"Each position must be a list of three elements.\"\n                )\n            if not all(isinstance(p, (float, int)) for p in position):\n                raise TypeError(\"All position elements must be numbers.\")\n\n        for label, position in zip(labels, positions):\n            self.add_coarse_anchor(position, label)\n\n        return self\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Convert the CoarseAligner object into a dictionary.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of the object.\n        \"\"\"\n        node_dict = super().to_dict()  # Get basic attributes from Node\n        node_dict.update(\n            {\n                \"alignment_anchors\": self.alignment_anchors,\n                \"residual_threshold\": self.residual_threshold,\n            }\n        )\n        return node_dict\n</code></pre>"},{"location":"nodes/aligners/CoarseAligner/#npxpy.nodes.aligners.CoarseAligner.alignment_anchors","title":"<code>alignment_anchors</code>  <code>property</code>","text":"<p>Get the list of alignment anchors.</p>"},{"location":"nodes/aligners/CoarseAligner/#npxpy.nodes.aligners.CoarseAligner.residual_threshold","title":"<code>residual_threshold</code>  <code>property</code> <code>writable</code>","text":"<p>Get the residual threshold.</p>"},{"location":"nodes/aligners/CoarseAligner/#npxpy.nodes.aligners.CoarseAligner.__init__","title":"<code>__init__(name='Coarse aligner', residual_threshold=10.0)</code>","text":"<p>Initialize the coarse aligner with a name and a residual threshold.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the coarse aligner node.</p> <code>'Coarse aligner'</code> <code>residual_threshold</code> <code>Union[float, int]</code> <p>The residual threshold for alignment. Must be greater than 0.</p> <code>10.0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If residual_threshold is not greater than 0.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"Coarse aligner\",\n    residual_threshold: Union[float, int] = 10.0,\n):\n    \"\"\"\n    Initialize the coarse aligner with a name and a residual threshold.\n\n    Parameters:\n        name (str): The name of the coarse aligner node.\n        residual_threshold (Union[float, int]): The residual threshold for alignment. Must be greater than 0.\n\n    Raises:\n        ValueError: If residual_threshold is not greater than 0.\n    \"\"\"\n    super().__init__(\"coarse_alignment\", name)\n\n    self._alignment_anchors = []\n    self.residual_threshold = (\n        residual_threshold  # Using setter for validation\n    )\n</code></pre>"},{"location":"nodes/aligners/CoarseAligner/#npxpy.nodes.aligners.CoarseAligner.add_coarse_anchor","title":"<code>add_coarse_anchor(position, label)</code>","text":"<p>Add a single coarse anchor with a label and position.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label for the anchor.</p> required <code>position</code> <code>List[Union[float, int]]</code> <p>The position [x, y, z] for the anchor.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If position does not contain exactly three elements.</p> <code>TypeError</code> <p>If any element in position is not a number.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def add_coarse_anchor(self, position: List[Union[float, int]], label: str):\n    \"\"\"\n    Add a single coarse anchor with a label and position.\n\n    Parameters:\n        label (str): The label for the anchor.\n        position (List[Union[float, int]]): The position [x, y, z] for the anchor.\n\n    Raises:\n        ValueError: If position does not contain exactly three elements.\n        TypeError: If any element in position is not a number.\n    \"\"\"\n    if not isinstance(label, str):\n        raise TypeError(\"label must be a string.\")\n    if len(position) != 3:\n        raise ValueError(\"position must be a list of three elements.\")\n    if not all(isinstance(p, (float, int)) for p in position):\n        raise TypeError(\"All position elements must be numbers.\")\n\n    self._alignment_anchors.append(\n        {\n            \"label\": label,\n            \"position\": position,\n        }\n    )\n    return self\n</code></pre>"},{"location":"nodes/aligners/CoarseAligner/#npxpy.nodes.aligners.CoarseAligner.set_coarse_anchors_at","title":"<code>set_coarse_anchors_at(positions, labels=None)</code>","text":"<p>Create multiple coarse anchors at specified positions.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>List[str]</code> <p>List of labels for the anchors.</p> <code>None</code> <code>positions</code> <code>List[List[Union[float, int]]]</code> <p>List of positions for the anchors, each position is [x, y, z].</p> required <p>Returns:</p> Name Type Description <code>self</code> <p>The instance of the CoarseAligner class.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the number of labels does not match the number of positions.</p> <code>TypeError</code> <p>If any label is not a string or any position is not a list of numbers.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def set_coarse_anchors_at(\n    self,\n    positions: List[List[Union[float, int]]],\n    labels: List[str] = None,\n):\n    \"\"\"\n    Create multiple coarse anchors at specified positions.\n\n    Parameters:\n        labels (List[str]): List of labels for the anchors.\n        positions (List[List[Union[float, int]]]): List of positions for the anchors, each position is [x, y, z].\n\n    Returns:\n        self: The instance of the CoarseAligner class.\n\n    Raises:\n        ValueError: If the number of labels does not match the number of positions.\n        TypeError: If any label is not a string or any position is not a list of numbers.\n    \"\"\"\n    if labels is None:\n        labels = [f\"anchor_{i}\" for i in range(len(positions))]\n    if len(labels) != len(positions):\n        raise ValueError(\n            \"The number of labels must match the number of positions.\"\n        )\n\n    for label in labels:\n        if not isinstance(label, str):\n            raise TypeError(\"All labels must be strings.\")\n\n    for position in positions:\n        if len(position) != 3:\n            raise ValueError(\n                \"Each position must be a list of three elements.\"\n            )\n        if not all(isinstance(p, (float, int)) for p in position):\n            raise TypeError(\"All position elements must be numbers.\")\n\n    for label, position in zip(labels, positions):\n        self.add_coarse_anchor(position, label)\n\n    return self\n</code></pre>"},{"location":"nodes/aligners/CoarseAligner/#npxpy.nodes.aligners.CoarseAligner.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the CoarseAligner object into a dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of the object.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert the CoarseAligner object into a dictionary.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of the object.\n    \"\"\"\n    node_dict = super().to_dict()  # Get basic attributes from Node\n    node_dict.update(\n        {\n            \"alignment_anchors\": self.alignment_anchors,\n            \"residual_threshold\": self.residual_threshold,\n        }\n    )\n    return node_dict\n</code></pre>"},{"location":"nodes/aligners/EdgeAligner/","title":"npxpy.nodes.aligners.EdgeAligner","text":"<p>               Bases: <code>Node</code></p> <p>A class to represent an edge aligner with various attributes and methods for managing edge alignment.</p> <p>Attributes:</p> Name Type Description <code>alignment_anchors</code> <code>List[Dict[str, Any]]</code> <p>List of alignment anchors.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>class EdgeAligner(Node):\n    \"\"\"\n    A class to represent an edge aligner with various attributes and methods for managing edge alignment.\n\n    Attributes:\n        alignment_anchors (List[Dict[str, Any]]): List of alignment anchors.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"Edge aligner\",\n        edge_location: List[float] = [0.0, 0.0],\n        edge_orientation: float = 0.0,\n        center_stage: bool = True,\n        action_upon_failure: str = \"abort\",\n        laser_power: Union[float, int] = 0.5,\n        scan_area_res_factors: List[float] = [1.0, 1.0],\n        scan_z_sample_distance: Union[float, int] = 0.1,\n        scan_z_sample_count: int = 51,\n        outlier_threshold: float = 10.0,\n    ):\n        \"\"\"\n        Initialize the edge aligner with the specified parameters.\n        \"\"\"\n        super().__init__(node_type=\"edge_alignment\", name=name)\n\n        # Set attributes using setters\n        self.edge_location = edge_location\n        self.edge_orientation = edge_orientation\n        self.center_stage = center_stage\n        self.action_upon_failure = action_upon_failure\n        self.laser_power = laser_power\n        self.scan_area_res_factors = scan_area_res_factors\n        self.scan_z_sample_distance = scan_z_sample_distance\n        self.scan_z_sample_count = scan_z_sample_count\n        self.outlier_threshold = outlier_threshold\n\n        self.alignment_anchors = []\n\n    # Property setters with validation\n    @property\n    def edge_location(self) -&gt; List[float]:\n        return self._edge_location\n\n    @edge_location.setter\n    def edge_location(self, value: List[float]):\n        if (\n            not isinstance(value, list)\n            or len(value) != 2\n            or not all(isinstance(val, (float, int)) for val in value)\n        ):\n            raise TypeError(\"edge_location must be a list of two numbers.\")\n        self._edge_location = value\n\n    @property\n    def edge_orientation(self) -&gt; float:\n        return self._edge_orientation\n\n    @edge_orientation.setter\n    def edge_orientation(self, value: float):\n        if not isinstance(value, (float, int)):\n            raise TypeError(\"edge_orientation must be a float or an int.\")\n        self._edge_orientation = value\n\n    @property\n    def center_stage(self) -&gt; bool:\n        return self._center_stage\n\n    @center_stage.setter\n    def center_stage(self, value: bool):\n        if not isinstance(value, bool):\n            raise TypeError(\"center_stage must be a boolean.\")\n        self._center_stage = value\n\n    @property\n    def action_upon_failure(self) -&gt; str:\n        return self._action_upon_failure\n\n    @action_upon_failure.setter\n    def action_upon_failure(self, value: str):\n        if value not in [\"abort\", \"ignore\"]:\n            raise ValueError(\n                \"action_upon_failure must be 'abort' or 'ignore'.\"\n            )\n        self._action_upon_failure = value\n\n    @property\n    def laser_power(self) -&gt; Union[float, int]:\n        return self._laser_power\n\n    @laser_power.setter\n    def laser_power(self, value: Union[float, int]):\n        if not isinstance(value, (float, int)) or value &lt; 0:\n            raise ValueError(\"laser_power must be a non-negative number.\")\n        self._laser_power = value\n\n    @property\n    def scan_area_res_factors(self) -&gt; List[float]:\n        return self._scan_area_res_factors\n\n    @scan_area_res_factors.setter\n    def scan_area_res_factors(self, value: List[float]):\n        if (\n            not isinstance(value, list)\n            or len(value) != 2\n            or not all(isinstance(val, (float, int)) for val in value)\n        ):\n            raise TypeError(\n                \"scan_area_res_factors must be a list of two numbers greater than zero.\"\n            )\n        if not all(factor &gt; 0 for factor in value):\n            raise ValueError(\n                \"All elements in scan_area_res_factors must be greater than 0.\"\n            )\n        self._scan_area_res_factors = value\n\n    @property\n    def scan_z_sample_distance(self) -&gt; Union[float, int]:\n        return self._scan_z_sample_distance\n\n    @scan_z_sample_distance.setter\n    def scan_z_sample_distance(self, value: Union[float, int]):\n        if not isinstance(value, (float, int)) or value &lt;= 0:\n            raise ValueError(\n                \"scan_z_sample_distance must be a positive number.\"\n            )\n        self._scan_z_sample_distance = value\n\n    @property\n    def scan_z_sample_count(self) -&gt; int:\n        return self._scan_z_sample_count\n\n    @scan_z_sample_count.setter\n    def scan_z_sample_count(self, value: int):\n        if not isinstance(value, int) or value &lt; 1:\n            raise ValueError(\n                \"scan_z_sample_count must be an integer greater than zero.\"\n            )\n        self._scan_z_sample_count = value\n\n    @property\n    def outlier_threshold(self) -&gt; float:\n        return self._outlier_threshold\n\n    @outlier_threshold.setter\n    def outlier_threshold(self, value: float):\n        if not isinstance(value, (float, int)) or not (0 &lt;= value &lt;= 100):\n            raise ValueError(\n                \"outlier_threshold must be a number between 0 and 100.\"\n            )\n        self._outlier_threshold = value\n\n    def add_measurement(\n        self,\n        offset: Union[float, int],\n        scan_area_size: List[Union[float, int]],\n        label: str,\n    ):\n        \"\"\"\n        Add a measurement with a label, offset, and scan area size.\n        \"\"\"\n        if not isinstance(label, str):\n            raise TypeError(\"label must be a string.\")\n        if not isinstance(offset, (float, int)):\n            raise TypeError(\"offset must be a float or an int.\")\n        if (\n            not isinstance(scan_area_size, list)\n            or len(scan_area_size) != 2\n            or not all(isinstance(val, (float, int)) for val in scan_area_size)\n        ):\n            raise TypeError(\"scan_area_size must be a list of two numbers.\")\n        if scan_area_size[0] &lt;= 0:\n            raise ValueError(\n                \"The width (X) in scan_area_size must be greater than 0.\"\n            )\n        if scan_area_size[1] &lt; 0:\n            raise ValueError(\n                \"The height (Y) in scan_area_size must be greater than or equal to 0.\"\n            )\n\n        self.alignment_anchors.append(\n            {\n                \"label\": label,\n                \"offset\": offset,\n                \"scan_area_size\": scan_area_size,\n            }\n        )\n        return self\n\n    def set_measurements_at(\n        self,\n        offsets: List[Union[float, int]],\n        scan_area_sizes: List[List[Union[float, int]]] = None,\n        labels: List[str] = None,\n    ):\n        \"\"\"\n        Set multiple measurements at specified positions.\n        \"\"\"\n        if scan_area_sizes is None:\n            scan_area_sizes = [[50.0, 10.0]] * len(offsets)\n        if labels is None:\n            labels = [f\"marker_{i}\" for i in range(len(offsets))]\n        if len(labels) != len(scan_area_sizes) or len(labels) != len(offsets):\n            raise ValueError(\n                \"The number of labels, offsets, and scan_area_sizes must match.\"\n            )\n\n        for label in labels:\n            if not isinstance(label, str):\n                raise TypeError(\"All labels must be strings.\")\n\n        for offset in offsets:\n            if not isinstance(offset, (float, int)):\n                raise TypeError(\"All offsets must be float or int.\")\n\n        for scan_area_size in scan_area_sizes:\n            if (\n                not isinstance(scan_area_size, list)\n                or len(scan_area_size) != 2\n                or not all(\n                    isinstance(val, (float, int)) for val in scan_area_size\n                )\n            ):\n                raise TypeError(\n                    \"All scan_area_sizes must be lists of two numbers.\"\n                )\n            if scan_area_size[0] &lt;= 0:\n                raise ValueError(\n                    \"The width (X) in scan_area_size must be greater than 0.\"\n                )\n            if scan_area_size[1] &lt; 0:\n                raise ValueError(\n                    \"The height (Y) in scan_area_size must be greater than or equal to 0.\"\n                )\n\n        for label, offset, scan_area_size in zip(\n            labels, offsets, scan_area_sizes\n        ):\n            self.add_measurement(offset, scan_area_size, label)\n        return self\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the current state of the object into a dictionary representation.\n        \"\"\"\n        node_dict = super().to_dict()\n        node_dict.update(\n            {\n                \"xy_position_local_cos\": self.edge_location,\n                \"z_rotation_local_cos\": self.edge_orientation,\n                \"center_stage\": self.center_stage,\n                \"action_upon_failure\": self.action_upon_failure,\n                \"laser_power\": self.laser_power,\n                \"scan_area_res_factors\": self.scan_area_res_factors,\n                \"scan_z_sample_distance\": self.scan_z_sample_distance,\n                \"scan_z_sample_count\": self.scan_z_sample_count,\n                \"outlier_threshold\": self.outlier_threshold,\n                \"alignment_anchors\": self.alignment_anchors,\n            }\n        )\n        return node_dict\n</code></pre>"},{"location":"nodes/aligners/EdgeAligner/#npxpy.nodes.aligners.EdgeAligner.__init__","title":"<code>__init__(name='Edge aligner', edge_location=[0.0, 0.0], edge_orientation=0.0, center_stage=True, action_upon_failure='abort', laser_power=0.5, scan_area_res_factors=[1.0, 1.0], scan_z_sample_distance=0.1, scan_z_sample_count=51, outlier_threshold=10.0)</code>","text":"<p>Initialize the edge aligner with the specified parameters.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"Edge aligner\",\n    edge_location: List[float] = [0.0, 0.0],\n    edge_orientation: float = 0.0,\n    center_stage: bool = True,\n    action_upon_failure: str = \"abort\",\n    laser_power: Union[float, int] = 0.5,\n    scan_area_res_factors: List[float] = [1.0, 1.0],\n    scan_z_sample_distance: Union[float, int] = 0.1,\n    scan_z_sample_count: int = 51,\n    outlier_threshold: float = 10.0,\n):\n    \"\"\"\n    Initialize the edge aligner with the specified parameters.\n    \"\"\"\n    super().__init__(node_type=\"edge_alignment\", name=name)\n\n    # Set attributes using setters\n    self.edge_location = edge_location\n    self.edge_orientation = edge_orientation\n    self.center_stage = center_stage\n    self.action_upon_failure = action_upon_failure\n    self.laser_power = laser_power\n    self.scan_area_res_factors = scan_area_res_factors\n    self.scan_z_sample_distance = scan_z_sample_distance\n    self.scan_z_sample_count = scan_z_sample_count\n    self.outlier_threshold = outlier_threshold\n\n    self.alignment_anchors = []\n</code></pre>"},{"location":"nodes/aligners/EdgeAligner/#npxpy.nodes.aligners.EdgeAligner.add_measurement","title":"<code>add_measurement(offset, scan_area_size, label)</code>","text":"<p>Add a measurement with a label, offset, and scan area size.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def add_measurement(\n    self,\n    offset: Union[float, int],\n    scan_area_size: List[Union[float, int]],\n    label: str,\n):\n    \"\"\"\n    Add a measurement with a label, offset, and scan area size.\n    \"\"\"\n    if not isinstance(label, str):\n        raise TypeError(\"label must be a string.\")\n    if not isinstance(offset, (float, int)):\n        raise TypeError(\"offset must be a float or an int.\")\n    if (\n        not isinstance(scan_area_size, list)\n        or len(scan_area_size) != 2\n        or not all(isinstance(val, (float, int)) for val in scan_area_size)\n    ):\n        raise TypeError(\"scan_area_size must be a list of two numbers.\")\n    if scan_area_size[0] &lt;= 0:\n        raise ValueError(\n            \"The width (X) in scan_area_size must be greater than 0.\"\n        )\n    if scan_area_size[1] &lt; 0:\n        raise ValueError(\n            \"The height (Y) in scan_area_size must be greater than or equal to 0.\"\n        )\n\n    self.alignment_anchors.append(\n        {\n            \"label\": label,\n            \"offset\": offset,\n            \"scan_area_size\": scan_area_size,\n        }\n    )\n    return self\n</code></pre>"},{"location":"nodes/aligners/EdgeAligner/#npxpy.nodes.aligners.EdgeAligner.set_measurements_at","title":"<code>set_measurements_at(offsets, scan_area_sizes=None, labels=None)</code>","text":"<p>Set multiple measurements at specified positions.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def set_measurements_at(\n    self,\n    offsets: List[Union[float, int]],\n    scan_area_sizes: List[List[Union[float, int]]] = None,\n    labels: List[str] = None,\n):\n    \"\"\"\n    Set multiple measurements at specified positions.\n    \"\"\"\n    if scan_area_sizes is None:\n        scan_area_sizes = [[50.0, 10.0]] * len(offsets)\n    if labels is None:\n        labels = [f\"marker_{i}\" for i in range(len(offsets))]\n    if len(labels) != len(scan_area_sizes) or len(labels) != len(offsets):\n        raise ValueError(\n            \"The number of labels, offsets, and scan_area_sizes must match.\"\n        )\n\n    for label in labels:\n        if not isinstance(label, str):\n            raise TypeError(\"All labels must be strings.\")\n\n    for offset in offsets:\n        if not isinstance(offset, (float, int)):\n            raise TypeError(\"All offsets must be float or int.\")\n\n    for scan_area_size in scan_area_sizes:\n        if (\n            not isinstance(scan_area_size, list)\n            or len(scan_area_size) != 2\n            or not all(\n                isinstance(val, (float, int)) for val in scan_area_size\n            )\n        ):\n            raise TypeError(\n                \"All scan_area_sizes must be lists of two numbers.\"\n            )\n        if scan_area_size[0] &lt;= 0:\n            raise ValueError(\n                \"The width (X) in scan_area_size must be greater than 0.\"\n            )\n        if scan_area_size[1] &lt; 0:\n            raise ValueError(\n                \"The height (Y) in scan_area_size must be greater than or equal to 0.\"\n            )\n\n    for label, offset, scan_area_size in zip(\n        labels, offsets, scan_area_sizes\n    ):\n        self.add_measurement(offset, scan_area_size, label)\n    return self\n</code></pre>"},{"location":"nodes/aligners/EdgeAligner/#npxpy.nodes.aligners.EdgeAligner.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the current state of the object into a dictionary representation.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the current state of the object into a dictionary representation.\n    \"\"\"\n    node_dict = super().to_dict()\n    node_dict.update(\n        {\n            \"xy_position_local_cos\": self.edge_location,\n            \"z_rotation_local_cos\": self.edge_orientation,\n            \"center_stage\": self.center_stage,\n            \"action_upon_failure\": self.action_upon_failure,\n            \"laser_power\": self.laser_power,\n            \"scan_area_res_factors\": self.scan_area_res_factors,\n            \"scan_z_sample_distance\": self.scan_z_sample_distance,\n            \"scan_z_sample_count\": self.scan_z_sample_count,\n            \"outlier_threshold\": self.outlier_threshold,\n            \"alignment_anchors\": self.alignment_anchors,\n        }\n    )\n    return node_dict\n</code></pre>"},{"location":"nodes/aligners/FiberAligner/","title":"npxpy.nodes.aligners.FiberAligner","text":"<p>               Bases: <code>Node</code></p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>class FiberAligner(Node):\n    def __init__(\n        self,\n        name: str = \"Fiber aligner\",\n        fiber_radius: Union[float, int] = 63.5,\n        center_stage: bool = True,\n        action_upon_failure: str = \"abort\",\n        illumination_name: str = \"process_led_1\",\n        core_signal_lower_threshold: Union[float, int] = 0.05,\n        core_signal_range: List[Union[float, int]] = [0.1, 0.9],\n        detection_margin: Union[float, int] = 6.35,\n    ):\n        \"\"\"\n        Initialize the fiber aligner with specified parameters.\n\n        Parameters:\n            name (str): Name of the fiber aligner.\n            fiber_radius (Union[float, int]): Radius of the fiber.\n            center_stage (bool): Whether to center the stage.\n            action_upon_failure (str): Action upon failure ('abort' or 'ignore').\n            illumination_name (str): Name of the illumination source.\n            core_signal_lower_threshold (Union[float, int]): Lower threshold for\n                the core signal.\n            core_signal_range (List[Union[float, int]]): Range for the core\n                signal [min, max].\n            detection_margin (Union[float, int]): Detection margin.\n        \"\"\"\n        super().__init__(\n            node_type=\"fiber_core_alignment\",\n            name=name,\n        )\n\n        # Use setters to handle attributes\n        self.fiber_radius = fiber_radius\n        self.center_stage = center_stage\n        self.action_upon_failure = action_upon_failure\n        self.illumination_name = illumination_name\n        self.core_signal_lower_threshold = core_signal_lower_threshold\n        self.core_signal_range = core_signal_range\n        self.detection_margin = detection_margin\n\n        # Default values using setters for consistency\n        self.detect_light_direction = False\n        self.z_scan_range = [10, 100]\n        self.z_scan_range_sample_count = 1\n        self.z_scan_range_scan_count = 1\n\n    # Proper setters with validation\n    @property\n    def fiber_radius(self) -&gt; Union[float, int]:\n        return self._fiber_radius\n\n    @fiber_radius.setter\n    def fiber_radius(self, value: Union[float, int]):\n        if not isinstance(value, (float, int)) or value &lt;= 0:\n            raise ValueError(\"fiber_radius must be a positive number.\")\n        self._fiber_radius = value\n\n    @property\n    def center_stage(self) -&gt; bool:\n        return self._center_stage\n\n    @center_stage.setter\n    def center_stage(self, value: bool):\n        if not isinstance(value, bool):\n            raise TypeError(\"center_stage must be a boolean.\")\n        self._center_stage = value\n\n    @property\n    def action_upon_failure(self) -&gt; str:\n        return self._action_upon_failure\n\n    @action_upon_failure.setter\n    def action_upon_failure(self, value: str):\n        if value not in [\"abort\", \"ignore\"]:\n            raise ValueError(\n                \"action_upon_failure must be 'abort' or 'ignore'.\"\n            )\n        self._action_upon_failure = value\n\n    @property\n    def illumination_name(self) -&gt; str:\n        return self._illumination_name\n\n    @illumination_name.setter\n    def illumination_name(self, value: str):\n        if not isinstance(value, str):\n            raise TypeError(\"illumination_name must be a string.\")\n        self._illumination_name = value\n\n    @property\n    def core_signal_lower_threshold(self) -&gt; Union[float, int]:\n        return self._core_signal_lower_threshold\n\n    @core_signal_lower_threshold.setter\n    def core_signal_lower_threshold(self, value: Union[float, int]):\n        if not isinstance(value, (float, int)):\n            raise TypeError(\n                \"core_signal_lower_threshold must be a float or an int.\"\n            )\n        self._core_signal_lower_threshold = value\n\n    @property\n    def core_signal_range(self) -&gt; List[Union[float, int]]:\n        return self._core_signal_range\n\n    @core_signal_range.setter\n    def core_signal_range(self, value: List[Union[float, int]]):\n        if not isinstance(value, list) or len(value) != 2:\n            raise ValueError(\n                \"core_signal_range must be a list of two elements.\"\n            )\n        if not all(isinstance(val, (float, int)) for val in value):\n            raise TypeError(\n                \"All elements in core_signal_range must be numbers.\"\n            )\n        self._core_signal_range = value\n\n    @property\n    def detection_margin(self) -&gt; Union[float, int]:\n        return self._detection_margin\n\n    @detection_margin.setter\n    def detection_margin(self, value: Union[float, int]):\n        if not isinstance(value, (float, int)) or value &lt;= 0:\n            raise ValueError(\"detection_margin must be a positive number.\")\n        self._detection_margin = value\n\n    @property\n    def z_scan_range(self) -&gt; List[Union[float, int]]:\n        return self._z_scan_range\n\n    @z_scan_range.setter\n    def z_scan_range(self, value: List[Union[float, int]]):\n        if (\n            not isinstance(value, list)\n            or len(value) != 2\n            or value[1] &lt;= value[0]\n        ):\n            raise ValueError(\n                \"z_scan_range must be a list of two elements where the \"\n                \"second element is greater than the first.\"\n            )\n        self._z_scan_range = value\n\n    @property\n    def z_scan_range_sample_count(self) -&gt; int:\n        return self._z_scan_range_sample_count\n\n    @z_scan_range_sample_count.setter\n    def z_scan_range_sample_count(self, value: int):\n        if not isinstance(value, int) or value &lt;= 0:\n            raise ValueError(\n                \"z_scan_range_sample_count must be a positive integer.\"\n            )\n        self._z_scan_range_sample_count = value\n\n    @property\n    def z_scan_range_scan_count(self) -&gt; int:\n        return self._z_scan_range_scan_count\n\n    @z_scan_range_scan_count.setter\n    def z_scan_range_scan_count(self, value: int):\n        if not isinstance(value, int) or value &lt;= 0:\n            raise ValueError(\n                \"z_scan_range_scan_count must be a positive integer.\"\n            )\n        self._z_scan_range_scan_count = value\n\n    def measure_tilt(\n        self,\n        z_scan_range: List[Union[float, int]] = [10, 100],\n        z_scan_range_sample_count: int = 3,\n        z_scan_range_scan_count: int = 1,\n    ):\n        \"\"\"\n        Measures tilt by setting scan range parameters.\n\n        Parameters:\n            z_scan_range (List[Union[float, int]]): Range for the z-scan.\n            z_scan_range_sample_count (int): Number of samples in the z-scan.\n            z_scan_range_scan_count (int): Number of scans in the z-scan.\n\n        Returns:\n            self: The instance of the FiberAligner class.\n\n        \"\"\"\n        self.z_scan_range = z_scan_range\n        self.z_scan_range_sample_count = z_scan_range_sample_count\n        self.z_scan_range_scan_count = z_scan_range_scan_count\n        self.detect_light_direction = True\n\n        return self\n\n    def to_dict(self) -&gt; Dict:\n        \"\"\"\n        Converts the current state of the object into a dictionary.\n\n        Returns:\n            dict: Dictionary representation of the current state of the object.\n        \"\"\"\n        node_dict = super().to_dict()\n        # Add custom attributes not covered by super().__init__()\n        node_dict.update(\n            {\n                \"fiber_radius\": self.fiber_radius,\n                \"center_stage\": self.center_stage,\n                \"action_upon_failure\": self.action_upon_failure,\n                \"illumination_name\": self.illumination_name,\n                \"core_signal_lower_threshold\": self.core_signal_lower_threshold,\n                \"core_signal_range\": self.core_signal_range,\n                \"core_position_offset_tolerance\": self.detection_margin,\n                \"detect_light_direction\": self.detect_light_direction,\n                \"z_scan_range\": self.z_scan_range,\n                \"z_scan_range_sample_count\": self.z_scan_range_sample_count,\n                \"z_scan_range_scan_count\": self.z_scan_range_scan_count,\n            }\n        )\n        return node_dict\n</code></pre>"},{"location":"nodes/aligners/FiberAligner/#npxpy.nodes.aligners.FiberAligner.__init__","title":"<code>__init__(name='Fiber aligner', fiber_radius=63.5, center_stage=True, action_upon_failure='abort', illumination_name='process_led_1', core_signal_lower_threshold=0.05, core_signal_range=[0.1, 0.9], detection_margin=6.35)</code>","text":"<p>Initialize the fiber aligner with specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the fiber aligner.</p> <code>'Fiber aligner'</code> <code>fiber_radius</code> <code>Union[float, int]</code> <p>Radius of the fiber.</p> <code>63.5</code> <code>center_stage</code> <code>bool</code> <p>Whether to center the stage.</p> <code>True</code> <code>action_upon_failure</code> <code>str</code> <p>Action upon failure ('abort' or 'ignore').</p> <code>'abort'</code> <code>illumination_name</code> <code>str</code> <p>Name of the illumination source.</p> <code>'process_led_1'</code> <code>core_signal_lower_threshold</code> <code>Union[float, int]</code> <p>Lower threshold for the core signal.</p> <code>0.05</code> <code>core_signal_range</code> <code>List[Union[float, int]]</code> <p>Range for the core signal [min, max].</p> <code>[0.1, 0.9]</code> <code>detection_margin</code> <code>Union[float, int]</code> <p>Detection margin.</p> <code>6.35</code> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"Fiber aligner\",\n    fiber_radius: Union[float, int] = 63.5,\n    center_stage: bool = True,\n    action_upon_failure: str = \"abort\",\n    illumination_name: str = \"process_led_1\",\n    core_signal_lower_threshold: Union[float, int] = 0.05,\n    core_signal_range: List[Union[float, int]] = [0.1, 0.9],\n    detection_margin: Union[float, int] = 6.35,\n):\n    \"\"\"\n    Initialize the fiber aligner with specified parameters.\n\n    Parameters:\n        name (str): Name of the fiber aligner.\n        fiber_radius (Union[float, int]): Radius of the fiber.\n        center_stage (bool): Whether to center the stage.\n        action_upon_failure (str): Action upon failure ('abort' or 'ignore').\n        illumination_name (str): Name of the illumination source.\n        core_signal_lower_threshold (Union[float, int]): Lower threshold for\n            the core signal.\n        core_signal_range (List[Union[float, int]]): Range for the core\n            signal [min, max].\n        detection_margin (Union[float, int]): Detection margin.\n    \"\"\"\n    super().__init__(\n        node_type=\"fiber_core_alignment\",\n        name=name,\n    )\n\n    # Use setters to handle attributes\n    self.fiber_radius = fiber_radius\n    self.center_stage = center_stage\n    self.action_upon_failure = action_upon_failure\n    self.illumination_name = illumination_name\n    self.core_signal_lower_threshold = core_signal_lower_threshold\n    self.core_signal_range = core_signal_range\n    self.detection_margin = detection_margin\n\n    # Default values using setters for consistency\n    self.detect_light_direction = False\n    self.z_scan_range = [10, 100]\n    self.z_scan_range_sample_count = 1\n    self.z_scan_range_scan_count = 1\n</code></pre>"},{"location":"nodes/aligners/FiberAligner/#npxpy.nodes.aligners.FiberAligner.measure_tilt","title":"<code>measure_tilt(z_scan_range=[10, 100], z_scan_range_sample_count=3, z_scan_range_scan_count=1)</code>","text":"<p>Measures tilt by setting scan range parameters.</p> <p>Parameters:</p> Name Type Description Default <code>z_scan_range</code> <code>List[Union[float, int]]</code> <p>Range for the z-scan.</p> <code>[10, 100]</code> <code>z_scan_range_sample_count</code> <code>int</code> <p>Number of samples in the z-scan.</p> <code>3</code> <code>z_scan_range_scan_count</code> <code>int</code> <p>Number of scans in the z-scan.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>self</code> <p>The instance of the FiberAligner class.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def measure_tilt(\n    self,\n    z_scan_range: List[Union[float, int]] = [10, 100],\n    z_scan_range_sample_count: int = 3,\n    z_scan_range_scan_count: int = 1,\n):\n    \"\"\"\n    Measures tilt by setting scan range parameters.\n\n    Parameters:\n        z_scan_range (List[Union[float, int]]): Range for the z-scan.\n        z_scan_range_sample_count (int): Number of samples in the z-scan.\n        z_scan_range_scan_count (int): Number of scans in the z-scan.\n\n    Returns:\n        self: The instance of the FiberAligner class.\n\n    \"\"\"\n    self.z_scan_range = z_scan_range\n    self.z_scan_range_sample_count = z_scan_range_sample_count\n    self.z_scan_range_scan_count = z_scan_range_scan_count\n    self.detect_light_direction = True\n\n    return self\n</code></pre>"},{"location":"nodes/aligners/FiberAligner/#npxpy.nodes.aligners.FiberAligner.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the current state of the object into a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict</code> <p>Dictionary representation of the current state of the object.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n    \"\"\"\n    Converts the current state of the object into a dictionary.\n\n    Returns:\n        dict: Dictionary representation of the current state of the object.\n    \"\"\"\n    node_dict = super().to_dict()\n    # Add custom attributes not covered by super().__init__()\n    node_dict.update(\n        {\n            \"fiber_radius\": self.fiber_radius,\n            \"center_stage\": self.center_stage,\n            \"action_upon_failure\": self.action_upon_failure,\n            \"illumination_name\": self.illumination_name,\n            \"core_signal_lower_threshold\": self.core_signal_lower_threshold,\n            \"core_signal_range\": self.core_signal_range,\n            \"core_position_offset_tolerance\": self.detection_margin,\n            \"detect_light_direction\": self.detect_light_direction,\n            \"z_scan_range\": self.z_scan_range,\n            \"z_scan_range_sample_count\": self.z_scan_range_sample_count,\n            \"z_scan_range_scan_count\": self.z_scan_range_scan_count,\n        }\n    )\n    return node_dict\n</code></pre>"},{"location":"nodes/aligners/InterfaceAligner/","title":"npxpy.nodes.aligners.InterfaceAligner","text":"<p>               Bases: <code>Node</code></p> <p>A class representing an interface aligner node, responsible for managing alignment settings and grid patterns for various operations.</p> <p>Attributes:</p> Name Type Description <code>alignment_anchors</code> <code>List[Dict]</code> <p>Stores the measurement locations (or interface anchors) for interface alignment.</p> <code>count</code> <code>List[int]</code> <p>The number of grid points in [x, y] direction.</p> <code>size</code> <code>List[float]</code> <p>The size of the grid in [width, height].</p> <code>pattern</code> <code>str</code> <p>The pattern used for grid or custom alignment.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>class InterfaceAligner(Node):\n    \"\"\"\n    A class representing an interface aligner node, responsible for managing\n    alignment settings and grid patterns for various operations.\n\n    Attributes:\n        alignment_anchors (List[Dict]): Stores the measurement locations (or interface anchors) for interface alignment.\n        count (List[int]): The number of grid points in [x, y] direction.\n        size (List[float]): The size of the grid in [width, height].\n        pattern (str): The pattern used for grid or custom alignment.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"Interface aligner\",\n        signal_type: str = \"auto\",\n        detector_type: str = \"auto\",\n        measure_tilt: bool = False,\n        area_measurement: bool = False,\n        center_stage: bool = True,\n        action_upon_failure: str = \"abort\",\n        laser_power: float = 0.5,\n        scan_area_res_factors: List[float] = [1.0, 1.0],\n        scan_z_sample_distance: float = 0.1,\n        scan_z_sample_count: int = 51,\n    ):\n        \"\"\"\n        Initializes an InterfaceAligner node with specified settings.\n\n        Parameters:\n            name (str): Name of the interface aligner. Defaults to \"Interface aligner\".\n            signal_type (str): The type of signal. Can be 'auto', 'fluorescence', or 'reflection'. Defaults to 'auto'.\n            detector_type (str): The type of detector. Can be 'auto', 'confocal', 'camera', or 'camera_legacy'. Defaults to 'auto'.\n            measure_tilt (bool): Whether to measure tilt. Defaults to False.\n            area_measurement (bool): Whether to measure the area. Defaults to False.\n            center_stage (bool): Whether to center the stage. Defaults to True.\n            action_upon_failure (str): Action upon failure, can be 'abort' or 'ignore'. Defaults to 'abort'.\n            laser_power (float): The power of the laser. Must be a positive number. Defaults to 0.5.\n            scan_area_res_factors (List[float]): Resolution factors for the scan area. Defaults to [1.0, 1.0].\n            scan_z_sample_distance (float): Distance between samples in the z-direction. Defaults to 0.1.\n            scan_z_sample_count (int): Number of samples in the z-direction. Must be greater than 0. Defaults to 51.\n\n        Raises:\n            ValueError: If any input is not valid (e.g., invalid types or constraints like negative values).\n        \"\"\"\n        super().__init__(\"interface_alignment\", name)\n\n        # Use setters for validation\n        self.signal_type = signal_type\n        self.detector_type = detector_type\n        self.measure_tilt = measure_tilt\n        self.area_measurement = area_measurement\n        self.center_stage = center_stage\n        self.action_upon_failure = action_upon_failure\n        self.laser_power = laser_power\n        self.scan_area_res_factors = scan_area_res_factors\n        self.scan_z_sample_distance = scan_z_sample_distance\n        self.scan_z_sample_count = scan_z_sample_count\n\n        self.alignment_anchors = []\n        self.count = [5, 5]\n        self.size = [200.0, 200.0]\n        self.pattern = \"Origin\"\n\n    # Setters with validation for various attributes\n\n    @property\n    def signal_type(self):\n        return self._signal_type\n\n    @signal_type.setter\n    def signal_type(self, value: str):\n        valid_types = [\"auto\", \"fluorescence\", \"reflection\"]\n        if value not in valid_types:\n            raise ValueError(f\"signal_type must be one of {valid_types}.\")\n        self._signal_type = value\n\n    @property\n    def detector_type(self):\n        return self._detector_type\n\n    @detector_type.setter\n    def detector_type(self, value: str):\n        valid_detectors = [\"auto\", \"confocal\", \"camera\", \"camera_legacy\"]\n        if value not in valid_detectors:\n            raise ValueError(\n                f\"detector_type must be one of {valid_detectors}.\"\n            )\n        self._detector_type = value\n\n    @property\n    def measure_tilt(self):\n        return self._measure_tilt\n\n    @measure_tilt.setter\n    def measure_tilt(self, value: bool):\n        if not isinstance(value, bool):\n            raise TypeError(\"measure_tilt must be a boolean.\")\n        self._measure_tilt = value\n\n    @property\n    def area_measurement(self):\n        return self._area_measurement\n\n    @area_measurement.setter\n    def area_measurement(self, value: bool):\n        if not isinstance(value, bool):\n            raise TypeError(\"area_measurement must be a boolean.\")\n        self._area_measurement = value\n\n    @property\n    def center_stage(self):\n        return self._center_stage\n\n    @center_stage.setter\n    def center_stage(self, value: bool):\n        if not isinstance(value, bool):\n            raise TypeError(\"center_stage must be a boolean.\")\n        self._center_stage = value\n\n    @property\n    def action_upon_failure(self):\n        return self._action_upon_failure\n\n    @action_upon_failure.setter\n    def action_upon_failure(self, value: str):\n        valid_actions = [\"abort\", \"ignore\"]\n        if value not in valid_actions:\n            raise ValueError(\n                f\"action_upon_failure must be one of {valid_actions}.\"\n            )\n        self._action_upon_failure = value\n\n    @property\n    def laser_power(self):\n        return self._laser_power\n\n    @laser_power.setter\n    def laser_power(self, value: float):\n        if not isinstance(value, (float, int)) or value &lt;= 0:\n            raise ValueError(\"laser_power must be a positive number.\")\n        self._laser_power = value\n\n    @property\n    def scan_area_res_factors(self):\n        return self._scan_area_res_factors\n\n    @scan_area_res_factors.setter\n    def scan_area_res_factors(self, value: List[float]):\n        if len(value) != 2 or not all(\n            isinstance(f, (float, int)) for f in value\n        ):\n            raise TypeError(\n                \"scan_area_res_factors must be a list of two floats or ints.\"\n            )\n        self._scan_area_res_factors = value\n\n    @property\n    def scan_z_sample_distance(self):\n        return self._scan_z_sample_distance\n\n    @scan_z_sample_distance.setter\n    def scan_z_sample_distance(self, value: float):\n        if not isinstance(value, (float, int)):\n            raise TypeError(\n                \"scan_z_sample_distance must be a float or an int.\"\n            )\n        self._scan_z_sample_distance = value\n\n    @property\n    def scan_z_sample_count(self):\n        return self._scan_z_sample_count\n\n    @scan_z_sample_count.setter\n    def scan_z_sample_count(self, value: int):\n        if not isinstance(value, int) or value &lt; 1:\n            raise ValueError(\n                \"scan_z_sample_count must be an integer greater than 0.\"\n            )\n        self._scan_z_sample_count = value\n\n    @property\n    def count(self):\n        return self._count\n\n    @count.setter\n    def count(self, value: List[int]):\n        if len(value) != 2 or not all(isinstance(c, int) for c in value):\n            raise ValueError(\"count must be a list of two integers.\")\n        self._count = value\n\n    @property\n    def size(self):\n        return self._size\n\n    @size.setter\n    def size(self, value: List[float]):\n        if len(value) != 2 or not all(\n            isinstance(s, (float, int)) for s in value\n        ):\n            raise ValueError(\"size must be a list of two numbers.\")\n        self._size = value\n\n    @property\n    def pattern(self):\n        return self._pattern\n\n    @pattern.setter\n    def pattern(self, value: str):\n        if value not in [\"Grid\", \"Custom\", \"Origin\"]:\n            raise ValueError(\"pattern must be 'Grid', 'Custom', or 'Origin'.\")\n        self._pattern = value\n\n    def set_grid(self, count: List[int], size: List[float]):\n        \"\"\"\n        Sets the grid point count and grid size for alignment operations.\n\n        Parameters:\n            count (List[int]): Number of grid points in [x, y] direction. Must contain exactly two integers.\n            size (List[float]): Size of the grid in [width, height]. Must contain exactly two numbers.\n\n        Returns:\n            self: The instance of the InterfaceAligner class.\n\n        Raises:\n            ValueError: If count or size does not contain exactly two elements.\n            TypeError: If elements in count or size are not numbers.\n        \"\"\"\n        self.count = count\n        self.size = size\n        self.pattern = \"Grid\"\n        return self\n\n    def add_interface_anchor(\n        self,\n        position: List[float],\n        label: str,\n        scan_area_size: List[float] = None,\n    ):\n        \"\"\"\n        Adds a custom interface anchor with a label, position, and optional scan area size.\n\n        Parameters:\n            label (str): The label for the anchor. Must be a string.\n            position (List[float]): The position of the anchor [x, y]. Must contain exactly two numbers.\n            scan_area_size (List[float], optional): The scan area size [width, height]. Defaults to [10.0, 10.0].\n\n        Raises:\n            ValueError: If position does not contain exactly two elements.\n            TypeError: If label is not a string or elements in position or scan_area_size are not numbers.\n        \"\"\"\n        if not isinstance(position, list) or len(position) != 2:\n            try:\n                position = list(position)\n                position = position[:2]\n                assert len(position) == 2\n            except:\n                raise ValueError(\"position must be a list of two elements.\")\n        if not all(isinstance(p, (float, int)) for p in position):\n            try:\n                position = [float(p) for p in position]\n            except:\n                raise TypeError(\"All position elements must be numbers.\")\n        if scan_area_size is None:\n            scan_area_size = [10.0, 10.0]\n\n        self.pattern = \"Custom\"\n        self.alignment_anchors.append(\n            {\n                \"label\": label,\n                \"position\": position,\n                \"scan_area_size\": scan_area_size,\n            }\n        )\n        return self\n\n    def set_interface_anchors_at(\n        self,\n        positions: List[List[float]],\n        labels: List[str] = None,\n        scan_area_sizes: List[List[float]] = None,\n    ):\n        \"\"\"\n        Creates multiple custom interface anchors at specified positions.\n\n        Parameters:\n            labels (List[str]): List of labels for the measurement locations.\n            positions (List[List[float]]): List of positions for the measurement locations, each position is [x, y].\n            scan_area_sizes (List[List[float]], optional): List of scan area sizes for the measurement locations,\n                                                           each scan area size is [width, height]. Defaults to [10.0, 10.0]\n                                                           for each anchor.\n\n        Returns:\n            self: The instance of the InterfaceAligner class.\n\n        Raises:\n            ValueError: If the number of labels does not match the number of positions.\n            TypeError: If elements in labels, positions, or scan_area_sizes are not of the correct types.\n        \"\"\"\n        if scan_area_sizes is None:\n            scan_area_sizes = [[10.0, 10.0]] * len(positions)\n        if labels is None:\n            labels = [f\"anchor_{i}\" for i in range(len(positions))]\n        for label, position, scan_area_size in zip(\n            labels, positions, scan_area_sizes\n        ):\n            self.add_interface_anchor(position, label, scan_area_size)\n\n        return self\n\n    def to_dict(self) -&gt; Dict:\n        \"\"\"\n        Converts the current state of the object into a dictionary representation.\n\n        Returns:\n            dict: Dictionary representation of the current state of the object, including\n                  alignment anchors, grid settings, and signal properties.\n        \"\"\"\n        node_dict = super().to_dict()\n        if self.signal_type == \"auto\" or self.detector_type == \"camera_legacy\":\n            node_dict[\"interface_finder_type\"] = self.signal_type\n        else:\n            node_dict[\"interface_finder_type\"] = (\n                f\"{self.signal_type}_{self.detector_type}\"\n            )\n        node_dict[\"properties\"] = {\n            \"signal_type\": self.signal_type,\n            \"detector_type\": self.detector_type,\n        }\n        node_dict[\"alignment_anchors\"] = self.alignment_anchors\n        node_dict[\"grid_point_count\"] = self.count\n        node_dict[\"grid_size\"] = self.size\n        node_dict[\"pattern\"] = self.pattern\n        node_dict[\"measure_tilt\"] = self.measure_tilt\n        node_dict[\"area_measurement\"] = self.area_measurement\n        node_dict[\"center_stage\"] = self.center_stage\n        node_dict[\"action_upon_failure\"] = self.action_upon_failure\n        node_dict[\"laser_power\"] = self.laser_power\n        node_dict[\"scan_area_res_factors\"] = self.scan_area_res_factors\n        node_dict[\"scan_z_sample_distance\"] = self.scan_z_sample_distance\n        node_dict[\"scan_z_sample_count\"] = self.scan_z_sample_count\n        return node_dict\n</code></pre>"},{"location":"nodes/aligners/InterfaceAligner/#npxpy.nodes.aligners.InterfaceAligner.__init__","title":"<code>__init__(name='Interface aligner', signal_type='auto', detector_type='auto', measure_tilt=False, area_measurement=False, center_stage=True, action_upon_failure='abort', laser_power=0.5, scan_area_res_factors=[1.0, 1.0], scan_z_sample_distance=0.1, scan_z_sample_count=51)</code>","text":"<p>Initializes an InterfaceAligner node with specified settings.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the interface aligner. Defaults to \"Interface aligner\".</p> <code>'Interface aligner'</code> <code>signal_type</code> <code>str</code> <p>The type of signal. Can be 'auto', 'fluorescence', or 'reflection'. Defaults to 'auto'.</p> <code>'auto'</code> <code>detector_type</code> <code>str</code> <p>The type of detector. Can be 'auto', 'confocal', 'camera', or 'camera_legacy'. Defaults to 'auto'.</p> <code>'auto'</code> <code>measure_tilt</code> <code>bool</code> <p>Whether to measure tilt. Defaults to False.</p> <code>False</code> <code>area_measurement</code> <code>bool</code> <p>Whether to measure the area. Defaults to False.</p> <code>False</code> <code>center_stage</code> <code>bool</code> <p>Whether to center the stage. Defaults to True.</p> <code>True</code> <code>action_upon_failure</code> <code>str</code> <p>Action upon failure, can be 'abort' or 'ignore'. Defaults to 'abort'.</p> <code>'abort'</code> <code>laser_power</code> <code>float</code> <p>The power of the laser. Must be a positive number. Defaults to 0.5.</p> <code>0.5</code> <code>scan_area_res_factors</code> <code>List[float]</code> <p>Resolution factors for the scan area. Defaults to [1.0, 1.0].</p> <code>[1.0, 1.0]</code> <code>scan_z_sample_distance</code> <code>float</code> <p>Distance between samples in the z-direction. Defaults to 0.1.</p> <code>0.1</code> <code>scan_z_sample_count</code> <code>int</code> <p>Number of samples in the z-direction. Must be greater than 0. Defaults to 51.</p> <code>51</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any input is not valid (e.g., invalid types or constraints like negative values).</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"Interface aligner\",\n    signal_type: str = \"auto\",\n    detector_type: str = \"auto\",\n    measure_tilt: bool = False,\n    area_measurement: bool = False,\n    center_stage: bool = True,\n    action_upon_failure: str = \"abort\",\n    laser_power: float = 0.5,\n    scan_area_res_factors: List[float] = [1.0, 1.0],\n    scan_z_sample_distance: float = 0.1,\n    scan_z_sample_count: int = 51,\n):\n    \"\"\"\n    Initializes an InterfaceAligner node with specified settings.\n\n    Parameters:\n        name (str): Name of the interface aligner. Defaults to \"Interface aligner\".\n        signal_type (str): The type of signal. Can be 'auto', 'fluorescence', or 'reflection'. Defaults to 'auto'.\n        detector_type (str): The type of detector. Can be 'auto', 'confocal', 'camera', or 'camera_legacy'. Defaults to 'auto'.\n        measure_tilt (bool): Whether to measure tilt. Defaults to False.\n        area_measurement (bool): Whether to measure the area. Defaults to False.\n        center_stage (bool): Whether to center the stage. Defaults to True.\n        action_upon_failure (str): Action upon failure, can be 'abort' or 'ignore'. Defaults to 'abort'.\n        laser_power (float): The power of the laser. Must be a positive number. Defaults to 0.5.\n        scan_area_res_factors (List[float]): Resolution factors for the scan area. Defaults to [1.0, 1.0].\n        scan_z_sample_distance (float): Distance between samples in the z-direction. Defaults to 0.1.\n        scan_z_sample_count (int): Number of samples in the z-direction. Must be greater than 0. Defaults to 51.\n\n    Raises:\n        ValueError: If any input is not valid (e.g., invalid types or constraints like negative values).\n    \"\"\"\n    super().__init__(\"interface_alignment\", name)\n\n    # Use setters for validation\n    self.signal_type = signal_type\n    self.detector_type = detector_type\n    self.measure_tilt = measure_tilt\n    self.area_measurement = area_measurement\n    self.center_stage = center_stage\n    self.action_upon_failure = action_upon_failure\n    self.laser_power = laser_power\n    self.scan_area_res_factors = scan_area_res_factors\n    self.scan_z_sample_distance = scan_z_sample_distance\n    self.scan_z_sample_count = scan_z_sample_count\n\n    self.alignment_anchors = []\n    self.count = [5, 5]\n    self.size = [200.0, 200.0]\n    self.pattern = \"Origin\"\n</code></pre>"},{"location":"nodes/aligners/InterfaceAligner/#npxpy.nodes.aligners.InterfaceAligner.add_interface_anchor","title":"<code>add_interface_anchor(position, label, scan_area_size=None)</code>","text":"<p>Adds a custom interface anchor with a label, position, and optional scan area size.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label for the anchor. Must be a string.</p> required <code>position</code> <code>List[float]</code> <p>The position of the anchor [x, y]. Must contain exactly two numbers.</p> required <code>scan_area_size</code> <code>List[float]</code> <p>The scan area size [width, height]. Defaults to [10.0, 10.0].</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If position does not contain exactly two elements.</p> <code>TypeError</code> <p>If label is not a string or elements in position or scan_area_size are not numbers.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def add_interface_anchor(\n    self,\n    position: List[float],\n    label: str,\n    scan_area_size: List[float] = None,\n):\n    \"\"\"\n    Adds a custom interface anchor with a label, position, and optional scan area size.\n\n    Parameters:\n        label (str): The label for the anchor. Must be a string.\n        position (List[float]): The position of the anchor [x, y]. Must contain exactly two numbers.\n        scan_area_size (List[float], optional): The scan area size [width, height]. Defaults to [10.0, 10.0].\n\n    Raises:\n        ValueError: If position does not contain exactly two elements.\n        TypeError: If label is not a string or elements in position or scan_area_size are not numbers.\n    \"\"\"\n    if not isinstance(position, list) or len(position) != 2:\n        try:\n            position = list(position)\n            position = position[:2]\n            assert len(position) == 2\n        except:\n            raise ValueError(\"position must be a list of two elements.\")\n    if not all(isinstance(p, (float, int)) for p in position):\n        try:\n            position = [float(p) for p in position]\n        except:\n            raise TypeError(\"All position elements must be numbers.\")\n    if scan_area_size is None:\n        scan_area_size = [10.0, 10.0]\n\n    self.pattern = \"Custom\"\n    self.alignment_anchors.append(\n        {\n            \"label\": label,\n            \"position\": position,\n            \"scan_area_size\": scan_area_size,\n        }\n    )\n    return self\n</code></pre>"},{"location":"nodes/aligners/InterfaceAligner/#npxpy.nodes.aligners.InterfaceAligner.set_grid","title":"<code>set_grid(count, size)</code>","text":"<p>Sets the grid point count and grid size for alignment operations.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>List[int]</code> <p>Number of grid points in [x, y] direction. Must contain exactly two integers.</p> required <code>size</code> <code>List[float]</code> <p>Size of the grid in [width, height]. Must contain exactly two numbers.</p> required <p>Returns:</p> Name Type Description <code>self</code> <p>The instance of the InterfaceAligner class.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If count or size does not contain exactly two elements.</p> <code>TypeError</code> <p>If elements in count or size are not numbers.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def set_grid(self, count: List[int], size: List[float]):\n    \"\"\"\n    Sets the grid point count and grid size for alignment operations.\n\n    Parameters:\n        count (List[int]): Number of grid points in [x, y] direction. Must contain exactly two integers.\n        size (List[float]): Size of the grid in [width, height]. Must contain exactly two numbers.\n\n    Returns:\n        self: The instance of the InterfaceAligner class.\n\n    Raises:\n        ValueError: If count or size does not contain exactly two elements.\n        TypeError: If elements in count or size are not numbers.\n    \"\"\"\n    self.count = count\n    self.size = size\n    self.pattern = \"Grid\"\n    return self\n</code></pre>"},{"location":"nodes/aligners/InterfaceAligner/#npxpy.nodes.aligners.InterfaceAligner.set_interface_anchors_at","title":"<code>set_interface_anchors_at(positions, labels=None, scan_area_sizes=None)</code>","text":"<p>Creates multiple custom interface anchors at specified positions.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>List[str]</code> <p>List of labels for the measurement locations.</p> <code>None</code> <code>positions</code> <code>List[List[float]]</code> <p>List of positions for the measurement locations, each position is [x, y].</p> required <code>scan_area_sizes</code> <code>List[List[float]]</code> <p>List of scan area sizes for the measurement locations,                                            each scan area size is [width, height]. Defaults to [10.0, 10.0]                                            for each anchor.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>self</code> <p>The instance of the InterfaceAligner class.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the number of labels does not match the number of positions.</p> <code>TypeError</code> <p>If elements in labels, positions, or scan_area_sizes are not of the correct types.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def set_interface_anchors_at(\n    self,\n    positions: List[List[float]],\n    labels: List[str] = None,\n    scan_area_sizes: List[List[float]] = None,\n):\n    \"\"\"\n    Creates multiple custom interface anchors at specified positions.\n\n    Parameters:\n        labels (List[str]): List of labels for the measurement locations.\n        positions (List[List[float]]): List of positions for the measurement locations, each position is [x, y].\n        scan_area_sizes (List[List[float]], optional): List of scan area sizes for the measurement locations,\n                                                       each scan area size is [width, height]. Defaults to [10.0, 10.0]\n                                                       for each anchor.\n\n    Returns:\n        self: The instance of the InterfaceAligner class.\n\n    Raises:\n        ValueError: If the number of labels does not match the number of positions.\n        TypeError: If elements in labels, positions, or scan_area_sizes are not of the correct types.\n    \"\"\"\n    if scan_area_sizes is None:\n        scan_area_sizes = [[10.0, 10.0]] * len(positions)\n    if labels is None:\n        labels = [f\"anchor_{i}\" for i in range(len(positions))]\n    for label, position, scan_area_size in zip(\n        labels, positions, scan_area_sizes\n    ):\n        self.add_interface_anchor(position, label, scan_area_size)\n\n    return self\n</code></pre>"},{"location":"nodes/aligners/InterfaceAligner/#npxpy.nodes.aligners.InterfaceAligner.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the current state of the object into a dictionary representation.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict</code> <p>Dictionary representation of the current state of the object, including   alignment anchors, grid settings, and signal properties.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n    \"\"\"\n    Converts the current state of the object into a dictionary representation.\n\n    Returns:\n        dict: Dictionary representation of the current state of the object, including\n              alignment anchors, grid settings, and signal properties.\n    \"\"\"\n    node_dict = super().to_dict()\n    if self.signal_type == \"auto\" or self.detector_type == \"camera_legacy\":\n        node_dict[\"interface_finder_type\"] = self.signal_type\n    else:\n        node_dict[\"interface_finder_type\"] = (\n            f\"{self.signal_type}_{self.detector_type}\"\n        )\n    node_dict[\"properties\"] = {\n        \"signal_type\": self.signal_type,\n        \"detector_type\": self.detector_type,\n    }\n    node_dict[\"alignment_anchors\"] = self.alignment_anchors\n    node_dict[\"grid_point_count\"] = self.count\n    node_dict[\"grid_size\"] = self.size\n    node_dict[\"pattern\"] = self.pattern\n    node_dict[\"measure_tilt\"] = self.measure_tilt\n    node_dict[\"area_measurement\"] = self.area_measurement\n    node_dict[\"center_stage\"] = self.center_stage\n    node_dict[\"action_upon_failure\"] = self.action_upon_failure\n    node_dict[\"laser_power\"] = self.laser_power\n    node_dict[\"scan_area_res_factors\"] = self.scan_area_res_factors\n    node_dict[\"scan_z_sample_distance\"] = self.scan_z_sample_distance\n    node_dict[\"scan_z_sample_count\"] = self.scan_z_sample_count\n    return node_dict\n</code></pre>"},{"location":"nodes/aligners/MarkerAligner/","title":"npxpy.nodes.aligners.MarkerAligner","text":"<p>               Bases: <code>Node</code></p> <p>Marker aligner class.</p> <p>Attributes:</p> Name Type Description <code>image</code> <code>Resources</code> <p>Image object that the marker gets assigned.</p> <code>name</code> <code>str</code> <p>Name of the marker aligner.</p> <code>marker_size</code> <code>List[float]</code> <p>Size of markers in micrometers. Marker size must be greater than 0.</p> <code>center_stage</code> <code>bool</code> <p>Centers stage if true.</p> <code>action_upon_failure</code> <code>str</code> <p>'abort' or 'ignore' at failure (not yet implemented!).</p> <code>laser_power</code> <code>float</code> <p>Laser power in mW.</p> <code>scan_area_size</code> <code>List[float]</code> <p>Scan area size in micrometers.</p> <code>scan_area_res_factors</code> <code>List[float]</code> <p>Resolution factors in scanned area.</p> <code>detection_margin</code> <code>float</code> <p>Additional margin around marker imaging field in micrometers.</p> <code>correlation_threshold</code> <code>float</code> <p>Correlation threshold below which abort is triggered in percent.</p> <code>residual_threshold</code> <code>float</code> <p>Residual threshold of marker image.</p> <code>max_outliers</code> <code>int</code> <p>Maximum amount of markers that are allowed to be outliers.</p> <code>orthonormalize</code> <code>bool</code> <p>Whether to orthonormalize or not.</p> <code>z_scan_sample_count</code> <code>int</code> <p>Number of z samples to be taken.</p> <code>z_scan_sample_distance</code> <code>float</code> <p>Sampling distance in micrometers for z samples to be apart from each other.</p> <code>z_scan_sample_mode</code> <code>str</code> <p>\"correlation\" or \"intensity\" for scan_z_sample_mode.</p> <code>measure_z</code> <code>bool</code> <p>Whether to measure z or not.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>class MarkerAligner(Node):\n    \"\"\"\n    Marker aligner class.\n\n    Attributes:\n        image (Resources): Image object that the marker gets assigned.\n        name (str): Name of the marker aligner.\n        marker_size (List[float]): Size of markers in micrometers. Marker size must be greater than 0.\n        center_stage (bool): Centers stage if true.\n        action_upon_failure (str): 'abort' or 'ignore' at failure (not yet implemented!).\n        laser_power (float): Laser power in mW.\n        scan_area_size (List[float]): Scan area size in micrometers.\n        scan_area_res_factors (List[float]): Resolution factors in scanned area.\n        detection_margin (float): Additional margin around marker imaging field in micrometers.\n        correlation_threshold (float): Correlation threshold below which abort is triggered in percent.\n        residual_threshold (float): Residual threshold of marker image.\n        max_outliers (int): Maximum amount of markers that are allowed to be outliers.\n        orthonormalize (bool): Whether to orthonormalize or not.\n        z_scan_sample_count (int): Number of z samples to be taken.\n        z_scan_sample_distance (float): Sampling distance in micrometers for z samples to be apart from each other.\n        z_scan_sample_mode (str): \"correlation\" or \"intensity\" for scan_z_sample_mode.\n        measure_z (bool): Whether to measure z or not.\n    \"\"\"\n\n    def __init__(\n        self,\n        image: Image,\n        name: str = \"Marker aligner\",\n        marker_size: List[float] = [5.0, 5.0],\n        center_stage: bool = True,\n        action_upon_failure: str = \"abort\",\n        laser_power: float = 0.5,\n        scan_area_size: List[float] = [10.0, 10.0],\n        scan_area_res_factors: List[float] = [2.0, 2.0],\n        detection_margin: float = 5.0,\n        correlation_threshold: float = 60.0,\n        residual_threshold: float = 0.5,\n        max_outliers: int = 0,\n        orthonormalize: bool = True,\n        z_scan_sample_count: int = 1,\n        z_scan_sample_distance: float = 0.5,\n        z_scan_sample_mode: str = \"correlation\",\n        measure_z: bool = False,\n    ):\n        \"\"\"\n        Initializes the MarkerAligner with the provided parameters.\n        \"\"\"\n        super().__init__(node_type=\"marker_alignment\", name=name)\n\n        # Set attributes via setters\n        self.image = image\n        self.marker_size = marker_size\n        self.center_stage = center_stage\n        self.action_upon_failure = action_upon_failure\n        self.laser_power = laser_power\n        self.scan_area_size = scan_area_size\n        self.scan_area_res_factors = scan_area_res_factors\n        self.detection_margin = detection_margin\n        self.correlation_threshold = correlation_threshold\n        self.residual_threshold = residual_threshold\n        self.max_outliers = max_outliers\n        self.orthonormalize = orthonormalize\n        self.z_scan_sample_count = z_scan_sample_count\n        self.z_scan_sample_distance = z_scan_sample_distance\n        self.z_scan_sample_mode = z_scan_sample_mode\n        self.measure_z = measure_z\n\n        self.alignment_anchors = []\n\n    # Property setters with validation\n    @property\n    def image(self) -&gt; Image:\n        return self._image\n\n    @image.setter\n    def image(self, value: Image):\n        if not isinstance(value, Image):\n            raise TypeError(\"image must be an instance of Image class.\")\n        self._image = value\n\n    @property\n    def marker_size(self) -&gt; List[float]:\n        return self._marker_size\n\n    @marker_size.setter\n    def marker_size(self, value: List[float]):\n        if (\n            not isinstance(value, list)\n            or len(value) != 2\n            or not all(isinstance(val, (float, int)) for val in value)\n        ):\n            raise TypeError(\n                \"marker_size must be a list of two positive numbers.\"\n            )\n        if value[0] &lt;= 0 or value[1] &lt;= 0:\n            raise ValueError(\"marker_size must be greater than 0.\")\n        self._marker_size = value\n\n    @property\n    def center_stage(self) -&gt; bool:\n        return self._center_stage\n\n    @center_stage.setter\n    def center_stage(self, value: bool):\n        if not isinstance(value, bool):\n            raise TypeError(\"center_stage must be a boolean.\")\n        self._center_stage = value\n\n    @property\n    def action_upon_failure(self) -&gt; str:\n        return self._action_upon_failure\n\n    @action_upon_failure.setter\n    def action_upon_failure(self, value: str):\n        if value not in [\"abort\", \"ignore\"]:\n            raise ValueError(\n                \"action_upon_failure must be 'abort' or 'ignore'.\"\n            )\n        self._action_upon_failure = value\n\n    @property\n    def laser_power(self) -&gt; float:\n        return self._laser_power\n\n    @laser_power.setter\n    def laser_power(self, value: float):\n        if not isinstance(value, (float, int)) or value &lt; 0:\n            raise ValueError(\"laser_power must be a non-negative number.\")\n        self._laser_power = value\n\n    @property\n    def scan_area_size(self) -&gt; List[float]:\n        return self._scan_area_size\n\n    @scan_area_size.setter\n    def scan_area_size(self, value: List[float]):\n        if (\n            not isinstance(value, list)\n            or len(value) != 2\n            or not all(isinstance(val, (float, int)) for val in value)\n        ):\n            raise TypeError(\"scan_area_size must be a list of two numbers.\")\n        self._scan_area_size = value\n\n    @property\n    def scan_area_res_factors(self) -&gt; List[float]:\n        return self._scan_area_res_factors\n\n    @scan_area_res_factors.setter\n    def scan_area_res_factors(self, value: List[float]):\n        if (\n            not isinstance(value, list)\n            or len(value) != 2\n            or not all(isinstance(val, (float, int)) for val in value)\n        ):\n            raise TypeError(\n                \"scan_area_res_factors must be a list of two numbers.\"\n            )\n        self._scan_area_res_factors = value\n\n    @property\n    def detection_margin(self) -&gt; float:\n        return self._detection_margin\n\n    @detection_margin.setter\n    def detection_margin(self, value: float):\n        if not isinstance(value, (float, int)) or value &lt; 0:\n            raise ValueError(\"detection_margin must be a non-negative number.\")\n        self._detection_margin = value\n\n    @property\n    def correlation_threshold(self) -&gt; float:\n        return self._correlation_threshold\n\n    @correlation_threshold.setter\n    def correlation_threshold(self, value: float):\n        if not isinstance(value, (float, int)) or not (0 &lt;= value &lt;= 100):\n            raise ValueError(\n                \"correlation_threshold must be between 0 and 100.\"\n            )\n        self._correlation_threshold = value\n\n    @property\n    def residual_threshold(self) -&gt; float:\n        return self._residual_threshold\n\n    @residual_threshold.setter\n    def residual_threshold(self, value: float):\n        if not isinstance(value, (float, int)) or value &lt; 0:\n            raise ValueError(\n                \"residual_threshold must be a non-negative number.\"\n            )\n        self._residual_threshold = value\n\n    @property\n    def max_outliers(self) -&gt; int:\n        return self._max_outliers\n\n    @max_outliers.setter\n    def max_outliers(self, value: int):\n        if not isinstance(value, int) or value &lt; 0:\n            raise ValueError(\"max_outliers must be a non-negative integer.\")\n        self._max_outliers = value\n\n    @property\n    def orthonormalize(self) -&gt; bool:\n        return self._orthonormalize\n\n    @orthonormalize.setter\n    def orthonormalize(self, value: bool):\n        if not isinstance(value, bool):\n            raise TypeError(\"orthonormalize must be a boolean.\")\n        self._orthonormalize = value\n\n    @property\n    def z_scan_sample_count(self) -&gt; int:\n        return self._z_scan_sample_count\n\n    @z_scan_sample_count.setter\n    def z_scan_sample_count(self, value: int):\n        if not isinstance(value, int) or value &lt; 1:\n            raise ValueError(\"z_scan_sample_count must be at least 1.\")\n        self._z_scan_sample_count = value\n\n    @property\n    def z_scan_sample_distance(self) -&gt; float:\n        return self._z_scan_sample_distance\n\n    @z_scan_sample_distance.setter\n    def z_scan_sample_distance(self, value: float):\n        if not isinstance(value, (float, int)) or value &lt;= 0:\n            raise ValueError(\n                \"z_scan_sample_distance must be a positive number.\"\n            )\n        self._z_scan_sample_distance = value\n\n    @property\n    def z_scan_sample_mode(self) -&gt; str:\n        return self._z_scan_sample_mode\n\n    @z_scan_sample_mode.setter\n    def z_scan_sample_mode(self, value: str):\n        if value not in [\"correlation\", \"intensity\"]:\n            raise ValueError(\n                'z_scan_sample_mode must be either \"correlation\" or \"intensity\".'\n            )\n        self._z_scan_sample_mode = value\n\n    @property\n    def measure_z(self) -&gt; bool:\n        return self._measure_z\n\n    @measure_z.setter\n    def measure_z(self, value: bool):\n        if not isinstance(value, bool):\n            raise TypeError(\"measure_z must be a boolean.\")\n        self._measure_z = value\n\n    def add_marker(\n        self, position: List[float], orientation: float, label: str\n    ):\n        \"\"\"\n        Adds a marker to the alignment anchors.\n        \"\"\"\n        if not isinstance(label, str):\n            raise TypeError(\"label must be a string.\")\n        if not isinstance(orientation, (float, int)):\n            try:\n                float(orientation)\n            except:\n                raise TypeError(\"orientation must be a float or an int.\")\n        if (\n            not isinstance(position, list)\n            or len(position) != 3\n            or not all(isinstance(val, (float, int)) for val in position)\n        ):\n            raise TypeError(\"position must be a list of three numbers.\")\n\n        self.alignment_anchors.append(\n            {\"label\": label, \"position\": position, \"rotation\": orientation}\n        )\n        return self\n\n    def set_markers_at(\n        self,\n        positions: List[List[float]],\n        orientations: List[float] = None,\n        labels: List[str] = None,\n    ):\n        \"\"\"\n        Creates multiple markers at specified positions with given orientations.\n        \"\"\"\n        if labels is None:\n            labels = [f\"marker_{i}\" for i in range(len(positions))]\n        if orientations is None:\n            orientations = [0 for i in range(len(positions))]\n        if len(labels) != len(positions) or len(labels) != len(orientations):\n            raise ValueError(\n                \"The number of labels, positions, and orientations must match.\"\n            )\n\n        for label in labels:\n            if not isinstance(label, str):\n                raise TypeError(\"All labels must be strings.\")\n\n        for position in positions:\n            if (\n                not isinstance(position, list)\n                or len(position) != 3\n                or not all(isinstance(val, (float, int)) for val in position)\n            ):\n                raise TypeError(\n                    \"All positions must be lists of three numbers.\"\n                )\n\n        for label, orientation, position in zip(\n            labels, orientations, positions\n        ):\n            self.add_marker(position, orientation, label)\n        return self\n\n    def to_dict(self) -&gt; Dict:\n        \"\"\"\n        Converts the current state of the object into a dictionary representation.\n        \"\"\"\n        node_dict = super().to_dict()\n        node_dict.update(\n            {\n                \"marker\": {\"image\": self.image.id, \"size\": self.marker_size},\n                \"center_stage\": self.center_stage,\n                \"action_upon_failure\": self.action_upon_failure,\n                \"laser_power\": self.laser_power,\n                \"scan_area_size\": self.scan_area_size,\n                \"scan_area_res_factors\": self.scan_area_res_factors,\n                \"detection_margin\": self.detection_margin,\n                \"correlation_threshold\": self.correlation_threshold,\n                \"residual_threshold\": self.residual_threshold,\n                \"max_outliers\": self.max_outliers,\n                \"orthonormalize\": self.orthonormalize,\n                \"z_scan_sample_count\": self.z_scan_sample_count,\n                \"z_scan_sample_distance\": self.z_scan_sample_distance,\n                \"z_scan_optimization_mode\": self.z_scan_sample_mode,\n                \"measure_z\": self.measure_z,\n                \"alignment_anchors\": self.alignment_anchors,\n            }\n        )\n        return node_dict\n</code></pre>"},{"location":"nodes/aligners/MarkerAligner/#npxpy.nodes.aligners.MarkerAligner.__init__","title":"<code>__init__(image, name='Marker aligner', marker_size=[5.0, 5.0], center_stage=True, action_upon_failure='abort', laser_power=0.5, scan_area_size=[10.0, 10.0], scan_area_res_factors=[2.0, 2.0], detection_margin=5.0, correlation_threshold=60.0, residual_threshold=0.5, max_outliers=0, orthonormalize=True, z_scan_sample_count=1, z_scan_sample_distance=0.5, z_scan_sample_mode='correlation', measure_z=False)</code>","text":"<p>Initializes the MarkerAligner with the provided parameters.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def __init__(\n    self,\n    image: Image,\n    name: str = \"Marker aligner\",\n    marker_size: List[float] = [5.0, 5.0],\n    center_stage: bool = True,\n    action_upon_failure: str = \"abort\",\n    laser_power: float = 0.5,\n    scan_area_size: List[float] = [10.0, 10.0],\n    scan_area_res_factors: List[float] = [2.0, 2.0],\n    detection_margin: float = 5.0,\n    correlation_threshold: float = 60.0,\n    residual_threshold: float = 0.5,\n    max_outliers: int = 0,\n    orthonormalize: bool = True,\n    z_scan_sample_count: int = 1,\n    z_scan_sample_distance: float = 0.5,\n    z_scan_sample_mode: str = \"correlation\",\n    measure_z: bool = False,\n):\n    \"\"\"\n    Initializes the MarkerAligner with the provided parameters.\n    \"\"\"\n    super().__init__(node_type=\"marker_alignment\", name=name)\n\n    # Set attributes via setters\n    self.image = image\n    self.marker_size = marker_size\n    self.center_stage = center_stage\n    self.action_upon_failure = action_upon_failure\n    self.laser_power = laser_power\n    self.scan_area_size = scan_area_size\n    self.scan_area_res_factors = scan_area_res_factors\n    self.detection_margin = detection_margin\n    self.correlation_threshold = correlation_threshold\n    self.residual_threshold = residual_threshold\n    self.max_outliers = max_outliers\n    self.orthonormalize = orthonormalize\n    self.z_scan_sample_count = z_scan_sample_count\n    self.z_scan_sample_distance = z_scan_sample_distance\n    self.z_scan_sample_mode = z_scan_sample_mode\n    self.measure_z = measure_z\n\n    self.alignment_anchors = []\n</code></pre>"},{"location":"nodes/aligners/MarkerAligner/#npxpy.nodes.aligners.MarkerAligner.add_marker","title":"<code>add_marker(position, orientation, label)</code>","text":"<p>Adds a marker to the alignment anchors.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def add_marker(\n    self, position: List[float], orientation: float, label: str\n):\n    \"\"\"\n    Adds a marker to the alignment anchors.\n    \"\"\"\n    if not isinstance(label, str):\n        raise TypeError(\"label must be a string.\")\n    if not isinstance(orientation, (float, int)):\n        try:\n            float(orientation)\n        except:\n            raise TypeError(\"orientation must be a float or an int.\")\n    if (\n        not isinstance(position, list)\n        or len(position) != 3\n        or not all(isinstance(val, (float, int)) for val in position)\n    ):\n        raise TypeError(\"position must be a list of three numbers.\")\n\n    self.alignment_anchors.append(\n        {\"label\": label, \"position\": position, \"rotation\": orientation}\n    )\n    return self\n</code></pre>"},{"location":"nodes/aligners/MarkerAligner/#npxpy.nodes.aligners.MarkerAligner.set_markers_at","title":"<code>set_markers_at(positions, orientations=None, labels=None)</code>","text":"<p>Creates multiple markers at specified positions with given orientations.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def set_markers_at(\n    self,\n    positions: List[List[float]],\n    orientations: List[float] = None,\n    labels: List[str] = None,\n):\n    \"\"\"\n    Creates multiple markers at specified positions with given orientations.\n    \"\"\"\n    if labels is None:\n        labels = [f\"marker_{i}\" for i in range(len(positions))]\n    if orientations is None:\n        orientations = [0 for i in range(len(positions))]\n    if len(labels) != len(positions) or len(labels) != len(orientations):\n        raise ValueError(\n            \"The number of labels, positions, and orientations must match.\"\n        )\n\n    for label in labels:\n        if not isinstance(label, str):\n            raise TypeError(\"All labels must be strings.\")\n\n    for position in positions:\n        if (\n            not isinstance(position, list)\n            or len(position) != 3\n            or not all(isinstance(val, (float, int)) for val in position)\n        ):\n            raise TypeError(\n                \"All positions must be lists of three numbers.\"\n            )\n\n    for label, orientation, position in zip(\n        labels, orientations, positions\n    ):\n        self.add_marker(position, orientation, label)\n    return self\n</code></pre>"},{"location":"nodes/aligners/MarkerAligner/#npxpy.nodes.aligners.MarkerAligner.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the current state of the object into a dictionary representation.</p> Source code in <code>npxpy/nodes/aligners.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n    \"\"\"\n    Converts the current state of the object into a dictionary representation.\n    \"\"\"\n    node_dict = super().to_dict()\n    node_dict.update(\n        {\n            \"marker\": {\"image\": self.image.id, \"size\": self.marker_size},\n            \"center_stage\": self.center_stage,\n            \"action_upon_failure\": self.action_upon_failure,\n            \"laser_power\": self.laser_power,\n            \"scan_area_size\": self.scan_area_size,\n            \"scan_area_res_factors\": self.scan_area_res_factors,\n            \"detection_margin\": self.detection_margin,\n            \"correlation_threshold\": self.correlation_threshold,\n            \"residual_threshold\": self.residual_threshold,\n            \"max_outliers\": self.max_outliers,\n            \"orthonormalize\": self.orthonormalize,\n            \"z_scan_sample_count\": self.z_scan_sample_count,\n            \"z_scan_sample_distance\": self.z_scan_sample_distance,\n            \"z_scan_optimization_mode\": self.z_scan_sample_mode,\n            \"measure_z\": self.measure_z,\n            \"alignment_anchors\": self.alignment_anchors,\n        }\n    )\n    return node_dict\n</code></pre>"},{"location":"nodes/misc/Capture/","title":"npxpy.nodes.misc.Capture","text":"<p>               Bases: <code>Node</code></p> <p>A class to represent a capture node with attributes and methods for managing capture settings.</p> <p>Attributes:</p> Name Type Description <code>capture_type</code> <code>str</code> <p>The type of capture (e.g., 'Camera', 'Confocal').</p> <code>laser_power</code> <code>float</code> <p>The laser power for the capture.</p> <code>scan_area_size</code> <code>List[float]</code> <p>The size of the scan area [width, height].</p> <code>scan_area_res_factors</code> <code>List[float]</code> <p>The resolution factors for the scan area.</p> Source code in <code>npxpy/nodes/misc.py</code> <pre><code>class Capture(Node):\n    \"\"\"\n    A class to represent a capture node with attributes and methods for managing\n    capture settings.\n\n    Attributes:\n        capture_type (str): The type of capture (e.g., 'Camera', 'Confocal').\n        laser_power (float): The laser power for the capture.\n        scan_area_size (List[float]): The size of the scan area [width, height].\n        scan_area_res_factors (List[float]): The resolution factors for the scan area.\n    \"\"\"\n\n    def __init__(self, name: str = \"Capture\"):\n        \"\"\"\n        Initialize the capture node.\n\n        Parameters:\n            name (str): Name of the capture node.\n        \"\"\"\n        super().__init__(node_type=\"capture\", name=name)\n        self.capture_type = \"Camera\"\n        self._laser_power = None\n        self._scan_area_size = None\n        self._scan_area_res_factors = None\n        self.laser_power = 0.5  # Using setter for validation\n        self.scan_area_size = [100.0, 100.0]  # Using setter for validation\n        self.scan_area_res_factors = [1.0, 1.0]  # Using setter for validation\n\n    @property\n    def laser_power(self):\n        \"\"\"Get the laser power.\"\"\"\n        return self._laser_power\n\n    @laser_power.setter\n    def laser_power(self, value: float):\n        \"\"\"\n        Set the laser power.\n\n        Parameters:\n            value (float): The laser power, must be greater or equal to 0.\n\n        Raises:\n            ValueError: If laser_power is less than 0.\n        \"\"\"\n        if not isinstance(value, (float, int)) or value &lt; 0:\n            raise ValueError(\"laser_power must be greater or equal to 0.\")\n        self._laser_power = value\n\n    @property\n    def scan_area_size(self):\n        \"\"\"Get the scan area size.\"\"\"\n        return self._scan_area_size\n\n    @scan_area_size.setter\n    def scan_area_size(self, value: List[float]):\n        \"\"\"\n        Set the scan area size.\n\n        Parameters:\n            value (List[float]): The scan area size [width, height].\n\n        Raises:\n            ValueError: If any value in scan_area_size is less than 0.\n        \"\"\"\n        if len(value) != 2 or not all(\n            isinstance(size, (float, int)) for size in value\n        ):\n            raise TypeError(\n                \"scan_area_size must be a list of two numbers greater or equal to 0.\"\n            )\n        if any(size &lt; 0 for size in value):\n            raise ValueError(\n                \"All elements in scan_area_size must be greater or equal to 0.\"\n            )\n        self._scan_area_size = value\n\n    @property\n    def scan_area_res_factors(self):\n        \"\"\"Get the scan area resolution factors.\"\"\"\n        return self._scan_area_res_factors\n\n    @scan_area_res_factors.setter\n    def scan_area_res_factors(self, value: List[float]):\n        \"\"\"\n        Set the scan area resolution factors.\n\n        Parameters:\n            value (List[float]): The scan area resolution factors [factor_x, factor_y].\n\n        Raises:\n            ValueError: If any value in scan_area_res_factors is less than or equal to 0.\n        \"\"\"\n        if len(value) != 2 or not all(\n            isinstance(factor, (float, int)) for factor in value\n        ):\n            raise TypeError(\n                \"scan_area_res_factors must be a list of two numbers greater than 0.\"\n            )\n        if any(factor &lt;= 0 for factor in value):\n            raise ValueError(\n                \"All elements in scan_area_res_factors must be greater than 0.\"\n            )\n        self._scan_area_res_factors = value\n\n    def confocal(\n        self,\n        laser_power: float = 0.5,\n        scan_area_size: List[float] = [100.0, 100.0],\n        scan_area_res_factors: List[float] = [1.0, 1.0],\n    ) -&gt; \"Capture\":\n        \"\"\"\n        Configure the capture node for confocal capture.\n\n        Parameters:\n            laser_power (float): The laser power, must be greater or equal to 0.\n            scan_area_size (List[float]): The scan area size [width, height].\n            scan_area_res_factors (List[float]): The resolution factors for the scan area.\n\n        Returns:\n            Capture: The updated Capture object.\n        \"\"\"\n        self.laser_power = laser_power\n        self.scan_area_size = scan_area_size\n        self.scan_area_res_factors = scan_area_res_factors\n        self.capture_type = \"Confocal\"\n        return self\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Convert the Capture object into a dictionary.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of the Capture object.\n        \"\"\"\n        node_dict = super().to_dict()  # Get the basic dict from Node\n        node_dict.update(\n            {\n                \"capture_type\": self.capture_type,\n                \"laser_power\": self.laser_power,\n                \"scan_area_size\": self.scan_area_size,\n                \"scan_area_res_factors\": self.scan_area_res_factors,\n            }\n        )\n        return node_dict\n</code></pre>"},{"location":"nodes/misc/Capture/#npxpy.nodes.misc.Capture.laser_power","title":"<code>laser_power</code>  <code>property</code> <code>writable</code>","text":"<p>Get the laser power.</p>"},{"location":"nodes/misc/Capture/#npxpy.nodes.misc.Capture.scan_area_res_factors","title":"<code>scan_area_res_factors</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scan area resolution factors.</p>"},{"location":"nodes/misc/Capture/#npxpy.nodes.misc.Capture.scan_area_size","title":"<code>scan_area_size</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scan area size.</p>"},{"location":"nodes/misc/Capture/#npxpy.nodes.misc.Capture.__init__","title":"<code>__init__(name='Capture')</code>","text":"<p>Initialize the capture node.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the capture node.</p> <code>'Capture'</code> Source code in <code>npxpy/nodes/misc.py</code> <pre><code>def __init__(self, name: str = \"Capture\"):\n    \"\"\"\n    Initialize the capture node.\n\n    Parameters:\n        name (str): Name of the capture node.\n    \"\"\"\n    super().__init__(node_type=\"capture\", name=name)\n    self.capture_type = \"Camera\"\n    self._laser_power = None\n    self._scan_area_size = None\n    self._scan_area_res_factors = None\n    self.laser_power = 0.5  # Using setter for validation\n    self.scan_area_size = [100.0, 100.0]  # Using setter for validation\n    self.scan_area_res_factors = [1.0, 1.0]  # Using setter for validation\n</code></pre>"},{"location":"nodes/misc/Capture/#npxpy.nodes.misc.Capture.confocal","title":"<code>confocal(laser_power=0.5, scan_area_size=[100.0, 100.0], scan_area_res_factors=[1.0, 1.0])</code>","text":"<p>Configure the capture node for confocal capture.</p> <p>Parameters:</p> Name Type Description Default <code>laser_power</code> <code>float</code> <p>The laser power, must be greater or equal to 0.</p> <code>0.5</code> <code>scan_area_size</code> <code>List[float]</code> <p>The scan area size [width, height].</p> <code>[100.0, 100.0]</code> <code>scan_area_res_factors</code> <code>List[float]</code> <p>The resolution factors for the scan area.</p> <code>[1.0, 1.0]</code> <p>Returns:</p> Name Type Description <code>Capture</code> <code>Capture</code> <p>The updated Capture object.</p> Source code in <code>npxpy/nodes/misc.py</code> <pre><code>def confocal(\n    self,\n    laser_power: float = 0.5,\n    scan_area_size: List[float] = [100.0, 100.0],\n    scan_area_res_factors: List[float] = [1.0, 1.0],\n) -&gt; \"Capture\":\n    \"\"\"\n    Configure the capture node for confocal capture.\n\n    Parameters:\n        laser_power (float): The laser power, must be greater or equal to 0.\n        scan_area_size (List[float]): The scan area size [width, height].\n        scan_area_res_factors (List[float]): The resolution factors for the scan area.\n\n    Returns:\n        Capture: The updated Capture object.\n    \"\"\"\n    self.laser_power = laser_power\n    self.scan_area_size = scan_area_size\n    self.scan_area_res_factors = scan_area_res_factors\n    self.capture_type = \"Confocal\"\n    return self\n</code></pre>"},{"location":"nodes/misc/Capture/#npxpy.nodes.misc.Capture.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the Capture object into a dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of the Capture object.</p> Source code in <code>npxpy/nodes/misc.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert the Capture object into a dictionary.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of the Capture object.\n    \"\"\"\n    node_dict = super().to_dict()  # Get the basic dict from Node\n    node_dict.update(\n        {\n            \"capture_type\": self.capture_type,\n            \"laser_power\": self.laser_power,\n            \"scan_area_size\": self.scan_area_size,\n            \"scan_area_res_factors\": self.scan_area_res_factors,\n        }\n    )\n    return node_dict\n</code></pre>"},{"location":"nodes/misc/DoseCompensation/","title":"npxpy.nodes.misc.DoseCompensation","text":"<p>               Bases: <code>Node</code></p> <p>A class to represent dose compensation with various attributes and methods for managing dose settings.</p> <p>Attributes:</p> Name Type Description <code>edge_location</code> <code>List[Union[float, int]]</code> <p>Location of the edge [x, y, z] in micrometers.</p> <code>edge_orientation</code> <code>Union[float, int]</code> <p>Orientation of the edge in degrees.</p> <code>domain_size</code> <code>List[Union[float, int]]</code> <p>Size of the domain [width, height, depth] in micrometers.</p> <code>gain_limit</code> <code>Union[float, int]</code> <p>Gain limit for the dose compensation.</p> Source code in <code>npxpy/nodes/misc.py</code> <pre><code>class DoseCompensation(Node):\n    \"\"\"\n    A class to represent dose compensation with various attributes and methods\n    for managing dose settings.\n\n    Attributes:\n        edge_location (List[Union[float, int]]): Location of the edge [x, y, z] in micrometers.\n        edge_orientation (Union[float, int]): Orientation of the edge in degrees.\n        domain_size (List[Union[float, int]]): Size of the domain [width, height, depth] in micrometers.\n        gain_limit (Union[float, int]): Gain limit for the dose compensation.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"Dose compensation 1\",\n        edge_location: List[Union[float, int]] = [0.0, 0.0, 0.0],\n        edge_orientation: Union[float, int] = 0.0,\n        domain_size: List[Union[float, int]] = [200.0, 100.0, 100.0],\n        gain_limit: Union[float, int] = 2.0,\n    ):\n        \"\"\"\n        Initialize the dose compensation with the specified parameters.\n\n        Parameters:\n            name (str): Name of the dose compensation.\n            edge_location (List[Union[float, int]]): Location of the edge [x, y, z] in micrometers.\n            edge_orientation (Union[float, int]): Orientation of the edge in degrees.\n            domain_size (List[Union[float, int]]): Size of the domain [width, height, depth] in micrometers.\n            gain_limit (Union[float, int]): Gain limit, must be &gt;= 1.\n        \"\"\"\n        super().__init__(node_type=\"dose_compensation\", name=name)\n        self.edge_location = edge_location\n        self.edge_orientation = edge_orientation\n        self.domain_size = domain_size\n        self.gain_limit = gain_limit\n\n    @property\n    def edge_location(self):\n        \"\"\"Get the location of the edge.\"\"\"\n        return self._edge_location\n\n    @edge_location.setter\n    def edge_location(self, value: List[Union[float, int]]):\n        \"\"\"\n        Set the location of the edge.\n\n        Parameters:\n            value (List[Union[float, int]]): The edge location [x, y, z].\n\n        Raises:\n            TypeError: If edge_location is not a list of three numbers.\n        \"\"\"\n        if len(value) != 3 or not all(\n            isinstance(val, (float, int)) for val in value\n        ):\n            raise TypeError(\"edge_location must be a list of three numbers.\")\n        self._edge_location = value\n\n    @property\n    def edge_orientation(self):\n        \"\"\"Get the edge orientation.\"\"\"\n        return self._edge_orientation\n\n    @edge_orientation.setter\n    def edge_orientation(self, value: Union[float, int]):\n        \"\"\"\n        Set the edge orientation.\n\n        Parameters:\n            value (Union[float, int]): The edge orientation in degrees.\n\n        Raises:\n            TypeError: If the value is not a number.\n        \"\"\"\n        if not isinstance(value, (float, int)):\n            raise TypeError(\"edge_orientation must be a float or an int.\")\n        self._edge_orientation = value\n\n    @property\n    def domain_size(self):\n        \"\"\"Get the size of the domain.\"\"\"\n        return self._domain_size\n\n    @domain_size.setter\n    def domain_size(self, value: List[Union[float, int]]):\n        \"\"\"\n        Set the domain size.\n\n        Parameters:\n            value (List[Union[float, int]]): The domain size [width, height, depth].\n\n        Raises:\n            TypeError: If domain_size is not a list of three numbers.\n            ValueError: If any element in domain_size is &lt;= 0.\n        \"\"\"\n        if len(value) != 3 or not all(\n            isinstance(val, (float, int)) for val in value\n        ):\n            raise TypeError(\"domain_size must be a list of three numbers.\")\n        if any(size &lt;= 0 for size in value):\n            raise ValueError(\n                \"All elements in domain_size must be greater than 0.\"\n            )\n        self._domain_size = value\n\n    @property\n    def gain_limit(self):\n        \"\"\"Get the gain limit.\"\"\"\n        return self._gain_limit\n\n    @gain_limit.setter\n    def gain_limit(self, value: Union[float, int]):\n        \"\"\"\n        Set the gain limit.\n\n        Parameters:\n            value (Union[float, int]): The gain limit.\n\n        Raises:\n            ValueError: If the gain limit is less than 1.\n        \"\"\"\n        if value &lt; 1:\n            raise ValueError(\"gain_limit must be greater than or equal to 1.\")\n        self._gain_limit = value\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Convert the DoseCompensation object into a dictionary.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of the object.\n        \"\"\"\n        node_dict = super().to_dict()  # Get the basic dict from Node\n        node_dict.update(\n            {\n                \"position_local_cos\": self.edge_location,\n                \"z_rotation_local_cos\": self.edge_orientation,\n                \"size\": self.domain_size,\n                \"gain_limit\": self.gain_limit,\n            }\n        )\n        return node_dict\n</code></pre>"},{"location":"nodes/misc/DoseCompensation/#npxpy.nodes.misc.DoseCompensation.domain_size","title":"<code>domain_size</code>  <code>property</code> <code>writable</code>","text":"<p>Get the size of the domain.</p>"},{"location":"nodes/misc/DoseCompensation/#npxpy.nodes.misc.DoseCompensation.edge_location","title":"<code>edge_location</code>  <code>property</code> <code>writable</code>","text":"<p>Get the location of the edge.</p>"},{"location":"nodes/misc/DoseCompensation/#npxpy.nodes.misc.DoseCompensation.edge_orientation","title":"<code>edge_orientation</code>  <code>property</code> <code>writable</code>","text":"<p>Get the edge orientation.</p>"},{"location":"nodes/misc/DoseCompensation/#npxpy.nodes.misc.DoseCompensation.gain_limit","title":"<code>gain_limit</code>  <code>property</code> <code>writable</code>","text":"<p>Get the gain limit.</p>"},{"location":"nodes/misc/DoseCompensation/#npxpy.nodes.misc.DoseCompensation.__init__","title":"<code>__init__(name='Dose compensation 1', edge_location=[0.0, 0.0, 0.0], edge_orientation=0.0, domain_size=[200.0, 100.0, 100.0], gain_limit=2.0)</code>","text":"<p>Initialize the dose compensation with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the dose compensation.</p> <code>'Dose compensation 1'</code> <code>edge_location</code> <code>List[Union[float, int]]</code> <p>Location of the edge [x, y, z] in micrometers.</p> <code>[0.0, 0.0, 0.0]</code> <code>edge_orientation</code> <code>Union[float, int]</code> <p>Orientation of the edge in degrees.</p> <code>0.0</code> <code>domain_size</code> <code>List[Union[float, int]]</code> <p>Size of the domain [width, height, depth] in micrometers.</p> <code>[200.0, 100.0, 100.0]</code> <code>gain_limit</code> <code>Union[float, int]</code> <p>Gain limit, must be &gt;= 1.</p> <code>2.0</code> Source code in <code>npxpy/nodes/misc.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"Dose compensation 1\",\n    edge_location: List[Union[float, int]] = [0.0, 0.0, 0.0],\n    edge_orientation: Union[float, int] = 0.0,\n    domain_size: List[Union[float, int]] = [200.0, 100.0, 100.0],\n    gain_limit: Union[float, int] = 2.0,\n):\n    \"\"\"\n    Initialize the dose compensation with the specified parameters.\n\n    Parameters:\n        name (str): Name of the dose compensation.\n        edge_location (List[Union[float, int]]): Location of the edge [x, y, z] in micrometers.\n        edge_orientation (Union[float, int]): Orientation of the edge in degrees.\n        domain_size (List[Union[float, int]]): Size of the domain [width, height, depth] in micrometers.\n        gain_limit (Union[float, int]): Gain limit, must be &gt;= 1.\n    \"\"\"\n    super().__init__(node_type=\"dose_compensation\", name=name)\n    self.edge_location = edge_location\n    self.edge_orientation = edge_orientation\n    self.domain_size = domain_size\n    self.gain_limit = gain_limit\n</code></pre>"},{"location":"nodes/misc/DoseCompensation/#npxpy.nodes.misc.DoseCompensation.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the DoseCompensation object into a dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of the object.</p> Source code in <code>npxpy/nodes/misc.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert the DoseCompensation object into a dictionary.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of the object.\n    \"\"\"\n    node_dict = super().to_dict()  # Get the basic dict from Node\n    node_dict.update(\n        {\n            \"position_local_cos\": self.edge_location,\n            \"z_rotation_local_cos\": self.edge_orientation,\n            \"size\": self.domain_size,\n            \"gain_limit\": self.gain_limit,\n        }\n    )\n    return node_dict\n</code></pre>"},{"location":"nodes/misc/StageMove/","title":"npxpy.nodes.misc.StageMove","text":"<p>               Bases: <code>Node</code></p> <p>A class to represent a stage move node with a specified stage position.</p> <p>Attributes:</p> Name Type Description <code>target_position</code> <code>List[float]</code> <p>The target position of the stage [x, y, z].</p> Source code in <code>npxpy/nodes/misc.py</code> <pre><code>class StageMove(Node):\n    \"\"\"\n    A class to represent a stage move node with a specified stage position.\n\n    Attributes:\n        target_position (List[float]): The target position of the stage [x, y, z].\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"Stage move\",\n        stage_position: List[float] = [0.0, 0.0, 0.0],\n    ):\n        \"\"\"\n        Initialize the stage move node.\n\n        Parameters:\n            name (str): Name of the stage move node.\n            stage_position (List[float]): Target position of the stage [x, y, z].\n        \"\"\"\n        super().__init__(node_type=\"stage_move\", name=name)\n        self.stage_position = stage_position\n\n    @property\n    def stage_position(self):\n        \"\"\"Get the stage position.\"\"\"\n        return self._stage_position\n\n    @stage_position.setter\n    def stage_position(self, value: List[float]):\n        \"\"\"\n        Set the stage position.\n\n        Parameters:\n            value (List[float]): The target stage position [x, y, z].\n\n        Raises:\n            TypeError: If stage_position is not a list of three numbers.\n        \"\"\"\n        if len(value) != 3 or not all(\n            isinstance(val, (float, int)) for val in value\n        ):\n            raise TypeError(\"stage_position must be a list of three numbers.\")\n        self._stage_position = value\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Convert the StageMove object into a dictionary.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of the object.\n        \"\"\"\n        node_dict = super().to_dict()  # Get the basic dict from Node\n        node_dict[\"target_position\"] = self.stage_position\n        return node_dict\n</code></pre>"},{"location":"nodes/misc/StageMove/#npxpy.nodes.misc.StageMove.stage_position","title":"<code>stage_position</code>  <code>property</code> <code>writable</code>","text":"<p>Get the stage position.</p>"},{"location":"nodes/misc/StageMove/#npxpy.nodes.misc.StageMove.__init__","title":"<code>__init__(name='Stage move', stage_position=[0.0, 0.0, 0.0])</code>","text":"<p>Initialize the stage move node.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the stage move node.</p> <code>'Stage move'</code> <code>stage_position</code> <code>List[float]</code> <p>Target position of the stage [x, y, z].</p> <code>[0.0, 0.0, 0.0]</code> Source code in <code>npxpy/nodes/misc.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"Stage move\",\n    stage_position: List[float] = [0.0, 0.0, 0.0],\n):\n    \"\"\"\n    Initialize the stage move node.\n\n    Parameters:\n        name (str): Name of the stage move node.\n        stage_position (List[float]): Target position of the stage [x, y, z].\n    \"\"\"\n    super().__init__(node_type=\"stage_move\", name=name)\n    self.stage_position = stage_position\n</code></pre>"},{"location":"nodes/misc/StageMove/#npxpy.nodes.misc.StageMove.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the StageMove object into a dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of the object.</p> Source code in <code>npxpy/nodes/misc.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert the StageMove object into a dictionary.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of the object.\n    \"\"\"\n    node_dict = super().to_dict()  # Get the basic dict from Node\n    node_dict[\"target_position\"] = self.stage_position\n    return node_dict\n</code></pre>"},{"location":"nodes/misc/Wait/","title":"npxpy.nodes.misc.Wait","text":"<p>               Bases: <code>Node</code></p> <p>A class to represent a wait node with a specified wait time.</p> <p>Attributes:</p> Name Type Description <code>wait_time</code> <code>float</code> <p>The wait time in seconds.</p> Source code in <code>npxpy/nodes/misc.py</code> <pre><code>class Wait(Node):\n    \"\"\"\n    A class to represent a wait node with a specified wait time.\n\n    Attributes:\n        wait_time (float): The wait time in seconds.\n    \"\"\"\n\n    def __init__(self, name: str = \"Wait\", wait_time: float = 1.0):\n        \"\"\"\n        Initialize the wait node.\n\n        Parameters:\n            name (str): Name of the wait node.\n            wait_time (float): Wait time in seconds, must be greater than 0.\n        \"\"\"\n        super().__init__(node_type=\"wait\", name=name)\n        self.wait_time = wait_time\n\n    @property\n    def wait_time(self):\n        \"\"\"Get the wait time.\"\"\"\n        return self._wait_time\n\n    @wait_time.setter\n    def wait_time(self, value: float):\n        \"\"\"\n        Set the wait time.\n\n        Parameters:\n            value (float): The wait time in seconds.\n\n        Raises:\n            ValueError: If the wait time is not greater than 0.\n        \"\"\"\n        if value &lt;= 0:\n            raise ValueError(\"wait_time must be a positive number.\")\n        self._wait_time = value\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Convert the Wait object into a dictionary.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of the object.\n        \"\"\"\n        node_dict = super().to_dict()  # Get the basic dict from Node\n        node_dict[\"wait_time\"] = self.wait_time\n        return node_dict\n</code></pre>"},{"location":"nodes/misc/Wait/#npxpy.nodes.misc.Wait.wait_time","title":"<code>wait_time</code>  <code>property</code> <code>writable</code>","text":"<p>Get the wait time.</p>"},{"location":"nodes/misc/Wait/#npxpy.nodes.misc.Wait.__init__","title":"<code>__init__(name='Wait', wait_time=1.0)</code>","text":"<p>Initialize the wait node.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the wait node.</p> <code>'Wait'</code> <code>wait_time</code> <code>float</code> <p>Wait time in seconds, must be greater than 0.</p> <code>1.0</code> Source code in <code>npxpy/nodes/misc.py</code> <pre><code>def __init__(self, name: str = \"Wait\", wait_time: float = 1.0):\n    \"\"\"\n    Initialize the wait node.\n\n    Parameters:\n        name (str): Name of the wait node.\n        wait_time (float): Wait time in seconds, must be greater than 0.\n    \"\"\"\n    super().__init__(node_type=\"wait\", name=name)\n    self.wait_time = wait_time\n</code></pre>"},{"location":"nodes/misc/Wait/#npxpy.nodes.misc.Wait.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the Wait object into a dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of the object.</p> Source code in <code>npxpy/nodes/misc.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert the Wait object into a dictionary.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of the object.\n    \"\"\"\n    node_dict = super().to_dict()  # Get the basic dict from Node\n    node_dict[\"wait_time\"] = self.wait_time\n    return node_dict\n</code></pre>"},{"location":"nodes/space/Array/","title":"npxpy.nodes.space.Array","text":"<p>               Bases: <code>_GatekeeperSpace</code></p> <p>Class representing an array node with additional attributes.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>List[float]</code> <p>Position of the array [x, y, z].</p> <code>rotation</code> <code>List[float]</code> <p>Rotation of the array [psi, theta, phi].</p> <code>count</code> <code>List[int]</code> <p>Number of grid points in [x, y] direction.</p> <code>spacing</code> <code>List[float]</code> <p>Spacing of the grid in [width, height].</p> <code>order</code> <code>str</code> <p>Order of the array ('Lexical' or 'Meander').</p> <code>shape</code> <code>str</code> <p>Shape of the array ('Rectangular' or 'Round').</p> Source code in <code>npxpy/nodes/space.py</code> <pre><code>class Array(_GatekeeperSpace):\n    \"\"\"\n    Class representing an array node with additional attributes.\n\n    Attributes:\n        position (List[float]): Position of the array [x, y, z].\n        rotation (List[float]): Rotation of the array [psi, theta, phi].\n        count (List[int]): Number of grid points in [x, y] direction.\n        spacing (List[float]): Spacing of the grid in [width, height].\n        order (str): Order of the array ('Lexical' or 'Meander').\n        shape (str): Shape of the array ('Rectangular' or 'Round').\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"Array\",\n        position: List[float] = [0, 0, 0],\n        rotation: List[float] = [0.0, 0.0, 0.0],\n        count: List[int] = [5, 5],\n        spacing: List[float] = [100.0, 100.0],\n        order: str = \"Lexical\",\n        shape: str = \"Rectangular\",\n    ):\n        \"\"\"\n        Initialize an Array node.\n        \"\"\"\n        super().__init__(\"array\", name)\n        self.position = position\n        self.rotation = rotation\n        self.count = count\n        self.spacing = spacing\n        self.order = order\n        self.shape = shape\n\n    # Setters for other attributes\n    @property\n    def count(self):\n        return self._count\n\n    @property\n    def count(self):\n        return self._count\n\n    @count.setter\n    def count(self, value: List[int]):\n        if len(value) != 2 or not all(\n            isinstance(c, int) and c &gt; 0 for c in value\n        ):\n            raise ValueError(\n                \"Count must be a list of exactly two integers greater than zero.\"\n            )\n        self._count = value\n\n    @property\n    def spacing(self):\n        return self._spacing\n\n    @spacing.setter\n    def spacing(self, value: List[float]):\n        if len(value) != 2 or not all(\n            isinstance(s, (int, float)) for s in value\n        ):\n            raise ValueError(\n                \"Spacing must be a list of exactly two numeric values.\"\n            )\n        self._spacing = value\n\n    @property\n    def order(self):\n        return self._order\n\n    @order.setter\n    def order(self, value: str):\n        if value not in [\"Lexical\", \"Meander\"]:\n            raise ValueError(\"order must be either 'Lexical' or 'Meander'.\")\n        self._order = value\n\n    @property\n    def shape(self):\n        return self._shape\n\n    @shape.setter\n    def shape(self, value: str):\n        if value not in [\"Rectangular\", \"Round\"]:\n            raise ValueError(\"shape must be either 'Rectangular' or 'Round'.\")\n        self._shape = value\n\n    def set_grid(\n        self, count: List[int] = count, spacing: List[float] = spacing\n    ):\n        \"\"\"\n        Set the count and spacing of the array grid.\n\n        Parameters:\n            count (List[int]): The new grid point count.\n            spacing (List[float]): The new grid spacing.\n\n        Returns:\n            Array: The updated Array object.\n        \"\"\"\n        self.count = count\n        self.spacing = spacing\n        return self\n\n    def to_dict(self) -&gt; Dict:\n        \"\"\"\n        Convert the Array object into a dictionary.\n        \"\"\"\n        node_dict = super().to_dict()\n        node_dict[\"position\"] = self.position\n        node_dict[\"rotation\"] = self.rotation\n        node_dict[\"count\"] = self.count\n        node_dict[\"spacing\"] = self.spacing\n        node_dict[\"order\"] = self.order\n        node_dict[\"shape\"] = self.shape\n        return node_dict\n</code></pre>"},{"location":"nodes/space/Array/#npxpy.nodes.space.Array.__init__","title":"<code>__init__(name='Array', position=[0, 0, 0], rotation=[0.0, 0.0, 0.0], count=[5, 5], spacing=[100.0, 100.0], order='Lexical', shape='Rectangular')</code>","text":"<p>Initialize an Array node.</p> Source code in <code>npxpy/nodes/space.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"Array\",\n    position: List[float] = [0, 0, 0],\n    rotation: List[float] = [0.0, 0.0, 0.0],\n    count: List[int] = [5, 5],\n    spacing: List[float] = [100.0, 100.0],\n    order: str = \"Lexical\",\n    shape: str = \"Rectangular\",\n):\n    \"\"\"\n    Initialize an Array node.\n    \"\"\"\n    super().__init__(\"array\", name)\n    self.position = position\n    self.rotation = rotation\n    self.count = count\n    self.spacing = spacing\n    self.order = order\n    self.shape = shape\n</code></pre>"},{"location":"nodes/space/Array/#npxpy.nodes.space.Array.set_grid","title":"<code>set_grid(count=count, spacing=spacing)</code>","text":"<p>Set the count and spacing of the array grid.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>List[int]</code> <p>The new grid point count.</p> <code>count</code> <code>spacing</code> <code>List[float]</code> <p>The new grid spacing.</p> <code>spacing</code> <p>Returns:</p> Name Type Description <code>Array</code> <p>The updated Array object.</p> Source code in <code>npxpy/nodes/space.py</code> <pre><code>def set_grid(\n    self, count: List[int] = count, spacing: List[float] = spacing\n):\n    \"\"\"\n    Set the count and spacing of the array grid.\n\n    Parameters:\n        count (List[int]): The new grid point count.\n        spacing (List[float]): The new grid spacing.\n\n    Returns:\n        Array: The updated Array object.\n    \"\"\"\n    self.count = count\n    self.spacing = spacing\n    return self\n</code></pre>"},{"location":"nodes/space/Array/#npxpy.nodes.space.Array.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the Array object into a dictionary.</p> Source code in <code>npxpy/nodes/space.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n    \"\"\"\n    Convert the Array object into a dictionary.\n    \"\"\"\n    node_dict = super().to_dict()\n    node_dict[\"position\"] = self.position\n    node_dict[\"rotation\"] = self.rotation\n    node_dict[\"count\"] = self.count\n    node_dict[\"spacing\"] = self.spacing\n    node_dict[\"order\"] = self.order\n    node_dict[\"shape\"] = self.shape\n    return node_dict\n</code></pre>"},{"location":"nodes/space/Group/","title":"npxpy.nodes.space.Group","text":"<p>               Bases: <code>_GatekeeperSpace</code></p> <p>Class representing a group node.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>List[float]</code> <p>Position of the group [x, y, z].</p> <code>rotation</code> <code>List[float]</code> <p>Rotation of the group [psi, theta, phi].</p> Source code in <code>npxpy/nodes/space.py</code> <pre><code>class Group(_GatekeeperSpace):\n    \"\"\"\n    Class representing a group node.\n\n    Attributes:\n        position (List[float]): Position of the group [x, y, z].\n        rotation (List[float]): Rotation of the group [psi, theta, phi].\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"Group\",\n        position: List[float] = [0, 0, 0],\n        rotation: List[float] = [0.0, 0.0, 0.0],\n    ):\n        \"\"\"\n        Initialize a Group node.\n        \"\"\"\n        super().__init__(\"group\", name)\n        self.position = position\n        self.rotation = rotation\n\n    def to_dict(self) -&gt; Dict:\n        \"\"\"\n        Convert the Group object into a dictionary.\n        \"\"\"\n        node_dict = super().to_dict()\n        node_dict[\"position\"] = self.position\n        node_dict[\"rotation\"] = self.rotation\n        return node_dict\n</code></pre>"},{"location":"nodes/space/Group/#npxpy.nodes.space.Group.__init__","title":"<code>__init__(name='Group', position=[0, 0, 0], rotation=[0.0, 0.0, 0.0])</code>","text":"<p>Initialize a Group node.</p> Source code in <code>npxpy/nodes/space.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"Group\",\n    position: List[float] = [0, 0, 0],\n    rotation: List[float] = [0.0, 0.0, 0.0],\n):\n    \"\"\"\n    Initialize a Group node.\n    \"\"\"\n    super().__init__(\"group\", name)\n    self.position = position\n    self.rotation = rotation\n</code></pre>"},{"location":"nodes/space/Group/#npxpy.nodes.space.Group.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the Group object into a dictionary.</p> Source code in <code>npxpy/nodes/space.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n    \"\"\"\n    Convert the Group object into a dictionary.\n    \"\"\"\n    node_dict = super().to_dict()\n    node_dict[\"position\"] = self.position\n    node_dict[\"rotation\"] = self.rotation\n    return node_dict\n</code></pre>"},{"location":"nodes/space/Scene/","title":"npxpy.nodes.space.Scene","text":"<p>               Bases: <code>_GatekeeperSpace</code></p> <p>Class representing a scene node.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>List[float]</code> <p>Position of the scene [x, y, z].</p> <code>rotation</code> <code>List[float]</code> <p>Rotation of the scene [psi, theta, phi].</p> <code>writing_direction_upward</code> <code>bool</code> <p>Writing direction of the scene.</p> Source code in <code>npxpy/nodes/space.py</code> <pre><code>class Scene(_GatekeeperSpace):\n    \"\"\"\n    Class representing a scene node.\n\n    Attributes:\n        position (List[float]): Position of the scene [x, y, z].\n        rotation (List[float]): Rotation of the scene [psi, theta, phi].\n        writing_direction_upward (bool): Writing direction of the scene.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"Scene\",\n        position: List[float] = [0, 0, 0],\n        rotation: List[float] = [0.0, 0.0, 0.0],\n        writing_direction_upward: bool = True,\n    ):\n        \"\"\"\n        Initialize a Scene node.\n        \"\"\"\n        super().__init__(\"scene\", name)\n        self.position = position\n        self.rotation = rotation\n        self._writing_direction_upward = None\n        self.writing_direction_upward = (\n            writing_direction_upward  # Using setter\n        )\n\n    # Getter and setter for writing direction\n    @property\n    def writing_direction_upward(self):\n        return self._writing_direction_upward\n\n    @writing_direction_upward.setter\n    def writing_direction_upward(self, value: bool):\n        if not isinstance(value, bool):\n            raise ValueError(\"writing_direction_upward must be a boolean.\")\n        self._writing_direction_upward = value\n\n    def to_dict(self) -&gt; Dict:\n        \"\"\"\n        Convert the Scene object into a dictionary.\n        \"\"\"\n        node_dict = super().to_dict()\n        node_dict[\"position\"] = self.position\n        node_dict[\"rotation\"] = self.rotation\n        node_dict[\"writing_direction_upward\"] = self.writing_direction_upward\n        return node_dict\n</code></pre>"},{"location":"nodes/space/Scene/#npxpy.nodes.space.Scene.__init__","title":"<code>__init__(name='Scene', position=[0, 0, 0], rotation=[0.0, 0.0, 0.0], writing_direction_upward=True)</code>","text":"<p>Initialize a Scene node.</p> Source code in <code>npxpy/nodes/space.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"Scene\",\n    position: List[float] = [0, 0, 0],\n    rotation: List[float] = [0.0, 0.0, 0.0],\n    writing_direction_upward: bool = True,\n):\n    \"\"\"\n    Initialize a Scene node.\n    \"\"\"\n    super().__init__(\"scene\", name)\n    self.position = position\n    self.rotation = rotation\n    self._writing_direction_upward = None\n    self.writing_direction_upward = (\n        writing_direction_upward  # Using setter\n    )\n</code></pre>"},{"location":"nodes/space/Scene/#npxpy.nodes.space.Scene.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the Scene object into a dictionary.</p> Source code in <code>npxpy/nodes/space.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n    \"\"\"\n    Convert the Scene object into a dictionary.\n    \"\"\"\n    node_dict = super().to_dict()\n    node_dict[\"position\"] = self.position\n    node_dict[\"rotation\"] = self.rotation\n    node_dict[\"writing_direction_upward\"] = self.writing_direction_upward\n    return node_dict\n</code></pre>"},{"location":"nodes/structures/Lens/","title":"npxpy.nodes.structures.Lens","text":"<p>               Bases: <code>Structure</code></p> <p>A class representing a lens node with specific optical properties.</p> <p>Attributes:</p> Name Type Description <code>radius</code> <code>Union[float, int]</code> <p>The radius of the lens.</p> <code>height</code> <code>Union[float, int]</code> <p>The height of the lens.</p> <code>crop_base</code> <code>bool</code> <p>Flag indicating whether the base of the lens should be cropped.</p> <code>asymmetric</code> <code>bool</code> <p>Flag indicating whether the lens is asymmetric.</p> <code>curvature</code> <code>Union[float, int]</code> <p>The curvature of the lens.</p> <code>conic_constant</code> <code>Union[float, int]</code> <p>The conic constant of the lens.</p> <code>curvature_y</code> <code>Union[float, int]</code> <p>The curvature of the lens in the Y direction (for asymmetric lenses).</p> <code>conic_constant_y</code> <code>Union[float, int]</code> <p>The conic constant in the Y direction.</p> <code>nr_radial_segments</code> <code>int</code> <p>The number of radial segments.</p> <code>nr_phi_segments</code> <code>int</code> <p>The number of phi segments.</p> Source code in <code>npxpy/nodes/structures.py</code> <pre><code>class Lens(Structure):\n    \"\"\"\n    A class representing a lens node with specific optical properties.\n\n    Attributes:\n        radius (Union[float, int]): The radius of the lens.\n        height (Union[float, int]): The height of the lens.\n        crop_base (bool): Flag indicating whether the base of the lens should be cropped.\n        asymmetric (bool): Flag indicating whether the lens is asymmetric.\n        curvature (Union[float, int]): The curvature of the lens.\n        conic_constant (Union[float, int]): The conic constant of the lens.\n        curvature_y (Union[float, int]): The curvature of the lens in the Y direction (for asymmetric lenses).\n        conic_constant_y (Union[float, int]): The conic constant in the Y direction.\n        nr_radial_segments (int): The number of radial segments.\n        nr_phi_segments (int): The number of phi segments.\n    \"\"\"\n\n    def __init__(\n        self,\n        preset: Preset,\n        name: str = \"Lens\",\n        radius: Union[float, int] = 100.0,\n        height: Union[float, int] = 50.0,\n        crop_base: bool = False,\n        asymmetric: bool = False,\n        curvature: Union[float, int] = 0.01,\n        conic_constant: Union[float, int] = 0.01,\n        curvature_y: Union[float, int] = 0.01,\n        conic_constant_y: Union[float, int] = -1.0,\n        nr_radial_segments: int = 500,\n        nr_phi_segments: int = 360,\n        slicing_origin: str = \"scene_bottom\",\n        slicing_offset: Union[float, int] = 0.0,\n        priority: int = 0,\n        expose_individually: bool = False,\n        position: List[Union[float, int]] = [0.0, 0.0, 0.0],\n        rotation: List[Union[float, int]] = [0.0, 0.0, 0.0],\n        color=\"lightblue\",\n    ):\n        \"\"\"\n        Initialize a Lens node with optical properties.\n\n        Parameters:\n            preset (Preset): The preset associated with the lens.\n            name (str): The name of the lens.\n            radius (Union[float, int]): The radius of the lens. Must be &gt; 0.\n            height (Union[float, int]): The height of the lens. Must be &gt; 0.\n            crop_base (bool): Whether to crop the base of the lens.\n            asymmetric (bool): Whether the lens is asymmetric.\n            curvature (Union[float, int]): The curvature of the lens.\n            conic_constant (Union[float, int]): The conic constant of the lens.\n            curvature_y (Union[float, int]): The curvature in the Y direction (if asymmetric).\n            conic_constant_y (Union[float, int]): The conic constant in the Y direction.\n            nr_radial_segments (int): The number of radial segments.\n            nr_phi_segments (int): The number of phi segments.\n            slicing_origin (str): The slicing origin.\n            slicing_offset (Union[float, int]): The slicing offset.\n            priority (int): The priority of the lens.\n            expose_individually (bool): Whether to expose the lens individually.\n            position (List[Union[float, int]]): The position of the lens [x, y, z].\n            rotation (List[Union[float, int]]): The rotation of the lens [psi, theta, phi].\n        \"\"\"\n        super().__init__(\n            preset=preset,\n            mesh=None,\n            name=name,\n            slicing_origin=slicing_origin,\n            slicing_offset=slicing_offset,\n            priority=priority,\n            expose_individually=expose_individually,\n            rotation=rotation,\n            position=position,\n            color=color,\n        )\n\n        # Setters for validation\n        self.radius = radius\n        self.height = height\n        self.crop_base = crop_base\n        self.asymmetric = asymmetric\n        self.curvature = curvature\n        self.conic_constant = conic_constant\n        self.curvature_y = curvature_y\n        self.conic_constant_y = conic_constant_y\n        self.nr_radial_segments = nr_radial_segments\n        self.nr_phi_segments = nr_phi_segments\n\n        self.polynomial_type = \"Normalized\"\n        self.polynomial_factors = []\n        self.polynomial_factors_y = []\n\n        self.surface_compensation_factors = []\n        self.surface_compensation_factors_y = []\n\n        self.load_mesh = False\n        self.load_preset = True\n\n        #  This guy sits in Structure. Ensures no mesh is passed.\n        self._mesh = False\n\n    # Setters with validation for Lens-specific attributes\n    @property\n    def radius(self):\n        \"\"\"The radius of the lens.\"\"\"\n        return self._radius\n\n    @radius.setter\n    def radius(self, value: Union[float, int]):\n        if not isinstance(value, (float, int)) or value &lt;= 0:\n            raise ValueError(\"radius must be a positive number.\")\n        self._radius = value\n\n    @property\n    def height(self):\n        \"\"\"The height of the lens.\"\"\"\n        return self._height\n\n    @height.setter\n    def height(self, value: Union[float, int]):\n        if not isinstance(value, (float, int)) or value &lt;= 0:\n            raise ValueError(\"height must be a positive number.\")\n        self._height = value\n\n    @property\n    def crop_base(self):\n        \"\"\"Whether the lens base should be cropped.\"\"\"\n        return self._crop_base\n\n    @crop_base.setter\n    def crop_base(self, value: bool):\n        if not isinstance(value, bool):\n            raise TypeError(\"crop_base must be a boolean.\")\n        self._crop_base = value\n\n    @property\n    def asymmetric(self):\n        \"\"\"Whether the lens is asymmetric.\"\"\"\n        return self._asymmetric\n\n    @asymmetric.setter\n    def asymmetric(self, value: bool):\n        if not isinstance(value, bool):\n            raise TypeError(\"asymmetric must be a boolean.\")\n        self._asymmetric = value\n\n    @property\n    def curvature(self):\n        \"\"\"The curvature of the lens.\"\"\"\n        return self._curvature\n\n    @curvature.setter\n    def curvature(self, value: Union[float, int]):\n        if not isinstance(value, (float, int)):\n            raise TypeError(\"curvature must be a float or an int.\")\n        self._curvature = value\n\n    @property\n    def conic_constant(self):\n        \"\"\"The conic constant of the lens.\"\"\"\n        return self._conic_constant\n\n    @conic_constant.setter\n    def conic_constant(self, value: Union[float, int]):\n        if not isinstance(value, (float, int)):\n            raise TypeError(\"conic_constant must be a float or an int.\")\n        self._conic_constant = value\n\n    @property\n    def curvature_y(self):\n        \"\"\"The curvature of the lens in the Y direction.\"\"\"\n        return self._curvature_y\n\n    @curvature_y.setter\n    def curvature_y(self, value: Union[float, int]):\n        if not isinstance(value, (float, int)):\n            raise TypeError(\"curvature_y must be a float or an int.\")\n        self._curvature_y = value\n\n    @property\n    def conic_constant_y(self):\n        \"\"\"The conic constant in the Y direction.\"\"\"\n        return self._conic_constant_y\n\n    @conic_constant_y.setter\n    def conic_constant_y(self, value: Union[float, int]):\n        if not isinstance(value, (float, int)):\n            raise TypeError(\"conic_constant_y must be a float or an int.\")\n        self._conic_constant_y = value\n\n    @property\n    def nr_radial_segments(self):\n        \"\"\"The number of radial segments for the lens.\"\"\"\n        return self._nr_radial_segments\n\n    @nr_radial_segments.setter\n    def nr_radial_segments(self, value: int):\n        if not isinstance(value, int):\n            raise TypeError(\"nr_radial_segments must be an int.\")\n        self._nr_radial_segments = value\n\n    @property\n    def nr_phi_segments(self):\n        \"\"\"The number of phi segments for the lens.\"\"\"\n        return self._nr_phi_segments\n\n    @nr_phi_segments.setter\n    def nr_phi_segments(self, value: int):\n        if not isinstance(value, int):\n            raise TypeError(\"nr_phi_segments must be an int.\")\n        self._nr_phi_segments = value\n\n    @property\n    def polynomial_type(self):\n        \"\"\"The type of polynomial ('Normalized' or 'Standard').\"\"\"\n        return self._polynomial_type\n\n    @polynomial_type.setter\n    def polynomial_type(self, value: str):\n        if value not in [\"Normalized\", \"Standard\"]:\n            raise ValueError(\n                \"polynomial_type must be either 'Normalized' or 'Standard'.\"\n            )\n        self._polynomial_type = value\n\n    @property\n    def polynomial_factors(self):\n        \"\"\"List of polynomial factors.\"\"\"\n        return self._polynomial_factors\n\n    @polynomial_factors.setter\n    def polynomial_factors(self, value: List[Union[float, int]]):\n        if not all(isinstance(f, (float, int)) for f in value):\n            raise TypeError(\n                \"All polynomial_factors elements must be float or int.\"\n            )\n        self._polynomial_factors = value\n\n    @property\n    def polynomial_factors_y(self):\n        \"\"\"Polynomial factors for Y axis (if asymmetric).\"\"\"\n        return self._polynomial_factors_y\n\n    @polynomial_factors_y.setter\n    def polynomial_factors_y(self, value: List[Union[float, int]]):\n        if not all(isinstance(f, (float, int)) for f in value):\n            raise TypeError(\n                \"All polynomial_factors_y elements must be float or int.\"\n            )\n        self._polynomial_factors_y = value\n\n    # Setters for surface_compensation_factors and surface_compensation_factors_y\n\n    @property\n    def surface_compensation_factors(self):\n        \"\"\"List of surface compensation factors.\"\"\"\n        return self._surface_compensation_factors\n\n    @surface_compensation_factors.setter\n    def surface_compensation_factors(self, value: List[Union[float, int]]):\n        if not all(isinstance(f, (float, int)) for f in value):\n            raise TypeError(\n                \"All surface_compensation_factors elements must be float or int.\"\n            )\n        self._surface_compensation_factors = value\n\n    @property\n    def surface_compensation_factors_y(self):\n        \"\"\"Surface compensation factors for Y axis (if asymmetric).\"\"\"\n        return self._surface_compensation_factors_y\n\n    @surface_compensation_factors_y.setter\n    def surface_compensation_factors_y(self, value: List[Union[float, int]]):\n        if not all(isinstance(f, (float, int)) for f in value):\n            raise TypeError(\n                \"All surface_compensation_factors_y elements must be float or int.\"\n            )\n        self._surface_compensation_factors_y = value\n\n    def polynomial(\n        self,\n        polynomial_type: str = \"Normalized\",\n        polynomial_factors: List[Union[float, int]] = [0, 0, 0],\n        polynomial_factors_y: List[Union[float, int]] = [0, 0, 0],\n    ):\n        \"\"\"\n        Set the polynomial factors for the lens.\n\n        Parameters:\n            polynomial_type (str): The type of polynomial.\n            polynomial_factors (List[Union[float, int]]):\n                List of polynomial factors.\n            polynomial_factors_y (List[Union[float, int]]):\n                Polynomial factors for Y axis (if asymmetric).\n\n        Returns:\n            self: The updated Lens object.\n        \"\"\"\n        self.polynomial_type = polynomial_type  # Use setter for validation\n        self.polynomial_factors = (\n            polynomial_factors  # Use setter for validation\n        )\n        if self.asymmetric:\n            self.polynomial_factors_y = (\n                polynomial_factors_y  # Use setter for validation\n            )\n        return self\n\n    def surface_compensation(\n        self,\n        surface_compensation_factors: List[Union[float, int]] = [0, 0, 0],\n        surface_compensation_factors_y: List[Union[float, int]] = [0, 0, 0],\n    ):\n        \"\"\"\n        Set the surface compensation factors for the lens.\n\n        Parameters:\n            surface_compensation_factors (List[Union[float, int]]):\n                Surface compensation factors.\n            surface_compensation_factors_y (List[Union[float, int]]):\n                Surface compensation factors for Y axis (if asymmetric).\n\n        Returns:\n            self: The updated Lens object.\n        \"\"\"\n        self.surface_compensation_factors = (\n            surface_compensation_factors  # Use setter for validation\n        )\n        if self.asymmetric:\n            self.surface_compensation_factors_y = (\n                surface_compensation_factors_y  # Use setter for validation\n            )\n        return self\n\n    def auto_load(\n        self,\n        project: Project,\n    ):\n        \"\"\"\n        Load passed presets to passed project if the flags are set.\n        \"\"\"\n        self.project = project\n\n        if self.load_preset:\n            self.project.load_presets(self.preset)\n\n        if self.load_mesh:\n            if self.mesh._type != \"mesh_file\":\n                raise TypeError(\n                    \"Images are used only for MarkerAligner class.\"\n                )\n            self.project.load_resources(self.mesh)\n        return self\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the lens to a dictionary representation.\n\n        Returns:\n            dict: The dictionary representation of the lens.\n        \"\"\"\n        self.geometry = {\n            \"type\": \"lens\",\n            \"radius\": self.radius,\n            \"height\": self.height,\n            \"crop_base\": self.crop_base,\n            \"asymmetric\": self.asymmetric,\n            \"curvature\": self.curvature,\n            \"conic_constant\": self.conic_constant,\n            \"curvature_y\": self.curvature_y,\n            \"conic_constant_y\": self.conic_constant_y,\n            \"polynomial_type\": self.polynomial_type,\n            \"polynomial_factors\": self.polynomial_factors,\n            \"polynomial_factors_y\": self.polynomial_factors_y,\n            \"surface_compensation_factors\": self.surface_compensation_factors,\n            \"surface_compensation_factors_y\": self.surface_compensation_factors_y,\n            \"nr_radial_segments\": self.nr_radial_segments,\n            \"nr_phi_segments\": self.nr_phi_segments,\n        }\n\n        node_dict = super().to_dict()\n        node_dict[\"geometry\"] = self.geometry\n        return node_dict\n</code></pre>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.asymmetric","title":"<code>asymmetric</code>  <code>property</code> <code>writable</code>","text":"<p>Whether the lens is asymmetric.</p>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.conic_constant","title":"<code>conic_constant</code>  <code>property</code> <code>writable</code>","text":"<p>The conic constant of the lens.</p>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.conic_constant_y","title":"<code>conic_constant_y</code>  <code>property</code> <code>writable</code>","text":"<p>The conic constant in the Y direction.</p>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.crop_base","title":"<code>crop_base</code>  <code>property</code> <code>writable</code>","text":"<p>Whether the lens base should be cropped.</p>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.curvature","title":"<code>curvature</code>  <code>property</code> <code>writable</code>","text":"<p>The curvature of the lens.</p>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.curvature_y","title":"<code>curvature_y</code>  <code>property</code> <code>writable</code>","text":"<p>The curvature of the lens in the Y direction.</p>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.height","title":"<code>height</code>  <code>property</code> <code>writable</code>","text":"<p>The height of the lens.</p>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.nr_phi_segments","title":"<code>nr_phi_segments</code>  <code>property</code> <code>writable</code>","text":"<p>The number of phi segments for the lens.</p>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.nr_radial_segments","title":"<code>nr_radial_segments</code>  <code>property</code> <code>writable</code>","text":"<p>The number of radial segments for the lens.</p>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.polynomial_factors","title":"<code>polynomial_factors</code>  <code>property</code> <code>writable</code>","text":"<p>List of polynomial factors.</p>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.polynomial_factors_y","title":"<code>polynomial_factors_y</code>  <code>property</code> <code>writable</code>","text":"<p>Polynomial factors for Y axis (if asymmetric).</p>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.polynomial_type","title":"<code>polynomial_type</code>  <code>property</code> <code>writable</code>","text":"<p>The type of polynomial ('Normalized' or 'Standard').</p>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.radius","title":"<code>radius</code>  <code>property</code> <code>writable</code>","text":"<p>The radius of the lens.</p>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.surface_compensation_factors","title":"<code>surface_compensation_factors</code>  <code>property</code> <code>writable</code>","text":"<p>List of surface compensation factors.</p>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.surface_compensation_factors_y","title":"<code>surface_compensation_factors_y</code>  <code>property</code> <code>writable</code>","text":"<p>Surface compensation factors for Y axis (if asymmetric).</p>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.__init__","title":"<code>__init__(preset, name='Lens', radius=100.0, height=50.0, crop_base=False, asymmetric=False, curvature=0.01, conic_constant=0.01, curvature_y=0.01, conic_constant_y=-1.0, nr_radial_segments=500, nr_phi_segments=360, slicing_origin='scene_bottom', slicing_offset=0.0, priority=0, expose_individually=False, position=[0.0, 0.0, 0.0], rotation=[0.0, 0.0, 0.0], color='lightblue')</code>","text":"<p>Initialize a Lens node with optical properties.</p> <p>Parameters:</p> Name Type Description Default <code>preset</code> <code>Preset</code> <p>The preset associated with the lens.</p> required <code>name</code> <code>str</code> <p>The name of the lens.</p> <code>'Lens'</code> <code>radius</code> <code>Union[float, int]</code> <p>The radius of the lens. Must be &gt; 0.</p> <code>100.0</code> <code>height</code> <code>Union[float, int]</code> <p>The height of the lens. Must be &gt; 0.</p> <code>50.0</code> <code>crop_base</code> <code>bool</code> <p>Whether to crop the base of the lens.</p> <code>False</code> <code>asymmetric</code> <code>bool</code> <p>Whether the lens is asymmetric.</p> <code>False</code> <code>curvature</code> <code>Union[float, int]</code> <p>The curvature of the lens.</p> <code>0.01</code> <code>conic_constant</code> <code>Union[float, int]</code> <p>The conic constant of the lens.</p> <code>0.01</code> <code>curvature_y</code> <code>Union[float, int]</code> <p>The curvature in the Y direction (if asymmetric).</p> <code>0.01</code> <code>conic_constant_y</code> <code>Union[float, int]</code> <p>The conic constant in the Y direction.</p> <code>-1.0</code> <code>nr_radial_segments</code> <code>int</code> <p>The number of radial segments.</p> <code>500</code> <code>nr_phi_segments</code> <code>int</code> <p>The number of phi segments.</p> <code>360</code> <code>slicing_origin</code> <code>str</code> <p>The slicing origin.</p> <code>'scene_bottom'</code> <code>slicing_offset</code> <code>Union[float, int]</code> <p>The slicing offset.</p> <code>0.0</code> <code>priority</code> <code>int</code> <p>The priority of the lens.</p> <code>0</code> <code>expose_individually</code> <code>bool</code> <p>Whether to expose the lens individually.</p> <code>False</code> <code>position</code> <code>List[Union[float, int]]</code> <p>The position of the lens [x, y, z].</p> <code>[0.0, 0.0, 0.0]</code> <code>rotation</code> <code>List[Union[float, int]]</code> <p>The rotation of the lens [psi, theta, phi].</p> <code>[0.0, 0.0, 0.0]</code> Source code in <code>npxpy/nodes/structures.py</code> <pre><code>def __init__(\n    self,\n    preset: Preset,\n    name: str = \"Lens\",\n    radius: Union[float, int] = 100.0,\n    height: Union[float, int] = 50.0,\n    crop_base: bool = False,\n    asymmetric: bool = False,\n    curvature: Union[float, int] = 0.01,\n    conic_constant: Union[float, int] = 0.01,\n    curvature_y: Union[float, int] = 0.01,\n    conic_constant_y: Union[float, int] = -1.0,\n    nr_radial_segments: int = 500,\n    nr_phi_segments: int = 360,\n    slicing_origin: str = \"scene_bottom\",\n    slicing_offset: Union[float, int] = 0.0,\n    priority: int = 0,\n    expose_individually: bool = False,\n    position: List[Union[float, int]] = [0.0, 0.0, 0.0],\n    rotation: List[Union[float, int]] = [0.0, 0.0, 0.0],\n    color=\"lightblue\",\n):\n    \"\"\"\n    Initialize a Lens node with optical properties.\n\n    Parameters:\n        preset (Preset): The preset associated with the lens.\n        name (str): The name of the lens.\n        radius (Union[float, int]): The radius of the lens. Must be &gt; 0.\n        height (Union[float, int]): The height of the lens. Must be &gt; 0.\n        crop_base (bool): Whether to crop the base of the lens.\n        asymmetric (bool): Whether the lens is asymmetric.\n        curvature (Union[float, int]): The curvature of the lens.\n        conic_constant (Union[float, int]): The conic constant of the lens.\n        curvature_y (Union[float, int]): The curvature in the Y direction (if asymmetric).\n        conic_constant_y (Union[float, int]): The conic constant in the Y direction.\n        nr_radial_segments (int): The number of radial segments.\n        nr_phi_segments (int): The number of phi segments.\n        slicing_origin (str): The slicing origin.\n        slicing_offset (Union[float, int]): The slicing offset.\n        priority (int): The priority of the lens.\n        expose_individually (bool): Whether to expose the lens individually.\n        position (List[Union[float, int]]): The position of the lens [x, y, z].\n        rotation (List[Union[float, int]]): The rotation of the lens [psi, theta, phi].\n    \"\"\"\n    super().__init__(\n        preset=preset,\n        mesh=None,\n        name=name,\n        slicing_origin=slicing_origin,\n        slicing_offset=slicing_offset,\n        priority=priority,\n        expose_individually=expose_individually,\n        rotation=rotation,\n        position=position,\n        color=color,\n    )\n\n    # Setters for validation\n    self.radius = radius\n    self.height = height\n    self.crop_base = crop_base\n    self.asymmetric = asymmetric\n    self.curvature = curvature\n    self.conic_constant = conic_constant\n    self.curvature_y = curvature_y\n    self.conic_constant_y = conic_constant_y\n    self.nr_radial_segments = nr_radial_segments\n    self.nr_phi_segments = nr_phi_segments\n\n    self.polynomial_type = \"Normalized\"\n    self.polynomial_factors = []\n    self.polynomial_factors_y = []\n\n    self.surface_compensation_factors = []\n    self.surface_compensation_factors_y = []\n\n    self.load_mesh = False\n    self.load_preset = True\n\n    #  This guy sits in Structure. Ensures no mesh is passed.\n    self._mesh = False\n</code></pre>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.auto_load","title":"<code>auto_load(project)</code>","text":"<p>Load passed presets to passed project if the flags are set.</p> Source code in <code>npxpy/nodes/structures.py</code> <pre><code>def auto_load(\n    self,\n    project: Project,\n):\n    \"\"\"\n    Load passed presets to passed project if the flags are set.\n    \"\"\"\n    self.project = project\n\n    if self.load_preset:\n        self.project.load_presets(self.preset)\n\n    if self.load_mesh:\n        if self.mesh._type != \"mesh_file\":\n            raise TypeError(\n                \"Images are used only for MarkerAligner class.\"\n            )\n        self.project.load_resources(self.mesh)\n    return self\n</code></pre>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.polynomial","title":"<code>polynomial(polynomial_type='Normalized', polynomial_factors=[0, 0, 0], polynomial_factors_y=[0, 0, 0])</code>","text":"<p>Set the polynomial factors for the lens.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_type</code> <code>str</code> <p>The type of polynomial.</p> <code>'Normalized'</code> <code>polynomial_factors</code> <code>List[Union[float, int]]</code> <p>List of polynomial factors.</p> <code>[0, 0, 0]</code> <code>polynomial_factors_y</code> <code>List[Union[float, int]]</code> <p>Polynomial factors for Y axis (if asymmetric).</p> <code>[0, 0, 0]</code> <p>Returns:</p> Name Type Description <code>self</code> <p>The updated Lens object.</p> Source code in <code>npxpy/nodes/structures.py</code> <pre><code>def polynomial(\n    self,\n    polynomial_type: str = \"Normalized\",\n    polynomial_factors: List[Union[float, int]] = [0, 0, 0],\n    polynomial_factors_y: List[Union[float, int]] = [0, 0, 0],\n):\n    \"\"\"\n    Set the polynomial factors for the lens.\n\n    Parameters:\n        polynomial_type (str): The type of polynomial.\n        polynomial_factors (List[Union[float, int]]):\n            List of polynomial factors.\n        polynomial_factors_y (List[Union[float, int]]):\n            Polynomial factors for Y axis (if asymmetric).\n\n    Returns:\n        self: The updated Lens object.\n    \"\"\"\n    self.polynomial_type = polynomial_type  # Use setter for validation\n    self.polynomial_factors = (\n        polynomial_factors  # Use setter for validation\n    )\n    if self.asymmetric:\n        self.polynomial_factors_y = (\n            polynomial_factors_y  # Use setter for validation\n        )\n    return self\n</code></pre>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.surface_compensation","title":"<code>surface_compensation(surface_compensation_factors=[0, 0, 0], surface_compensation_factors_y=[0, 0, 0])</code>","text":"<p>Set the surface compensation factors for the lens.</p> <p>Parameters:</p> Name Type Description Default <code>surface_compensation_factors</code> <code>List[Union[float, int]]</code> <p>Surface compensation factors.</p> <code>[0, 0, 0]</code> <code>surface_compensation_factors_y</code> <code>List[Union[float, int]]</code> <p>Surface compensation factors for Y axis (if asymmetric).</p> <code>[0, 0, 0]</code> <p>Returns:</p> Name Type Description <code>self</code> <p>The updated Lens object.</p> Source code in <code>npxpy/nodes/structures.py</code> <pre><code>def surface_compensation(\n    self,\n    surface_compensation_factors: List[Union[float, int]] = [0, 0, 0],\n    surface_compensation_factors_y: List[Union[float, int]] = [0, 0, 0],\n):\n    \"\"\"\n    Set the surface compensation factors for the lens.\n\n    Parameters:\n        surface_compensation_factors (List[Union[float, int]]):\n            Surface compensation factors.\n        surface_compensation_factors_y (List[Union[float, int]]):\n            Surface compensation factors for Y axis (if asymmetric).\n\n    Returns:\n        self: The updated Lens object.\n    \"\"\"\n    self.surface_compensation_factors = (\n        surface_compensation_factors  # Use setter for validation\n    )\n    if self.asymmetric:\n        self.surface_compensation_factors_y = (\n            surface_compensation_factors_y  # Use setter for validation\n        )\n    return self\n</code></pre>"},{"location":"nodes/structures/Lens/#npxpy.nodes.structures.Lens.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the lens to a dictionary representation.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the lens.</p> Source code in <code>npxpy/nodes/structures.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the lens to a dictionary representation.\n\n    Returns:\n        dict: The dictionary representation of the lens.\n    \"\"\"\n    self.geometry = {\n        \"type\": \"lens\",\n        \"radius\": self.radius,\n        \"height\": self.height,\n        \"crop_base\": self.crop_base,\n        \"asymmetric\": self.asymmetric,\n        \"curvature\": self.curvature,\n        \"conic_constant\": self.conic_constant,\n        \"curvature_y\": self.curvature_y,\n        \"conic_constant_y\": self.conic_constant_y,\n        \"polynomial_type\": self.polynomial_type,\n        \"polynomial_factors\": self.polynomial_factors,\n        \"polynomial_factors_y\": self.polynomial_factors_y,\n        \"surface_compensation_factors\": self.surface_compensation_factors,\n        \"surface_compensation_factors_y\": self.surface_compensation_factors_y,\n        \"nr_radial_segments\": self.nr_radial_segments,\n        \"nr_phi_segments\": self.nr_phi_segments,\n    }\n\n    node_dict = super().to_dict()\n    node_dict[\"geometry\"] = self.geometry\n    return node_dict\n</code></pre>"},{"location":"nodes/structures/Structure/","title":"npxpy.nodes.structures.Structure","text":"<p>               Bases: <code>_GatekeeperSpace</code></p> <p>A class representing a structure node.</p> <p>Attributes:</p> Name Type Description <code>preset</code> <code>Preset</code> <p>The preset associated with the structure.</p> <code>mesh</code> <code>Mesh</code> <p>The mesh object used for the structure.</p> <code>load_preset</code> <code>bool</code> <p>Flag to auto-load presets.</p> <code>load_mesh</code> <code>bool</code> <p>Flag to auto-load resources.</p> <code>size</code> <code>List[Union[float, int]]</code> <p>The size (scaling) of the structure.</p> <code>name</code> <code>str</code> <p>The name of the structure.</p> <code>slicing_origin</code> <code>str</code> <p>The origin for slicing.</p> <code>slicing_offset</code> <code>Union[float, int]</code> <p>The offset for slicing.</p> <code>priority</code> <code>int</code> <p>The priority of the structure.</p> <code>expose_individually</code> <code>bool</code> <p>Flag to expose the structure individually.</p> <code>position</code> <code>List[Union[float, int]]</code> <p>Position of the structure.</p> <code>rotation</code> <code>List[Union[float, int]]</code> <p>Rotation of the structure.</p> Source code in <code>npxpy/nodes/structures.py</code> <pre><code>class Structure(_GatekeeperSpace):\n    \"\"\"\n    A class representing a structure node.\n\n    Attributes:\n        preset (Preset): The preset associated with the structure.\n        mesh (Mesh): The mesh object used for the structure.\n        load_preset (bool): Flag to auto-load presets.\n        load_mesh (bool): Flag to auto-load resources.\n        size (List[Union[float, int]]): The size (scaling) of the structure.\n        name (str): The name of the structure.\n        slicing_origin (str): The origin for slicing.\n        slicing_offset (Union[float, int]): The offset for slicing.\n        priority (int): The priority of the structure.\n        expose_individually (bool): Flag to expose the structure individually.\n        position (List[Union[float, int]]): Position of the structure.\n        rotation (List[Union[float, int]]): Rotation of the structure.\n    \"\"\"\n\n    def __init__(\n        self,\n        preset: Preset,\n        mesh: Mesh,\n        size: List[Union[float, int]] = [100.0, 100.0, 100.0],\n        name: str = \"Structure\",\n        slicing_origin: str = \"scene_bottom\",\n        slicing_offset: Union[float, int] = 0.0,\n        priority: int = 0,\n        expose_individually: bool = False,\n        position: List[Union[float, int]] = [0, 0, 0],\n        rotation: List[Union[float, int]] = [0.0, 0.0, 0.0],\n        color=\"#16506B\",\n    ):\n        \"\"\"\n        Initialize a Structure node.\n\n        Parameters:\n            preset (Optional[Preset]): The preset associated with the structure.\n            mesh (Optional[Mesh]): The mesh object to be used for the structure.\n            load_preset (bool): Flag to auto-load presets.\n            load_mesh (bool): Flag to auto-load resources.\n            size (List[Union[float, int]]): The size of the structure in micrometers [x, y, z].\n            name (str): The name of the structure.\n            slicing_origin (str): The origin for slicing. Must be one of\n                                  'structure_center', 'zero', 'scene_top', 'scene_bottom',\n                                  'structure_top', 'structure_bottom', 'scene_center'.\n            slicing_offset (Union[float, int]): The offset for slicing.\n            priority (int): The priority of the structure. Must be &gt;= 0.\n            expose_individually (bool): Flag to expose the structure individually.\n            position (List[Union[float, int]]): The position of the structure [x, y, z].\n            rotation (List[Union[float, int]]): The rotation of the structure [psi, theta, phi].\n        \"\"\"\n        super().__init__(\n            \"structure\",\n            name,\n        )\n\n        # Setters for attributes with validation\n        self.slicing_origin_reference = slicing_origin\n        self.slicing_offset = slicing_offset\n        self.priority = priority\n        self.expose_individually = expose_individually\n        self.preset = preset\n        self.mesh = mesh\n        self.project = None\n        self.size = size\n        self.position = position\n        self.rotation = rotation\n        self.color = color\n\n        self._mesh = True\n\n    @property\n    def slicing_origin(self):\n        \"\"\"The origin for slicing.\"\"\"\n        return self._slicing_origin\n\n    @slicing_origin.setter\n    def slicing_origin(self, value: str):\n        if not isinstance(value, str) or value not in [\n            \"zero\",\n            \"structure_top\",\n            \"scene_center\",\n            \"structure_center\",\n            \"scene_top\",\n            \"structure_bottom\",\n            \"scene_bottom\",\n        ]:\n            valids = [\n                \"zero\",\n                \"structure_top\",\n                \"scene_center\",\n                \"structure_center\",\n                \"scene_top\",\n                \"structure_bottom\",\n                \"scene_bottom\",\n            ]\n            raise TypeError(\n                \"slicing_origin must be a string. \"\n                f\"Valid inputs are: {valids}\"\n            )\n        # Add any specific value constraints here if needed (e.g., valid slicing origins)\n        self._slicing_origin = value\n\n    @property\n    def slicing_offset(self):\n        \"\"\"The offset for slicing.\"\"\"\n        return self._slicing_offset\n\n    @slicing_offset.setter\n    def slicing_offset(self, value: Union[float, int]):\n        if not isinstance(value, (float, int)):\n            raise TypeError(\"slicing_offset must be a float or an int.\")\n        self._slicing_offset = value\n\n    @property\n    def priority(self):\n        \"\"\"The priority of the structure.\"\"\"\n        return self._priority\n\n    @priority.setter\n    def priority(self, value: int):\n        if not isinstance(value, int):\n            raise TypeError(\"priority must be an integer.\")\n        if value &lt; 0:\n            raise ValueError(\"priority must be greater than or equal to 0.\")\n        self._priority = value\n\n    @property\n    def expose_individually(self):\n        \"\"\"Flag to expose the structure individually.\"\"\"\n        return self._expose_individually\n\n    @expose_individually.setter\n    def expose_individually(self, value: bool):\n        if not isinstance(value, bool):\n            raise TypeError(\"expose_individually must be a boolean.\")\n        self._expose_individually = value\n\n    # Setters with validation\n    @property\n    def preset(self):\n        \"\"\"The preset used for the structure.\"\"\"\n        return self._preset\n\n    @preset.setter\n    def preset(self, value: Optional[Preset]):\n        if value is not None and not isinstance(value, Preset):\n            raise TypeError(\"preset must be an instance of Preset or None.\")\n        self._preset = value\n\n    @property\n    def mesh(self):\n        \"\"\"The mesh used for the structure.\"\"\"\n        return self._mesh_obj\n\n    @mesh.setter\n    def mesh(self, value: Optional[Mesh]):\n        if value is not None and not isinstance(value, Mesh):\n            raise TypeError(\"mesh must be an instance of Mesh or None.\")\n        self._mesh_obj = value\n\n    @property\n    def project(self):\n        \"\"\"The project context associated with the structure.\"\"\"\n        return self._project\n\n    @project.setter\n    def project(self, value: Optional[Project]):\n        if value is not None and not isinstance(value, Project):\n            raise TypeError(\"project must be an instance of Project or None.\")\n        self._project = value\n\n    @property\n    def load_preset(self):\n        \"\"\"Flag to determine whether presets are auto-loaded.\"\"\"\n        return self._load_preset\n\n    @load_preset.setter\n    def load_preset(self, value: bool):\n        if not isinstance(value, bool):\n            raise TypeError(\"load_preset must be a boolean.\")\n        self._load_preset = value\n\n    @property\n    def load_mesh(self):\n        \"\"\"Flag to determine whether resources are auto-loaded.\"\"\"\n        return self._load_mesh\n\n    @load_mesh.setter\n    def load_mesh(self, value: bool):\n        if not isinstance(value, bool):\n            raise TypeError(\"load_mesh must be a boolean.\")\n        self._load_mesh = value\n\n    @property\n    def size(self):\n        \"\"\"The size (scaling) of the structure.\"\"\"\n        return self._size\n\n    @size.setter\n    def size(self, value: List[Union[float, int]]):\n        if not all(isinstance(s, (float, int)) for s in value):\n            raise TypeError(\"All size elements must be float or int.\")\n        self._size = value\n\n    @property\n    def color(self):\n        \"\"\"The color of the structure inside the viewport.\"\"\"\n        return self._color\n\n    @color.setter\n    def color(self, value: str):\n        if not isinstance(value, str):\n            raise TypeError(\n                \"color must be a string. A non-valid string will default to black.\"\n            )\n        self._color = value\n\n    def position_at(\n        self,\n        position: List[Union[float, int]] = [0, 0, 0],\n        rotation: List[Union[float, int]] = None,\n    ):\n        \"\"\"\n        Set the current position and rotation of the structure.\n\n        Parameters:\n            position (List[Union[float, int]]): Position values [x, y, z].\n            rotation (List[Union[float, int]]): Rotation values [psi, theta, phi].\n\n        Returns:\n            self: The updated Structure object.\n        \"\"\"\n        if rotation is not None:\n            self.position = position\n            self.rotation = rotation\n        else:\n            self.position = position\n        return self\n\n    def translate(self, translation: List[Union[float, int]]):\n        \"\"\"\n        Translate the structure by the specified values.\n\n        Parameters:\n            translation (List[Union[float, int]]): Translation values [dx, dy, dz].\n        \"\"\"\n        if len(translation) != 3 or not all(\n            isinstance(t, (float, int)) for t in translation\n        ):\n            raise ValueError(\n                \"Translation must be a list of three numeric elements.\"\n            )\n        self.position = [p + t for p, t in zip(self.position, translation)]\n        return self\n\n    def rotate(self, rotation: List[Union[float, int]]):\n        \"\"\"\n        Rotate the structure by the specified values.\n\n        Parameters:\n            rotation (List[Union[float, int]]): Rotation angles to apply [d_psi, d_theta, d_phi].\n        \"\"\"\n        if len(rotation) != 3 or not all(\n            isinstance(r, (float, int)) for r in rotation\n        ):\n            raise ValueError(\n                \"Rotation must be a list of three numeric elements.\"\n            )\n        self.rotation = [\n            (r + delta) % 360 for r, delta in zip(self.rotation, rotation)\n        ]\n        return self\n\n    def auto_load(\n        self: Struct,\n        project: Project,\n        load_mesh: bool = True,\n        load_preset: bool = True,\n    ) -&gt; Struct:\n        \"\"\"\n        Load passed presets and meshes to passed project if the flags are set.\n        \"\"\"\n        self.project = project\n        self.load_mesh = load_mesh\n        self.load_preset = load_preset\n\n        if self.load_preset:\n            self.project.load_presets(self.preset)\n\n        if self.load_mesh:\n            if self.mesh._type != \"mesh_file\":\n                raise TypeError(\n                    \"Images are used only for MarkerAligner class.\"\n                )\n            self.project.load_resources(self.mesh)\n        return self\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the structure to a dictionary representation.\n\n        Returns:\n            dict: The dictionary representation of the structure.\n        \"\"\"\n        if self._mesh:\n            self.geometry = {\n                \"type\": \"mesh\",\n                \"resource\": self.mesh.id,\n                \"scale\": [\n                    self.size[0] / 100,\n                    self.size[1] / 100,\n                    self.size[2] / 100,\n                ],\n            }\n        node_dict = super().to_dict()\n        node_dict[\"preset\"] = self.preset.id if self.preset else None\n        node_dict[\"properties\"] = {\"color\": self.color}\n        node_dict[\"geometry\"] = self.geometry\n        node_dict[\"slicing_origin_reference\"] = self.slicing_origin_reference\n        node_dict[\"slicing_offset\"] = self.slicing_offset\n        node_dict[\"priority\"] = self.priority\n        node_dict[\"expose_individually\"] = self.expose_individually\n\n        return node_dict\n</code></pre>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.color","title":"<code>color</code>  <code>property</code> <code>writable</code>","text":"<p>The color of the structure inside the viewport.</p>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.expose_individually","title":"<code>expose_individually</code>  <code>property</code> <code>writable</code>","text":"<p>Flag to expose the structure individually.</p>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.load_mesh","title":"<code>load_mesh</code>  <code>property</code> <code>writable</code>","text":"<p>Flag to determine whether resources are auto-loaded.</p>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.load_preset","title":"<code>load_preset</code>  <code>property</code> <code>writable</code>","text":"<p>Flag to determine whether presets are auto-loaded.</p>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.mesh","title":"<code>mesh</code>  <code>property</code> <code>writable</code>","text":"<p>The mesh used for the structure.</p>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.preset","title":"<code>preset</code>  <code>property</code> <code>writable</code>","text":"<p>The preset used for the structure.</p>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.priority","title":"<code>priority</code>  <code>property</code> <code>writable</code>","text":"<p>The priority of the structure.</p>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.project","title":"<code>project</code>  <code>property</code> <code>writable</code>","text":"<p>The project context associated with the structure.</p>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.size","title":"<code>size</code>  <code>property</code> <code>writable</code>","text":"<p>The size (scaling) of the structure.</p>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.slicing_offset","title":"<code>slicing_offset</code>  <code>property</code> <code>writable</code>","text":"<p>The offset for slicing.</p>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.slicing_origin","title":"<code>slicing_origin</code>  <code>property</code> <code>writable</code>","text":"<p>The origin for slicing.</p>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.__init__","title":"<code>__init__(preset, mesh, size=[100.0, 100.0, 100.0], name='Structure', slicing_origin='scene_bottom', slicing_offset=0.0, priority=0, expose_individually=False, position=[0, 0, 0], rotation=[0.0, 0.0, 0.0], color='#16506B')</code>","text":"<p>Initialize a Structure node.</p> <p>Parameters:</p> Name Type Description Default <code>preset</code> <code>Optional[Preset]</code> <p>The preset associated with the structure.</p> required <code>mesh</code> <code>Optional[Mesh]</code> <p>The mesh object to be used for the structure.</p> required <code>load_preset</code> <code>bool</code> <p>Flag to auto-load presets.</p> required <code>load_mesh</code> <code>bool</code> <p>Flag to auto-load resources.</p> required <code>size</code> <code>List[Union[float, int]]</code> <p>The size of the structure in micrometers [x, y, z].</p> <code>[100.0, 100.0, 100.0]</code> <code>name</code> <code>str</code> <p>The name of the structure.</p> <code>'Structure'</code> <code>slicing_origin</code> <code>str</code> <p>The origin for slicing. Must be one of                   'structure_center', 'zero', 'scene_top', 'scene_bottom',                   'structure_top', 'structure_bottom', 'scene_center'.</p> <code>'scene_bottom'</code> <code>slicing_offset</code> <code>Union[float, int]</code> <p>The offset for slicing.</p> <code>0.0</code> <code>priority</code> <code>int</code> <p>The priority of the structure. Must be &gt;= 0.</p> <code>0</code> <code>expose_individually</code> <code>bool</code> <p>Flag to expose the structure individually.</p> <code>False</code> <code>position</code> <code>List[Union[float, int]]</code> <p>The position of the structure [x, y, z].</p> <code>[0, 0, 0]</code> <code>rotation</code> <code>List[Union[float, int]]</code> <p>The rotation of the structure [psi, theta, phi].</p> <code>[0.0, 0.0, 0.0]</code> Source code in <code>npxpy/nodes/structures.py</code> <pre><code>def __init__(\n    self,\n    preset: Preset,\n    mesh: Mesh,\n    size: List[Union[float, int]] = [100.0, 100.0, 100.0],\n    name: str = \"Structure\",\n    slicing_origin: str = \"scene_bottom\",\n    slicing_offset: Union[float, int] = 0.0,\n    priority: int = 0,\n    expose_individually: bool = False,\n    position: List[Union[float, int]] = [0, 0, 0],\n    rotation: List[Union[float, int]] = [0.0, 0.0, 0.0],\n    color=\"#16506B\",\n):\n    \"\"\"\n    Initialize a Structure node.\n\n    Parameters:\n        preset (Optional[Preset]): The preset associated with the structure.\n        mesh (Optional[Mesh]): The mesh object to be used for the structure.\n        load_preset (bool): Flag to auto-load presets.\n        load_mesh (bool): Flag to auto-load resources.\n        size (List[Union[float, int]]): The size of the structure in micrometers [x, y, z].\n        name (str): The name of the structure.\n        slicing_origin (str): The origin for slicing. Must be one of\n                              'structure_center', 'zero', 'scene_top', 'scene_bottom',\n                              'structure_top', 'structure_bottom', 'scene_center'.\n        slicing_offset (Union[float, int]): The offset for slicing.\n        priority (int): The priority of the structure. Must be &gt;= 0.\n        expose_individually (bool): Flag to expose the structure individually.\n        position (List[Union[float, int]]): The position of the structure [x, y, z].\n        rotation (List[Union[float, int]]): The rotation of the structure [psi, theta, phi].\n    \"\"\"\n    super().__init__(\n        \"structure\",\n        name,\n    )\n\n    # Setters for attributes with validation\n    self.slicing_origin_reference = slicing_origin\n    self.slicing_offset = slicing_offset\n    self.priority = priority\n    self.expose_individually = expose_individually\n    self.preset = preset\n    self.mesh = mesh\n    self.project = None\n    self.size = size\n    self.position = position\n    self.rotation = rotation\n    self.color = color\n\n    self._mesh = True\n</code></pre>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.auto_load","title":"<code>auto_load(project, load_mesh=True, load_preset=True)</code>","text":"<p>Load passed presets and meshes to passed project if the flags are set.</p> Source code in <code>npxpy/nodes/structures.py</code> <pre><code>def auto_load(\n    self: Struct,\n    project: Project,\n    load_mesh: bool = True,\n    load_preset: bool = True,\n) -&gt; Struct:\n    \"\"\"\n    Load passed presets and meshes to passed project if the flags are set.\n    \"\"\"\n    self.project = project\n    self.load_mesh = load_mesh\n    self.load_preset = load_preset\n\n    if self.load_preset:\n        self.project.load_presets(self.preset)\n\n    if self.load_mesh:\n        if self.mesh._type != \"mesh_file\":\n            raise TypeError(\n                \"Images are used only for MarkerAligner class.\"\n            )\n        self.project.load_resources(self.mesh)\n    return self\n</code></pre>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.position_at","title":"<code>position_at(position=[0, 0, 0], rotation=None)</code>","text":"<p>Set the current position and rotation of the structure.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>List[Union[float, int]]</code> <p>Position values [x, y, z].</p> <code>[0, 0, 0]</code> <code>rotation</code> <code>List[Union[float, int]]</code> <p>Rotation values [psi, theta, phi].</p> <code>None</code> <p>Returns:</p> Name Type Description <code>self</code> <p>The updated Structure object.</p> Source code in <code>npxpy/nodes/structures.py</code> <pre><code>def position_at(\n    self,\n    position: List[Union[float, int]] = [0, 0, 0],\n    rotation: List[Union[float, int]] = None,\n):\n    \"\"\"\n    Set the current position and rotation of the structure.\n\n    Parameters:\n        position (List[Union[float, int]]): Position values [x, y, z].\n        rotation (List[Union[float, int]]): Rotation values [psi, theta, phi].\n\n    Returns:\n        self: The updated Structure object.\n    \"\"\"\n    if rotation is not None:\n        self.position = position\n        self.rotation = rotation\n    else:\n        self.position = position\n    return self\n</code></pre>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.rotate","title":"<code>rotate(rotation)</code>","text":"<p>Rotate the structure by the specified values.</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>List[Union[float, int]]</code> <p>Rotation angles to apply [d_psi, d_theta, d_phi].</p> required Source code in <code>npxpy/nodes/structures.py</code> <pre><code>def rotate(self, rotation: List[Union[float, int]]):\n    \"\"\"\n    Rotate the structure by the specified values.\n\n    Parameters:\n        rotation (List[Union[float, int]]): Rotation angles to apply [d_psi, d_theta, d_phi].\n    \"\"\"\n    if len(rotation) != 3 or not all(\n        isinstance(r, (float, int)) for r in rotation\n    ):\n        raise ValueError(\n            \"Rotation must be a list of three numeric elements.\"\n        )\n    self.rotation = [\n        (r + delta) % 360 for r, delta in zip(self.rotation, rotation)\n    ]\n    return self\n</code></pre>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the structure to a dictionary representation.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the structure.</p> Source code in <code>npxpy/nodes/structures.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the structure to a dictionary representation.\n\n    Returns:\n        dict: The dictionary representation of the structure.\n    \"\"\"\n    if self._mesh:\n        self.geometry = {\n            \"type\": \"mesh\",\n            \"resource\": self.mesh.id,\n            \"scale\": [\n                self.size[0] / 100,\n                self.size[1] / 100,\n                self.size[2] / 100,\n            ],\n        }\n    node_dict = super().to_dict()\n    node_dict[\"preset\"] = self.preset.id if self.preset else None\n    node_dict[\"properties\"] = {\"color\": self.color}\n    node_dict[\"geometry\"] = self.geometry\n    node_dict[\"slicing_origin_reference\"] = self.slicing_origin_reference\n    node_dict[\"slicing_offset\"] = self.slicing_offset\n    node_dict[\"priority\"] = self.priority\n    node_dict[\"expose_individually\"] = self.expose_individually\n\n    return node_dict\n</code></pre>"},{"location":"nodes/structures/Structure/#npxpy.nodes.structures.Structure.translate","title":"<code>translate(translation)</code>","text":"<p>Translate the structure by the specified values.</p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>List[Union[float, int]]</code> <p>Translation values [dx, dy, dz].</p> required Source code in <code>npxpy/nodes/structures.py</code> <pre><code>def translate(self, translation: List[Union[float, int]]):\n    \"\"\"\n    Translate the structure by the specified values.\n\n    Parameters:\n        translation (List[Union[float, int]]): Translation values [dx, dy, dz].\n    \"\"\"\n    if len(translation) != 3 or not all(\n        isinstance(t, (float, int)) for t in translation\n    ):\n        raise ValueError(\n            \"Translation must be a list of three numeric elements.\"\n        )\n    self.position = [p + t for p, t in zip(self.position, translation)]\n    return self\n</code></pre>"},{"location":"nodes/structures/Text/","title":"npxpy.nodes.structures.Text","text":"<p>               Bases: <code>Structure</code></p> <p>A class representing a text node.</p> <p>Attributes:</p> Name Type Description <code>text</code> <code>str</code> <p>The text content.</p> <code>font_size</code> <code>Union[float, int]</code> <p>The font size of the text.</p> <code>height</code> <code>Union[float, int]</code> <p>The height of the text.</p> Source code in <code>npxpy/nodes/structures.py</code> <pre><code>class Text(Structure):\n    \"\"\"\n    A class representing a text node.\n\n    Attributes:\n        text (str): The text content.\n        font_size (Union[float, int]): The font size of the text.\n        height (Union[float, int]): The height of the text.\n    \"\"\"\n\n    def __init__(\n        self,\n        preset: Preset,\n        name: str = \"Text\",\n        text: str = \"Text\",\n        font_size: Union[float, int] = 10.0,\n        height: Union[float, int] = 5.0,\n        slicing_origin: str = \"scene_bottom\",\n        slicing_offset: Union[float, int] = 0.0,\n        priority: int = 0,\n        expose_individually: bool = False,\n        position: List[Union[float, int]] = [0, 0, 0],\n        rotation: List[Union[float, int]] = [0.0, 0.0, 0.0],\n        color=\"lightblue\",\n    ):\n        \"\"\"\n        Initialize a Text node.\n\n        Parameters:\n            preset (Preset): The preset associated with the text.\n            name (str): The name of the text.\n            text (str): The text content.\n            font_size (Union[float, int]): The font size of the text. Must be greater than 0.\n            height (Union[float, int]): The height of the text. Must be greater than 0.\n            slicing_origin (str): The origin for slicing. Must be one of\n                                  'structure_center', 'zero', 'scene_top', 'scene_bottom',\n                                  'structure_top', 'structure_bottom', 'scene_center'.\n            slicing_offset (Union[float, int]): The offset for slicing.\n            priority (int): The priority of the text. Must be &gt;= 0.\n            expose_individually (bool): Flag to expose the text individually.\n            position (List[Union[float, int]]): The position of the text [x, y, z].\n            rotation (List[Union[float, int]]): The rotation of the text [psi, theta, phi].\n        \"\"\"\n        super().__init__(\n            preset=preset,\n            mesh=None,\n            name=name,\n            slicing_origin=slicing_origin,\n            slicing_offset=slicing_offset,\n            priority=priority,\n            expose_individually=expose_individually,\n            position=position,\n            rotation=rotation,\n            color=color,\n        )\n\n        # Setters for validation\n        self.text = text\n        self.font_size = font_size\n        self.height = height\n\n        self.load_mesh = False\n        self.load_preset = True\n\n        #  This guy sits in Structure. Ensures no mesh is passed.\n        self._mesh = False\n\n    @property\n    def text(self):\n        \"\"\"The text content of the node.\"\"\"\n        return self._text\n\n    @text.setter\n    def text(self, value: str):\n        if not isinstance(value, str):\n            raise TypeError(\"text must be a string.\")\n        self._text = value\n\n    @property\n    def font_size(self):\n        \"\"\"The font size of the text.\"\"\"\n        return self._font_size\n\n    @font_size.setter\n    def font_size(self, value: Union[float, int]):\n        if not isinstance(value, (float, int)) or value &lt;= 0:\n            raise ValueError(\"font_size must be a positive number.\")\n        self._font_size = value\n\n    @property\n    def height(self):\n        \"\"\"The height of the text.\"\"\"\n        return self._height\n\n    @height.setter\n    def height(self, value: Union[float, int]):\n        if not isinstance(value, (float, int)) or value &lt;= 0:\n            raise ValueError(\"height must be a positive number.\")\n        self._height = value\n\n    def auto_load(\n        self,\n        project: Project,\n    ):\n        \"\"\"\n        Load passed presets to passed project if the flags are set.\n        \"\"\"\n        self.project = project\n\n        if self.load_preset:\n            self.project.load_presets(self.preset)\n\n        if self.load_mesh:\n            if self.mesh._type != \"mesh_file\":\n                raise TypeError(\n                    \"Images are used only for MarkerAligner class.\"\n                )\n            self.project.load_resources(self.mesh)\n        return self\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the text to a dictionary representation.\n\n        Returns:\n            dict: The dictionary representation of the text.\n        \"\"\"\n        self.geometry = {\n            \"type\": \"text\",\n            \"text\": self.text,\n            \"font_size\": self.font_size,\n            \"height\": self.height,\n        }\n        node_dict = super().to_dict()\n        node_dict[\"geometry\"] = self.geometry\n        return node_dict\n</code></pre>"},{"location":"nodes/structures/Text/#npxpy.nodes.structures.Text.font_size","title":"<code>font_size</code>  <code>property</code> <code>writable</code>","text":"<p>The font size of the text.</p>"},{"location":"nodes/structures/Text/#npxpy.nodes.structures.Text.height","title":"<code>height</code>  <code>property</code> <code>writable</code>","text":"<p>The height of the text.</p>"},{"location":"nodes/structures/Text/#npxpy.nodes.structures.Text.text","title":"<code>text</code>  <code>property</code> <code>writable</code>","text":"<p>The text content of the node.</p>"},{"location":"nodes/structures/Text/#npxpy.nodes.structures.Text.__init__","title":"<code>__init__(preset, name='Text', text='Text', font_size=10.0, height=5.0, slicing_origin='scene_bottom', slicing_offset=0.0, priority=0, expose_individually=False, position=[0, 0, 0], rotation=[0.0, 0.0, 0.0], color='lightblue')</code>","text":"<p>Initialize a Text node.</p> <p>Parameters:</p> Name Type Description Default <code>preset</code> <code>Preset</code> <p>The preset associated with the text.</p> required <code>name</code> <code>str</code> <p>The name of the text.</p> <code>'Text'</code> <code>text</code> <code>str</code> <p>The text content.</p> <code>'Text'</code> <code>font_size</code> <code>Union[float, int]</code> <p>The font size of the text. Must be greater than 0.</p> <code>10.0</code> <code>height</code> <code>Union[float, int]</code> <p>The height of the text. Must be greater than 0.</p> <code>5.0</code> <code>slicing_origin</code> <code>str</code> <p>The origin for slicing. Must be one of                   'structure_center', 'zero', 'scene_top', 'scene_bottom',                   'structure_top', 'structure_bottom', 'scene_center'.</p> <code>'scene_bottom'</code> <code>slicing_offset</code> <code>Union[float, int]</code> <p>The offset for slicing.</p> <code>0.0</code> <code>priority</code> <code>int</code> <p>The priority of the text. Must be &gt;= 0.</p> <code>0</code> <code>expose_individually</code> <code>bool</code> <p>Flag to expose the text individually.</p> <code>False</code> <code>position</code> <code>List[Union[float, int]]</code> <p>The position of the text [x, y, z].</p> <code>[0, 0, 0]</code> <code>rotation</code> <code>List[Union[float, int]]</code> <p>The rotation of the text [psi, theta, phi].</p> <code>[0.0, 0.0, 0.0]</code> Source code in <code>npxpy/nodes/structures.py</code> <pre><code>def __init__(\n    self,\n    preset: Preset,\n    name: str = \"Text\",\n    text: str = \"Text\",\n    font_size: Union[float, int] = 10.0,\n    height: Union[float, int] = 5.0,\n    slicing_origin: str = \"scene_bottom\",\n    slicing_offset: Union[float, int] = 0.0,\n    priority: int = 0,\n    expose_individually: bool = False,\n    position: List[Union[float, int]] = [0, 0, 0],\n    rotation: List[Union[float, int]] = [0.0, 0.0, 0.0],\n    color=\"lightblue\",\n):\n    \"\"\"\n    Initialize a Text node.\n\n    Parameters:\n        preset (Preset): The preset associated with the text.\n        name (str): The name of the text.\n        text (str): The text content.\n        font_size (Union[float, int]): The font size of the text. Must be greater than 0.\n        height (Union[float, int]): The height of the text. Must be greater than 0.\n        slicing_origin (str): The origin for slicing. Must be one of\n                              'structure_center', 'zero', 'scene_top', 'scene_bottom',\n                              'structure_top', 'structure_bottom', 'scene_center'.\n        slicing_offset (Union[float, int]): The offset for slicing.\n        priority (int): The priority of the text. Must be &gt;= 0.\n        expose_individually (bool): Flag to expose the text individually.\n        position (List[Union[float, int]]): The position of the text [x, y, z].\n        rotation (List[Union[float, int]]): The rotation of the text [psi, theta, phi].\n    \"\"\"\n    super().__init__(\n        preset=preset,\n        mesh=None,\n        name=name,\n        slicing_origin=slicing_origin,\n        slicing_offset=slicing_offset,\n        priority=priority,\n        expose_individually=expose_individually,\n        position=position,\n        rotation=rotation,\n        color=color,\n    )\n\n    # Setters for validation\n    self.text = text\n    self.font_size = font_size\n    self.height = height\n\n    self.load_mesh = False\n    self.load_preset = True\n\n    #  This guy sits in Structure. Ensures no mesh is passed.\n    self._mesh = False\n</code></pre>"},{"location":"nodes/structures/Text/#npxpy.nodes.structures.Text.auto_load","title":"<code>auto_load(project)</code>","text":"<p>Load passed presets to passed project if the flags are set.</p> Source code in <code>npxpy/nodes/structures.py</code> <pre><code>def auto_load(\n    self,\n    project: Project,\n):\n    \"\"\"\n    Load passed presets to passed project if the flags are set.\n    \"\"\"\n    self.project = project\n\n    if self.load_preset:\n        self.project.load_presets(self.preset)\n\n    if self.load_mesh:\n        if self.mesh._type != \"mesh_file\":\n            raise TypeError(\n                \"Images are used only for MarkerAligner class.\"\n            )\n        self.project.load_resources(self.mesh)\n    return self\n</code></pre>"},{"location":"nodes/structures/Text/#npxpy.nodes.structures.Text.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the text to a dictionary representation.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the text.</p> Source code in <code>npxpy/nodes/structures.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the text to a dictionary representation.\n\n    Returns:\n        dict: The dictionary representation of the text.\n    \"\"\"\n    self.geometry = {\n        \"type\": \"text\",\n        \"text\": self.text,\n        \"font_size\": self.font_size,\n        \"height\": self.height,\n    }\n    node_dict = super().to_dict()\n    node_dict[\"geometry\"] = self.geometry\n    return node_dict\n</code></pre>"},{"location":"preset/Preset/","title":"npxpy.preset.Preset","text":"<p>A class to represent a preset with various parameters related to writing and hatching settings.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for the preset.</p> <code>name</code> <code>str</code> <p>Name of the preset.</p> <code>valid_objectives</code> <code>List[str]</code> <p>Valid objectives for the preset.</p> <code>valid_resins</code> <code>List[str]</code> <p>Valid resins for the preset.</p> <code>valid_substrates</code> <code>List[str]</code> <p>Valid substrates for the preset.</p> <code>writing_speed</code> <code>float</code> <p>Writing speed.</p> <code>writing_power</code> <code>float</code> <p>Writing power.</p> <code>slicing_spacing</code> <code>float</code> <p>Slicing spacing.</p> <code>hatching_spacing</code> <code>float</code> <p>Hatching spacing.</p> <code>hatching_angle</code> <code>float</code> <p>Hatching angle.</p> <code>hatching_angle_increment</code> <code>float</code> <p>Hatching angle increment.</p> <code>hatching_offset</code> <code>float</code> <p>Hatching offset.</p> <code>hatching_offset_increment</code> <code>float</code> <p>Hatching offset increment.</p> <code>hatching_back_n_forth</code> <code>bool</code> <p>Whether hatching is back and forth.</p> <code>mesh_z_offset</code> <code>float</code> <p>Mesh Z offset.</p> Source code in <code>npxpy/preset.py</code> <pre><code>class Preset:\n    \"\"\"\n    A class to represent a preset with various parameters related to writing\n    and hatching settings.\n\n    Attributes:\n        id (str): Unique identifier for the preset.\n        name (str): Name of the preset.\n        valid_objectives (List[str]): Valid objectives for the preset.\n        valid_resins (List[str]): Valid resins for the preset.\n        valid_substrates (List[str]): Valid substrates for the preset.\n        writing_speed (float): Writing speed.\n        writing_power (float): Writing power.\n        slicing_spacing (float): Slicing spacing.\n        hatching_spacing (float): Hatching spacing.\n        hatching_angle (float): Hatching angle.\n        hatching_angle_increment (float): Hatching angle increment.\n        hatching_offset (float): Hatching offset.\n        hatching_offset_increment (float): Hatching offset increment.\n        hatching_back_n_forth (bool): Whether hatching is back and forth.\n        mesh_z_offset (float): Mesh Z offset.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"25x_IP-n162_default\",\n        valid_objectives: List[str] = None,\n        valid_resins: List[str] = None,\n        valid_substrates: List[str] = None,\n        writing_speed: float = 250000.0,\n        writing_power: float = 50.0,\n        slicing_spacing: float = 0.8,\n        hatching_spacing: float = 0.3,\n        hatching_angle: float = 0.0,\n        hatching_angle_increment: float = 0.0,\n        hatching_offset: float = 0.0,\n        hatching_offset_increment: float = 0.0,\n        hatching_back_n_forth: bool = True,\n        mesh_z_offset: float = 0.0,\n    ):\n\n        # Default lists for valid_objectives, valid_resins, valid_substrates\n        self._valid_objectives = None\n        self._valid_resins = None\n        self._valid_substrates = None\n\n        # Set attributes via setters\n        self.name = name\n        self.valid_objectives = (\n            valid_objectives if valid_objectives else [\"25x\"]\n        )\n        self.valid_resins = valid_resins if valid_resins else [\"IP-n162\"]\n        self.valid_substrates = valid_substrates if valid_substrates else [\"*\"]\n        self.writing_speed = writing_speed\n        self.writing_power = writing_power\n        self.slicing_spacing = slicing_spacing\n        self.hatching_spacing = hatching_spacing\n        self.hatching_angle = hatching_angle\n        self.hatching_angle_increment = hatching_angle_increment\n        self.hatching_offset = hatching_offset\n        self.hatching_offset_increment = hatching_offset_increment\n        self.hatching_back_n_forth = hatching_back_n_forth\n        self.mesh_z_offset = mesh_z_offset\n        self.grayscale_multilayer_enabled = False\n        self.grayscale_layer_profile_nr_layers = 6\n        self.grayscale_writing_power_minimum = 0.0\n        self.grayscale_exponent = 1.0\n        self.id = str(uuid.uuid4())\n\n    # Setters and validation logic for all attributes\n    @property\n    def name(self):\n        return self._name\n\n    @name.setter\n    def name(self, value: str):\n        value = str(value)\n        if not isinstance(value, str) or not value.strip():\n            raise ValueError(\"name must be a non-empty string.\")\n        self._name = value\n\n    @property\n    def valid_objectives(self):\n        return self._valid_objectives\n\n    @valid_objectives.setter\n    def valid_objectives(self, value):\n        # Replace all occurrences of \"10x\" with \"10xW\" before proceeding\n        value = [\"10xW\" if obj == \"10x\" else obj for obj in value]\n\n        valid_objectives_set = {\"10xW\", \"25x\", \"63x\", \"*\"}\n        if not set(value).issubset(valid_objectives_set):\n            raise ValueError(f\"Invalid valid_objectives: {value}\")\n        self._valid_objectives = value\n\n    @property\n    def valid_resins(self):\n        return self._valid_resins\n\n    @valid_resins.setter\n    def valid_resins(self, value):\n        valid_resins_set = {\n            \"IP-Dip\",\n            \"IP-Dip2\",\n            \"IP-L\",\n            \"IP-n162\",\n            \"IP-PDMS\",\n            \"IP-S\",\n            \"IP-Visio\",\n            \"IPX-Clear\",\n            \"IPX-Q\",\n            \"IPX-S\",\n            \"*\",\n        }\n        if not set(value).issubset(valid_resins_set):\n            raise ValueError(f\"Invalid valid_resins: {value}\")\n        self._valid_resins = value\n\n    @property\n    def valid_substrates(self):\n        return self._valid_substrates\n\n    @valid_substrates.setter\n    def valid_substrates(self, value):\n        valid_substrates_set = {\"*\", \"FuSi\", \"Si\"}\n        if not set(value).issubset(valid_substrates_set):\n            raise ValueError(f\"Invalid valid_substrates: {value}\")\n        self._valid_substrates = value\n\n    @property\n    def writing_speed(self):\n        return self._writing_speed\n\n    @writing_speed.setter\n    def writing_speed(self, value):\n        value = float(value)  # Type coercion\n        if value &lt;= 0:\n            raise ValueError(\n                f\"writing_speed must be greater than 0. Got {value}\"\n            )\n        self._writing_speed = value\n\n    @property\n    def writing_power(self):\n        return self._writing_power\n\n    @writing_power.setter\n    def writing_power(self, value):\n        value = float(value)  # Type coercion\n        if value &lt; 0:\n            raise ValueError(\n                f\"writing_power must be greater or equal to 0. Got {value}\"\n            )\n        self._writing_power = value\n\n    @property\n    def slicing_spacing(self):\n        return self._slicing_spacing\n\n    @slicing_spacing.setter\n    def slicing_spacing(self, value):\n        value = float(value)\n        if value &lt;= 0:\n            raise ValueError(\n                f\"slicing_spacing must be greater than 0. Got {value}\"\n            )\n        self._slicing_spacing = value\n\n    @property\n    def hatching_spacing(self):\n        return self._hatching_spacing\n\n    @hatching_spacing.setter\n    def hatching_spacing(self, value):\n        value = float(value)\n        if value &lt;= 0:\n            raise ValueError(\n                f\"hatching_spacing must be greater than 0. Got {value}\"\n            )\n        self._hatching_spacing = value\n\n    @property\n    def hatching_angle(self):\n        return self._hatching_angle\n\n    @hatching_angle.setter\n    def hatching_angle(self, value):\n        self._hatching_angle = float(value)\n\n    @property\n    def hatching_angle_increment(self):\n        return self._hatching_angle_increment\n\n    @hatching_angle_increment.setter\n    def hatching_angle_increment(self, value):\n        self._hatching_angle_increment = float(value)\n\n    @property\n    def hatching_offset(self):\n        return self._hatching_offset\n\n    @hatching_offset.setter\n    def hatching_offset(self, value):\n        self._hatching_offset = float(value)\n\n    @property\n    def hatching_offset_increment(self):\n        return self._hatching_offset_increment\n\n    @hatching_offset_increment.setter\n    def hatching_offset_increment(self, value):\n        self._hatching_offset_increment = float(value)\n\n    @property\n    def hatching_back_n_forth(self):\n        return self._hatching_back_n_forth\n\n    @hatching_back_n_forth.setter\n    def hatching_back_n_forth(self, value):\n        if not isinstance(value, bool):\n            raise ValueError(\n                f\"hatching_back_n_forth must be a boolean. Got {type(value).__name__}\"\n            )\n        self._hatching_back_n_forth = value\n\n    @property\n    def mesh_z_offset(self):\n        return self._mesh_z_offset\n\n    @mesh_z_offset.setter\n    def mesh_z_offset(self, value):\n        self._mesh_z_offset = float(value)\n\n    @property\n    def grayscale_layer_profile_nr_layers(self):\n        return self._grayscale_layer_profile_nr_layers\n\n    @grayscale_layer_profile_nr_layers.setter\n    def grayscale_layer_profile_nr_layers(self, value):\n        value = float(value)\n        if value &lt; 0:\n            raise ValueError(\n                f\"grayscale_layer_profile_nr_layers must be greater or equal to 0. Got {value}\"\n            )\n        self._grayscale_layer_profile_nr_layers = value\n\n    @property\n    def grayscale_writing_power_minimum(self):\n        return self._grayscale_writing_power_minimum\n\n    @grayscale_writing_power_minimum.setter\n    def grayscale_writing_power_minimum(self, value):\n        value = float(value)\n        if value &lt; 0:\n            raise ValueError(\n                f\"grayscale_writing_power_minimum must be greater or equal to 0. Got {value}\"\n            )\n        self._grayscale_writing_power_minimum = value\n\n    @property\n    def grayscale_exponent(self):\n        return self._grayscale_exponent\n\n    @grayscale_exponent.setter\n    def grayscale_exponent(self, value):\n        value = float(value)\n        if value &lt;= 0:\n            raise ValueError(\n                f\"grayscale_exponent must be greater than 0. Got {value}\"\n            )\n        self._grayscale_exponent = value\n\n    def set_grayscale_multilayer(\n        self,\n        grayscale_layer_profile_nr_layers: float = 6.0,\n        grayscale_writing_power_minimum: float = 0.0,\n        grayscale_exponent: float = 1.0,\n    ) -&gt; \"Preset\":\n        \"\"\"\n        Enable grayscale multilayer and set the related attributes.\n        grayscale_layer_profile_nr_layers (float): Number of layers for\n            grayscale layer profile.\n        grayscale_writing_power_minimum (float): Minimum writing power for\n            grayscale.\n        grayscale_exponent (float): Grayscale exponent.\n        \"\"\"\n        self.grayscale_layer_profile_nr_layers = (\n            grayscale_layer_profile_nr_layers\n        )\n        self.grayscale_writing_power_minimum = grayscale_writing_power_minimum\n        self.grayscale_exponent = grayscale_exponent\n        self.grayscale_multilayer_enabled = True\n        return self\n\n    def duplicate(self) -&gt; \"Preset\":\n        \"\"\"\n        Create a duplicate of the current preset instance.\n\n        Returns:\n            Preset: A duplicate of the current preset instance.\n        \"\"\"\n        duplicate = copy.copy(self)\n        duplicate.id = str(uuid.uuid4())\n        return duplicate\n\n    @classmethod\n    def load_single(cls, file_path: str, fresh_id: bool = True) -&gt; \"Preset\":\n        \"\"\"\n        Load a single preset from a valid .toml file containing\n        preset data only.\n\n        Parameters:\n            file_path (str): The path to the .toml file.\n            fresh_id (bool): Whether to assign a fresh ID to the loaded preset.\n\n        Returns:\n            Preset: The loaded preset instance.\n\n        Raises:\n            FileNotFoundError: If the file at file_path does not exist.\n            toml.TomlDecodeError: If there is an error decoding the TOML file.\n        \"\"\"\n        if not os.path.isfile(file_path):\n            raise FileNotFoundError(f\"File not found: {file_path}\")\n\n        with open(file_path, \"r\") as toml_file:\n            data = toml.load(toml_file)\n\n        # Create a new Preset instance using the setters\n        try:\n            instance = cls(\n                name=data.get(\n                    \"name\", os.path.splitext(os.path.basename(file_path))[0]\n                ),\n                valid_objectives=data.get(\"valid_objectives\", [\"25x\"]),\n                valid_resins=data.get(\"valid_resins\", [\"IP-n162\"]),\n                valid_substrates=data.get(\"valid_substrates\", [\"*\"]),\n                writing_speed=data.get(\"writing_speed\", 250000.0),\n                writing_power=data.get(\"writing_power\", 50.0),\n                slicing_spacing=data.get(\"slicing_spacing\", 0.8),\n                hatching_spacing=data.get(\"hatching_spacing\", 0.3),\n                hatching_angle=data.get(\"hatching_angle\", 0.0),\n                hatching_angle_increment=data.get(\n                    \"hatching_angle_increment\", 0.0\n                ),\n                hatching_offset=data.get(\"hatching_offset\", 0.0),\n                hatching_offset_increment=data.get(\n                    \"hatching_offset_increment\", 0.0\n                ),\n                hatching_back_n_forth=data.get(\"hatching_back_n_forth\", True),\n                mesh_z_offset=data.get(\"mesh_z_offset\", 0.0),\n            )\n\n            instance.grayscale_multilayer_enabled = data.get(\n                \"grayscale_multilayer_enabled\", False\n            )\n            instance.grayscale_layer_profile_nr_layers = data.get(\n                \"grayscale_layer_profile_nr_layers\", 6\n            )\n            instance.grayscale_writing_power_minimum = data.get(\n                \"grayscale_writing_power_minimum\", 0.0\n            )\n            instance.grayscale_exponent = data.get(\"grayscale_exponent\", 1.0)\n\n        except Exception as e:\n            raise ValueError(\n                f\"Error creating Preset from file {file_path}: {e}\"\n            )\n\n        # Optionally assign a new ID if fresh_id is True\n        if not fresh_id:\n            instance.id = data.get(\"id\", instance.id)\n\n        return instance\n\n    @classmethod\n    def load_multiple(\n        cls,\n        directory_path: str,\n        print_names: bool = False,\n        fresh_id: bool = True,\n    ) -&gt; List[\"Preset\"]:\n        \"\"\"\n        Load multiple presets from a directory containing .toml files.\n\n        Parameters:\n            directory_path (str): The path to the directory containing .toml files.\n            print_names (bool): If True, print the names of the files in the order they are loaded.\n            fresh_id (bool): Whether to assign fresh IDs to the loaded presets.\n\n        Returns:\n            List[Preset]: A list of loaded preset instances.\n\n        Raises:\n            FileNotFoundError: If the directory_path does not exist.\n        \"\"\"\n        if not os.path.isdir(directory_path):\n            raise FileNotFoundError(f\"Directory not found: {directory_path}\")\n\n        presets = []\n        for file_name in sorted(os.listdir(directory_path)):\n            if file_name.endswith(\".toml\"):\n                file_path = os.path.join(directory_path, file_name)\n                preset = cls.load_single(file_path, fresh_id)\n                presets.append(preset)\n                if print_names:\n                    print(file_name)\n        return presets\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Convert the preset to a dictionary format.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of the preset, including\n                            attributes starting with '_', but excluding attributes with '__'.\n                            Leading '_' is removed from keys in the resulting dictionary.\n        \"\"\"\n        preset_dict = {}\n\n        for attr_name, attr_value in self.__dict__.items():\n            # Skip attributes that start with two underscores\n            # Ensures functional backend implementations via self.__interals\n            if attr_name.startswith(\"__\"):\n                continue\n\n            # Remove leading single underscore if present\n            if attr_name.startswith(\"_\"):\n                key = attr_name[1:]  # Remove the leading '_'\n            else:\n                key = attr_name\n\n            preset_dict[key] = attr_value\n\n        return preset_dict\n\n    def export(self, file_path: str = None) -&gt; None:\n        \"\"\"\n        Export the preset to a file that can be loaded by nanoPrintX and/or npxpy.\n\n        Parameters:\n            file_path (str): The path to the .toml file to be created. If not provided,\n                             defaults to the current directory with the preset's name.\n\n        Raises:\n            IOError: If there is an error writing to the file.\n        \"\"\"\n        if file_path is None:\n            file_path = f\"{self.name}.toml\"\n        elif not file_path.endswith(\".toml\"):\n            file_path += \".toml\"\n\n        data = self.to_dict()\n\n        with open(file_path, \"w\") as toml_file:\n            toml.dump(data, toml_file)\n</code></pre>"},{"location":"preset/Preset/#npxpy.preset.Preset.duplicate","title":"<code>duplicate()</code>","text":"<p>Create a duplicate of the current preset instance.</p> <p>Returns:</p> Name Type Description <code>Preset</code> <code>Preset</code> <p>A duplicate of the current preset instance.</p> Source code in <code>npxpy/preset.py</code> <pre><code>def duplicate(self) -&gt; \"Preset\":\n    \"\"\"\n    Create a duplicate of the current preset instance.\n\n    Returns:\n        Preset: A duplicate of the current preset instance.\n    \"\"\"\n    duplicate = copy.copy(self)\n    duplicate.id = str(uuid.uuid4())\n    return duplicate\n</code></pre>"},{"location":"preset/Preset/#npxpy.preset.Preset.export","title":"<code>export(file_path=None)</code>","text":"<p>Export the preset to a file that can be loaded by nanoPrintX and/or npxpy.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the .toml file to be created. If not provided,              defaults to the current directory with the preset's name.</p> <code>None</code> <p>Raises:</p> Type Description <code>IOError</code> <p>If there is an error writing to the file.</p> Source code in <code>npxpy/preset.py</code> <pre><code>def export(self, file_path: str = None) -&gt; None:\n    \"\"\"\n    Export the preset to a file that can be loaded by nanoPrintX and/or npxpy.\n\n    Parameters:\n        file_path (str): The path to the .toml file to be created. If not provided,\n                         defaults to the current directory with the preset's name.\n\n    Raises:\n        IOError: If there is an error writing to the file.\n    \"\"\"\n    if file_path is None:\n        file_path = f\"{self.name}.toml\"\n    elif not file_path.endswith(\".toml\"):\n        file_path += \".toml\"\n\n    data = self.to_dict()\n\n    with open(file_path, \"w\") as toml_file:\n        toml.dump(data, toml_file)\n</code></pre>"},{"location":"preset/Preset/#npxpy.preset.Preset.load_multiple","title":"<code>load_multiple(directory_path, print_names=False, fresh_id=True)</code>  <code>classmethod</code>","text":"<p>Load multiple presets from a directory containing .toml files.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>str</code> <p>The path to the directory containing .toml files.</p> required <code>print_names</code> <code>bool</code> <p>If True, print the names of the files in the order they are loaded.</p> <code>False</code> <code>fresh_id</code> <code>bool</code> <p>Whether to assign fresh IDs to the loaded presets.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Preset]</code> <p>List[Preset]: A list of loaded preset instances.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the directory_path does not exist.</p> Source code in <code>npxpy/preset.py</code> <pre><code>@classmethod\ndef load_multiple(\n    cls,\n    directory_path: str,\n    print_names: bool = False,\n    fresh_id: bool = True,\n) -&gt; List[\"Preset\"]:\n    \"\"\"\n    Load multiple presets from a directory containing .toml files.\n\n    Parameters:\n        directory_path (str): The path to the directory containing .toml files.\n        print_names (bool): If True, print the names of the files in the order they are loaded.\n        fresh_id (bool): Whether to assign fresh IDs to the loaded presets.\n\n    Returns:\n        List[Preset]: A list of loaded preset instances.\n\n    Raises:\n        FileNotFoundError: If the directory_path does not exist.\n    \"\"\"\n    if not os.path.isdir(directory_path):\n        raise FileNotFoundError(f\"Directory not found: {directory_path}\")\n\n    presets = []\n    for file_name in sorted(os.listdir(directory_path)):\n        if file_name.endswith(\".toml\"):\n            file_path = os.path.join(directory_path, file_name)\n            preset = cls.load_single(file_path, fresh_id)\n            presets.append(preset)\n            if print_names:\n                print(file_name)\n    return presets\n</code></pre>"},{"location":"preset/Preset/#npxpy.preset.Preset.load_single","title":"<code>load_single(file_path, fresh_id=True)</code>  <code>classmethod</code>","text":"<p>Load a single preset from a valid .toml file containing preset data only.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the .toml file.</p> required <code>fresh_id</code> <code>bool</code> <p>Whether to assign a fresh ID to the loaded preset.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Preset</code> <code>Preset</code> <p>The loaded preset instance.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file at file_path does not exist.</p> <code>TomlDecodeError</code> <p>If there is an error decoding the TOML file.</p> Source code in <code>npxpy/preset.py</code> <pre><code>@classmethod\ndef load_single(cls, file_path: str, fresh_id: bool = True) -&gt; \"Preset\":\n    \"\"\"\n    Load a single preset from a valid .toml file containing\n    preset data only.\n\n    Parameters:\n        file_path (str): The path to the .toml file.\n        fresh_id (bool): Whether to assign a fresh ID to the loaded preset.\n\n    Returns:\n        Preset: The loaded preset instance.\n\n    Raises:\n        FileNotFoundError: If the file at file_path does not exist.\n        toml.TomlDecodeError: If there is an error decoding the TOML file.\n    \"\"\"\n    if not os.path.isfile(file_path):\n        raise FileNotFoundError(f\"File not found: {file_path}\")\n\n    with open(file_path, \"r\") as toml_file:\n        data = toml.load(toml_file)\n\n    # Create a new Preset instance using the setters\n    try:\n        instance = cls(\n            name=data.get(\n                \"name\", os.path.splitext(os.path.basename(file_path))[0]\n            ),\n            valid_objectives=data.get(\"valid_objectives\", [\"25x\"]),\n            valid_resins=data.get(\"valid_resins\", [\"IP-n162\"]),\n            valid_substrates=data.get(\"valid_substrates\", [\"*\"]),\n            writing_speed=data.get(\"writing_speed\", 250000.0),\n            writing_power=data.get(\"writing_power\", 50.0),\n            slicing_spacing=data.get(\"slicing_spacing\", 0.8),\n            hatching_spacing=data.get(\"hatching_spacing\", 0.3),\n            hatching_angle=data.get(\"hatching_angle\", 0.0),\n            hatching_angle_increment=data.get(\n                \"hatching_angle_increment\", 0.0\n            ),\n            hatching_offset=data.get(\"hatching_offset\", 0.0),\n            hatching_offset_increment=data.get(\n                \"hatching_offset_increment\", 0.0\n            ),\n            hatching_back_n_forth=data.get(\"hatching_back_n_forth\", True),\n            mesh_z_offset=data.get(\"mesh_z_offset\", 0.0),\n        )\n\n        instance.grayscale_multilayer_enabled = data.get(\n            \"grayscale_multilayer_enabled\", False\n        )\n        instance.grayscale_layer_profile_nr_layers = data.get(\n            \"grayscale_layer_profile_nr_layers\", 6\n        )\n        instance.grayscale_writing_power_minimum = data.get(\n            \"grayscale_writing_power_minimum\", 0.0\n        )\n        instance.grayscale_exponent = data.get(\"grayscale_exponent\", 1.0)\n\n    except Exception as e:\n        raise ValueError(\n            f\"Error creating Preset from file {file_path}: {e}\"\n        )\n\n    # Optionally assign a new ID if fresh_id is True\n    if not fresh_id:\n        instance.id = data.get(\"id\", instance.id)\n\n    return instance\n</code></pre>"},{"location":"preset/Preset/#npxpy.preset.Preset.set_grayscale_multilayer","title":"<code>set_grayscale_multilayer(grayscale_layer_profile_nr_layers=6.0, grayscale_writing_power_minimum=0.0, grayscale_exponent=1.0)</code>","text":"<p>Enable grayscale multilayer and set the related attributes. grayscale_layer_profile_nr_layers (float): Number of layers for     grayscale layer profile. grayscale_writing_power_minimum (float): Minimum writing power for     grayscale. grayscale_exponent (float): Grayscale exponent.</p> Source code in <code>npxpy/preset.py</code> <pre><code>def set_grayscale_multilayer(\n    self,\n    grayscale_layer_profile_nr_layers: float = 6.0,\n    grayscale_writing_power_minimum: float = 0.0,\n    grayscale_exponent: float = 1.0,\n) -&gt; \"Preset\":\n    \"\"\"\n    Enable grayscale multilayer and set the related attributes.\n    grayscale_layer_profile_nr_layers (float): Number of layers for\n        grayscale layer profile.\n    grayscale_writing_power_minimum (float): Minimum writing power for\n        grayscale.\n    grayscale_exponent (float): Grayscale exponent.\n    \"\"\"\n    self.grayscale_layer_profile_nr_layers = (\n        grayscale_layer_profile_nr_layers\n    )\n    self.grayscale_writing_power_minimum = grayscale_writing_power_minimum\n    self.grayscale_exponent = grayscale_exponent\n    self.grayscale_multilayer_enabled = True\n    return self\n</code></pre>"},{"location":"preset/Preset/#npxpy.preset.Preset.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the preset to a dictionary format.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of the preset, including             attributes starting with '', but excluding attributes with '__'.             Leading '' is removed from keys in the resulting dictionary.</p> Source code in <code>npxpy/preset.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert the preset to a dictionary format.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of the preset, including\n                        attributes starting with '_', but excluding attributes with '__'.\n                        Leading '_' is removed from keys in the resulting dictionary.\n    \"\"\"\n    preset_dict = {}\n\n    for attr_name, attr_value in self.__dict__.items():\n        # Skip attributes that start with two underscores\n        # Ensures functional backend implementations via self.__interals\n        if attr_name.startswith(\"__\"):\n            continue\n\n        # Remove leading single underscore if present\n        if attr_name.startswith(\"_\"):\n            key = attr_name[1:]  # Remove the leading '_'\n        else:\n            key = attr_name\n\n        preset_dict[key] = attr_value\n\n    return preset_dict\n</code></pre>"},{"location":"resources/Image/","title":"npxpy.resources.Image","text":"<p>               Bases: <code>Resource</code></p> <p>A class to represent an image resource.</p> Source code in <code>npxpy/resources.py</code> <pre><code>class Image(Resource):\n    \"\"\"\n    A class to represent an image resource.\n    \"\"\"\n\n    def __init__(self, file_path: str, name: str = \"image\"):\n        \"\"\"\n        Initialize the image resource with the specified parameters.\n\n        Parameters:\n            file_path (str): Path where the image is stored.\n            name (str, optional): Name of the image resource. Defaults to 'image'.\n        \"\"\"\n        # Ensure the file_path is valid\n        if not os.path.isfile(file_path):\n            raise FileNotFoundError(f\"Image file not found: {file_path}\")\n\n        super().__init__(\n            resource_type=\"image_file\", name=name, file_path=file_path\n        )\n</code></pre>"},{"location":"resources/Image/#npxpy.resources.Image.__init__","title":"<code>__init__(file_path, name='image')</code>","text":"<p>Initialize the image resource with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path where the image is stored.</p> required <code>name</code> <code>str</code> <p>Name of the image resource. Defaults to 'image'.</p> <code>'image'</code> Source code in <code>npxpy/resources.py</code> <pre><code>def __init__(self, file_path: str, name: str = \"image\"):\n    \"\"\"\n    Initialize the image resource with the specified parameters.\n\n    Parameters:\n        file_path (str): Path where the image is stored.\n        name (str, optional): Name of the image resource. Defaults to 'image'.\n    \"\"\"\n    # Ensure the file_path is valid\n    if not os.path.isfile(file_path):\n        raise FileNotFoundError(f\"Image file not found: {file_path}\")\n\n    super().__init__(\n        resource_type=\"image_file\", name=name, file_path=file_path\n    )\n</code></pre>"},{"location":"resources/Mesh/","title":"npxpy.resources.Mesh","text":"<p>               Bases: <code>Resource</code></p> <p>A class to represent a mesh resource with attributes such as translation, rotation, scale, etc.</p> <p>Attributes:</p> Name Type Description <code>translation</code> <code>List[float]</code> <p>Translation values [x, y, z].</p> <code>rotation</code> <code>List[float]</code> <p>Rotation values [psi, theta, phi].</p> <code>scale</code> <code>List[float]</code> <p>Scale values [x, y, z].</p> <code>enhance_mesh</code> <code>bool</code> <p>Whether to enhance the mesh.</p> <code>simplify_mesh</code> <code>bool</code> <p>Whether to simplify the mesh.</p> <code>target_ratio</code> <code>float</code> <p>Target ratio for mesh simplification.</p> Source code in <code>npxpy/resources.py</code> <pre><code>class Mesh(Resource):\n    \"\"\"\n    A class to represent a mesh resource with attributes such as translation, rotation, scale, etc.\n\n    Attributes:\n        translation (List[float]): Translation values [x, y, z].\n        rotation (List[float]): Rotation values [psi, theta, phi].\n        scale (List[float]): Scale values [x, y, z].\n        enhance_mesh (bool): Whether to enhance the mesh.\n        simplify_mesh (bool): Whether to simplify the mesh.\n        target_ratio (float): Target ratio for mesh simplification.\n    \"\"\"\n\n    def __init__(\n        self,\n        file_path: str,\n        name: str = \"mesh\",\n        translation: List[float] = [0, 0, 0],\n        auto_center: bool = False,\n        rotation: List[float] = [0.0, 0.0, 0.0],\n        scale: List[float] = [1.0, 1.0, 1.0],\n        enhance_mesh: bool = True,\n        simplify_mesh: bool = False,\n        target_ratio: float = 100.0,\n    ):\n        \"\"\"\n        Initialize the mesh resource with the specified parameters.\n\n        Parameters:\n            file_path (str): Path where the mesh is stored (original file location).\n            name (str, optional): Name of the mesh resource. Defaults to 'mesh'.\n            translation (List[float], optional): Translation values [x, y, z]. Defaults to [0, 0, 0].\n            auto_center (bool, optional): Whether to auto-center the mesh. Defaults to False.\n            rotation (List[float], optional): Rotation values [psi, theta, phi]. Defaults to [0.0, 0.0, 0.0].\n            scale (List[float], optional): Scale values [x, y, z]. Defaults to [1.0, 1.0, 1.0].\n            enhance_mesh (bool, optional): Whether to enhance the mesh. Defaults to True.\n            simplify_mesh (bool, optional): Whether to simplify the mesh. Defaults to False.\n            target_ratio (float, optional): Target ratio for mesh simplification. Defaults to 100.0.\n        \"\"\"\n        super().__init__(\n            resource_type=\"mesh_file\", name=name, file_path=file_path\n        )\n\n        # Set attributes with validation\n        self.translation = translation\n        self.auto_center = auto_center\n        self.rotation = rotation\n        self.scale = scale\n        self.enhance_mesh = enhance_mesh\n        self.simplify_mesh = simplify_mesh\n        self.target_ratio = target_ratio\n        self.original_triangle_count = self._get_triangle_count(file_path)\n\n        # Load the mesh data\n        self.mesh_data = stl_mesh.Mesh.from_file(file_path)\n\n        # Apply auto-centering if enabled\n        if self.auto_center:\n            self._auto_center()\n\n    @property\n    def translation(self):\n        return self._translation\n\n    @translation.setter\n    def translation(self, value: List[Any]):\n        if len(value) != 3:\n            raise ValueError(\n                \"Translation must have exactly 3 elements [x, y, z]\"\n            )\n        try:\n            self._translation = [float(v) for v in value]\n        except ValueError:\n            raise ValueError(\"Translation elements must be numeric values.\")\n\n    @property\n    def rotation(self):\n        return self._rotation\n\n    @rotation.setter\n    def rotation(self, value: List[Any]):\n        if len(value) != 3:\n            raise ValueError(\n                \"Rotation must have exactly 3 elements [psi, theta, phi]\"\n            )\n        try:\n            self._rotation = [float(v) for v in value]\n        except ValueError:\n            raise ValueError(\"Rotation elements must be numeric values.\")\n\n    @property\n    def scale(self):\n        return self._scale\n\n    @scale.setter\n    def scale(self, value: List[Any]):\n        if len(value) != 3:\n            raise ValueError(\"Scale must have exactly 3 elements [x, y, z]\")\n        try:\n            self._scale = [float(v) for v in value]\n        except ValueError:\n            raise ValueError(\"Scale elements must be numeric values.\")\n\n    @property\n    def target_ratio(self):\n        return self._target_ratio\n\n    @target_ratio.setter\n    def target_ratio(self, value: Any):\n        try:\n            value = float(value)\n        except ValueError:\n            raise ValueError(\"Target ratio must be a numeric value.\")\n        if not (0 &lt;= value &lt;= 100):\n            raise ValueError(\"Target ratio must be between 0 and 100\")\n        self._target_ratio = value\n\n    def _auto_center(self):\n        \"\"\"\n        Auto-center the mesh by translating it so the bounding box center aligns with the origin\n        in the x and y axes, and the lowest z coordinate is set to 0.\n        \"\"\"\n        all_vertices = self.mesh_data.vectors.reshape(-1, 3)\n\n        # Calculate the min and max coordinates for bounding box\n        min_coords = all_vertices.min(axis=0)\n        max_coords = all_vertices.max(axis=0)\n\n        # Center x and y by calculating the bounding box center\n        bounding_box_center = (min_coords + max_coords) / 2.0\n        bounding_box_center[2] = min_coords[2]  # For z, use the lowest point\n\n        # Calculate the translation\n        translation = -bounding_box_center\n        translation[2] = -min_coords[\n            2\n        ]  # Translate only enough to set the lowest z to 0\n\n        # Apply the translation to the mesh\n        self.mesh_data.translate(translation)\n\n        # Update translation property to reflect the applied translation\n        self.translation = [\n            t + c for t, c in zip(self.translation, translation)\n        ]\n\n    def _get_triangle_count(self, path: str) -&gt; int:\n        \"\"\"\n        Get the number of triangles in the mesh.\n\n        Parameters:\n            path (str): Path to the mesh file.\n\n        Returns:\n            int: Number of triangles in the mesh.\n\n        Raises:\n            FileNotFoundError: If the mesh file does not exist.\n            Exception: If there is an error reading the STL file.\n        \"\"\"\n        if not os.path.isfile(path):\n            raise FileNotFoundError(f\"Mesh file not found: {path}\")\n\n        try:\n            mesh_data = stl_mesh.Mesh.from_file(path)\n            return len(mesh_data.vectors)\n        except Exception as e:\n            raise Exception(f\"Error reading STL file: {e}\")\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the current state of the object into a dictionary representation.\n\n        Returns:\n            dict: Dictionary representation of the current state of the object.\n        \"\"\"\n        resource_dict = super().to_dict()\n        resource_dict.update(\n            {\n                \"translation\": self.translation,\n                \"auto_center\": self.auto_center,\n                \"rotation\": self.rotation,\n                \"scale\": self.scale,\n                \"enhance_mesh\": self.enhance_mesh,\n                \"simplify_mesh\": self.simplify_mesh,\n                \"target_ratio\": self.target_ratio,\n                \"properties\": {\n                    \"original_triangle_count\": self.original_triangle_count\n                },\n            }\n        )\n        return resource_dict\n</code></pre>"},{"location":"resources/Mesh/#npxpy.resources.Mesh.__init__","title":"<code>__init__(file_path, name='mesh', translation=[0, 0, 0], auto_center=False, rotation=[0.0, 0.0, 0.0], scale=[1.0, 1.0, 1.0], enhance_mesh=True, simplify_mesh=False, target_ratio=100.0)</code>","text":"<p>Initialize the mesh resource with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path where the mesh is stored (original file location).</p> required <code>name</code> <code>str</code> <p>Name of the mesh resource. Defaults to 'mesh'.</p> <code>'mesh'</code> <code>translation</code> <code>List[float]</code> <p>Translation values [x, y, z]. Defaults to [0, 0, 0].</p> <code>[0, 0, 0]</code> <code>auto_center</code> <code>bool</code> <p>Whether to auto-center the mesh. Defaults to False.</p> <code>False</code> <code>rotation</code> <code>List[float]</code> <p>Rotation values [psi, theta, phi]. Defaults to [0.0, 0.0, 0.0].</p> <code>[0.0, 0.0, 0.0]</code> <code>scale</code> <code>List[float]</code> <p>Scale values [x, y, z]. Defaults to [1.0, 1.0, 1.0].</p> <code>[1.0, 1.0, 1.0]</code> <code>enhance_mesh</code> <code>bool</code> <p>Whether to enhance the mesh. Defaults to True.</p> <code>True</code> <code>simplify_mesh</code> <code>bool</code> <p>Whether to simplify the mesh. Defaults to False.</p> <code>False</code> <code>target_ratio</code> <code>float</code> <p>Target ratio for mesh simplification. Defaults to 100.0.</p> <code>100.0</code> Source code in <code>npxpy/resources.py</code> <pre><code>def __init__(\n    self,\n    file_path: str,\n    name: str = \"mesh\",\n    translation: List[float] = [0, 0, 0],\n    auto_center: bool = False,\n    rotation: List[float] = [0.0, 0.0, 0.0],\n    scale: List[float] = [1.0, 1.0, 1.0],\n    enhance_mesh: bool = True,\n    simplify_mesh: bool = False,\n    target_ratio: float = 100.0,\n):\n    \"\"\"\n    Initialize the mesh resource with the specified parameters.\n\n    Parameters:\n        file_path (str): Path where the mesh is stored (original file location).\n        name (str, optional): Name of the mesh resource. Defaults to 'mesh'.\n        translation (List[float], optional): Translation values [x, y, z]. Defaults to [0, 0, 0].\n        auto_center (bool, optional): Whether to auto-center the mesh. Defaults to False.\n        rotation (List[float], optional): Rotation values [psi, theta, phi]. Defaults to [0.0, 0.0, 0.0].\n        scale (List[float], optional): Scale values [x, y, z]. Defaults to [1.0, 1.0, 1.0].\n        enhance_mesh (bool, optional): Whether to enhance the mesh. Defaults to True.\n        simplify_mesh (bool, optional): Whether to simplify the mesh. Defaults to False.\n        target_ratio (float, optional): Target ratio for mesh simplification. Defaults to 100.0.\n    \"\"\"\n    super().__init__(\n        resource_type=\"mesh_file\", name=name, file_path=file_path\n    )\n\n    # Set attributes with validation\n    self.translation = translation\n    self.auto_center = auto_center\n    self.rotation = rotation\n    self.scale = scale\n    self.enhance_mesh = enhance_mesh\n    self.simplify_mesh = simplify_mesh\n    self.target_ratio = target_ratio\n    self.original_triangle_count = self._get_triangle_count(file_path)\n\n    # Load the mesh data\n    self.mesh_data = stl_mesh.Mesh.from_file(file_path)\n\n    # Apply auto-centering if enabled\n    if self.auto_center:\n        self._auto_center()\n</code></pre>"},{"location":"resources/Mesh/#npxpy.resources.Mesh.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the current state of the object into a dictionary representation.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>Dictionary representation of the current state of the object.</p> Source code in <code>npxpy/resources.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the current state of the object into a dictionary representation.\n\n    Returns:\n        dict: Dictionary representation of the current state of the object.\n    \"\"\"\n    resource_dict = super().to_dict()\n    resource_dict.update(\n        {\n            \"translation\": self.translation,\n            \"auto_center\": self.auto_center,\n            \"rotation\": self.rotation,\n            \"scale\": self.scale,\n            \"enhance_mesh\": self.enhance_mesh,\n            \"simplify_mesh\": self.simplify_mesh,\n            \"target_ratio\": self.target_ratio,\n            \"properties\": {\n                \"original_triangle_count\": self.original_triangle_count\n            },\n        }\n    )\n    return resource_dict\n</code></pre>"},{"location":"resources/resources/","title":"Resources Module","text":"<p>A class to represent a generic resource.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for the resource.</p> <code>name</code> <code>str</code> <p>Name of the resource.</p> <code>safe_path</code> <code>str</code> <p>Path where the resource is stored, based on file hash.</p> <code>file_path</code> <code>str</code> <p>Original path from where the resource was loaded.</p> Source code in <code>npxpy/resources.py</code> <pre><code>class Resource:\n    \"\"\"\n    A class to represent a generic resource.\n\n    Attributes:\n        id (str): Unique identifier for the resource.\n        name (str): Name of the resource.\n        safe_path (str): Path where the resource is stored, based on file hash.\n        file_path (str): Original path from where the resource was loaded.\n    \"\"\"\n\n    def __init__(self, resource_type: str, name: str, file_path: str):\n        \"\"\"\n        Initialize the resource with the specified parameters.\n\n        Parameters:\n            resource_type (str): Type of the resource.\n            name (str): Name of the resource.\n            file_path (str): Path where the resource is loaded from.\n        \"\"\"\n        if not name or not name.strip():\n            raise ValueError(\n                \"Resource: The 'name' parameter must not be an empty string.\"\n            )\n\n        self.id = str(uuid.uuid4())\n        self._type = resource_type\n        self.name = name\n        self.file_path = file_path\n        self.safe_path = self.generate_safe_path(file_path)\n\n    @property\n    def name(self):\n        \"\"\"Return the name of the resource.\"\"\"\n        return self._name\n\n    @name.setter\n    def name(self, value: str):\n        \"\"\"Set the name of the resource with validation to ensure it is a non-empty string.\"\"\"\n        value = str(value)\n        if not isinstance(value, str) or not value.strip():\n            raise ValueError(\"name must be a non-empty string.\")\n        self._name = value\n\n    def generate_safe_path(self, file_path: str) -&gt; str:\n        \"\"\"\n        Generate a 'safe' path for the resource based on the MD5 hash of the file content.\n\n        Parameters:\n            file_path (str): Path to the file.\n\n        Returns:\n            str: Generated safe path for the resource.\n\n        Raises:\n            FileNotFoundError: If the file at file_path does not exist.\n        \"\"\"\n        if not os.path.isfile(file_path):\n            raise FileNotFoundError(f\"File not found: {file_path}\")\n\n        md5_hash = hashlib.md5()\n        with open(file_path, \"rb\") as file:\n            for chunk in iter(lambda: file.read(4096), b\"\"):\n                md5_hash.update(chunk)\n\n        file_hash = md5_hash.hexdigest()\n        target_path = f\"resources/{file_hash}/{os.path.basename(file_path)}\"\n        return target_path\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the current state of the object into a dictionary representation.\n\n        Returns:\n            dict: Dictionary representation of the current state of the object.\n        \"\"\"\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"type\": self._type,\n            \"path\": self.safe_path,\n        }\n</code></pre>"},{"location":"resources/resources/#npxpy.resources.Resource.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":"<p>Return the name of the resource.</p>"},{"location":"resources/resources/#npxpy.resources.Resource.__init__","title":"<code>__init__(resource_type, name, file_path)</code>","text":"<p>Initialize the resource with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>resource_type</code> <code>str</code> <p>Type of the resource.</p> required <code>name</code> <code>str</code> <p>Name of the resource.</p> required <code>file_path</code> <code>str</code> <p>Path where the resource is loaded from.</p> required Source code in <code>npxpy/resources.py</code> <pre><code>def __init__(self, resource_type: str, name: str, file_path: str):\n    \"\"\"\n    Initialize the resource with the specified parameters.\n\n    Parameters:\n        resource_type (str): Type of the resource.\n        name (str): Name of the resource.\n        file_path (str): Path where the resource is loaded from.\n    \"\"\"\n    if not name or not name.strip():\n        raise ValueError(\n            \"Resource: The 'name' parameter must not be an empty string.\"\n        )\n\n    self.id = str(uuid.uuid4())\n    self._type = resource_type\n    self.name = name\n    self.file_path = file_path\n    self.safe_path = self.generate_safe_path(file_path)\n</code></pre>"},{"location":"resources/resources/#npxpy.resources.Resource.generate_safe_path","title":"<code>generate_safe_path(file_path)</code>","text":"<p>Generate a 'safe' path for the resource based on the MD5 hash of the file content.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the file.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Generated safe path for the resource.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file at file_path does not exist.</p> Source code in <code>npxpy/resources.py</code> <pre><code>def generate_safe_path(self, file_path: str) -&gt; str:\n    \"\"\"\n    Generate a 'safe' path for the resource based on the MD5 hash of the file content.\n\n    Parameters:\n        file_path (str): Path to the file.\n\n    Returns:\n        str: Generated safe path for the resource.\n\n    Raises:\n        FileNotFoundError: If the file at file_path does not exist.\n    \"\"\"\n    if not os.path.isfile(file_path):\n        raise FileNotFoundError(f\"File not found: {file_path}\")\n\n    md5_hash = hashlib.md5()\n    with open(file_path, \"rb\") as file:\n        for chunk in iter(lambda: file.read(4096), b\"\"):\n            md5_hash.update(chunk)\n\n    file_hash = md5_hash.hexdigest()\n    target_path = f\"resources/{file_hash}/{os.path.basename(file_path)}\"\n    return target_path\n</code></pre>"},{"location":"resources/resources/#npxpy.resources.Resource.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the current state of the object into a dictionary representation.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>Dictionary representation of the current state of the object.</p> Source code in <code>npxpy/resources.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the current state of the object into a dictionary representation.\n\n    Returns:\n        dict: Dictionary representation of the current state of the object.\n    \"\"\"\n    return {\n        \"id\": self.id,\n        \"name\": self.name,\n        \"type\": self._type,\n        \"path\": self.safe_path,\n    }\n</code></pre>"}]}